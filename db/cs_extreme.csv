question,question_sub,answer,answer_sub,ef_factor,category_id,created_at,modified_at
해밍 코드란 무엇인가요?,What is Hamming Code?,"통신에서 해밍 코드는 해밍(7,4) 코드를 일반화한 선형 오류 수정 코드 계열로, 1950년 리처드 해밍에 의해 발명되었습니다. 해밍 코드는 수정되지 않은 오류를 감지하지 않고도 최대 2비트 오류를 감지하거나 1비트 오류를 수정할 수 있습니다.","In telecommunication, Hamming codes are a family of linear error-correcting codes that generalize the Hamming(7,4)-code, and were invented by Richard Hamming in 1950. Hamming codes can detect up to two-bit errors or correct one-bit errors without detection of uncorrected errors.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
256의 제곱근은 무엇인가요?,What is the square root of 256?,16,16,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2^16,2^16,"65,536","65,536",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트 단위 연산을 사용하여 숫자가 2의 거듭제곱인지 어떻게 테스트하시겠습니까?,"Using bitwise operations, how would you test that a number is a power of 2?",bool isPowerOfTwo = (x & (x - 1);,bool isPowerOfTwo = (x & (x - 1);,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
ELF는 무엇을 의미하나요?,What does ELF stand for?,"실행 가능하고 연결 가능한 형식.
실행 파일, 객체 코드, 공유 라이브러리, 코어 덤프를 위한 일반적인 표준 파일 형식입니다.","Executable and Linkable Format.
It's a common standard file format for executables, object code, shared libraries, and core dumps.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
지연 장치의 예,example of a latency device,CPU 코어,CPU core,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
처리량 장치의 예,example of a throughput device,GPU 코어,GPU core,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
해밍 거리란 무엇인가요?,What is the Hamming Distance?,같은 길이의 두 이진 문자열 간의 차이 수를 나타내는 데 사용되는 숫자입니다.,A number used to denote the number of differences between two binary strings of the same length.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
컴파일 과정의 5단계는 무엇인가요?,What are the 5 steps of the compiling process?,"어휘 분석
구문 분석
의미 분석
최적화
코드 생성","Lexical Analysis
Parsing
Semantic Analysis
Optimization
Code Generation",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파싱이란 무엇인가요?,What is parsing?,토큰과 토큰 그룹을 트리 구조(파싱 트리)로 결합합니다.,Combining tokens and groups of tokens into a tree structure (a parse tree).,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
어휘 분석이란 무엇인가요?,What is lexical analysis?,프로그램 텍스트를 단어나 토큰으로 나누는 과정.,The process of dividing program text into words or tokens.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
코드 생성이란 무엇인가요?,What is code generation?,고급 프로그램에서 어셈블리 코드로의 번역을 생성합니다. (Linker와 Archiver가 여기서 기계 코드를 생성합니다.),Producing a translation from a high-level program to assembly code. (Linker and Archiver taker over from here to produce machine code),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
4 * 16,4 * 16,64,64,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2 ^ 4,2 ^ 4,16,16,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2^3,2^3,8,8,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2^5,2^5,32,32,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2^6,2^6,64,64,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2^7,2^7,128,128,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2^8,2^8,256,256,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2^9,2^9,512,512,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2^10,2^10,1024,1024,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2^11,2^11,2048,2048,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2^12,2^12,4096,4096,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2^13,2^13,8192,8192,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2^14,2^14,"16,384","16,384",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2^15,2^15,"32,768","32,768",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2^32,2^32,"42억 9,400만",4.294 Billion,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트 단위의 char 크기,size of char in bits,8비트,8 bits,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
문자 크기(바이트 단위),size of char in bytes,1바이트,1 byte,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트 단위의 bool 크기,size of bool in bits,8비트,8 bits,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트 단위의 short 크기,size of short in bits,"16비트(최소), 일반적으로 16비트","16 bits (at least), and 16 commonly",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
바이트 단위의 short 크기,size of short in bytes,"2바이트, 일반적으로 2바이트","2 bytes, and 2 bytes commonly",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
size of int in bits,size of int in bits,"일반적으로 32비트, 최소 16비트","32 bits commonly, at least 16 bits",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
size of int in bytes,size of int in bytes,"일반적으로 4바이트, 최소 2바이트","4 bytes commonly, at least 2 bytes",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트 단위의 long 크기,size of long in bits,"32(최소, 일반적으로 32), 64(LP64)","32 (at least, 32 commonly), 64 on LP64",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
바이트 단위의 long 크기,size of long in bytes,"4바이트, (최소 4바이트, 일반적으로 4바이트), LP64에서 8바이트","4 bytes, (at least 4, and commonly 4), 8 on LP64",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트 단위로 long long의 크기,size of long long in bits,64비트,64 bits,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
바이트 단위로 long 크기,size of long long in bytes,8바이트,8 bytes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트 단위 플로트 크기,size of float in bits,32비트,32 bits,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
플로트 크기(바이트),size of float in bytes,4바이트,4 bytes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트 단위의 두 배 크기,size of double in bits,64비트,64 bits,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
바이트 단위의 두 배 크기,size of double in bytes,8바이트,8 bytes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트 단위 wchar_t 크기,size of wchar_t in bits,16비트,16 bits,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
바이트 단위의 wchar_t 크기,size of wchar_t in bytes,2바이트,2 bytes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
크기가 n인 완전 이진 트리의 레벨은 몇 개인가요?,How many levels in a complete binary tree of size n?,바닥(1 + log(base2)(n)),floor(1 + log(base2)(n)),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
힙을 선형 시간 내에 빌드하려면 어떻게 해야 하나요?,How can build heap be done in linear time?,"크기 n개의 노드를 가진 트리는 높이가 >= h인 바닥(n/2^h)개의 노드를 가질 것입니다.
노드의 마지막 절반은 리프가 되므로 이미 힙 속성을 만족합니다. 노드에 대한 작업을 수행할 필요가 없습니다.
상향식으로 올라가며(마지막 n/2 항목은 무시하고) 힙 속성을 한 번에 한 단계씩 만족시킵니다. 트리 위로 올라가는 각 레벨은 트리 아래 레벨보다 최대 1개 이상의 연산을 수행해야 합니다. 하지만 트리 위로 올라갈수록 더 높은 레벨의 노드 수가 줄어들어 더 많은 연산을 수행할 수 있지만, 이는 더 적은 횟수에 발생합니다.
이것은 시리즈와 비슷합니다:

n/2 - 높이 1: 작업 1
n/4 - 높이 2: 2 작동
n/8 - 높이 3: 3단계 작업
...
바닥으로 가기(n/2^h) - 높이 h: h 작업

n * (1/2 + 2/4 + 3/8 + 4/16 ....) = n * 1 = n","A tree of size n nodes, will have floor(n/2^h) nodes with height >= h.
The last half of nodes will be leaves, so they already satisfy the heap property. No work needs to be done on them.
going bottom-up (ignoring the last n/2 items) and satisfying the heap property one level at a time, each level going up the tree has to do at most 1 operation more than the level below it. But as you go up the tree, higher levels have fewer nodes, so you may be doing more operations, but it happens on fewer number of times.
This resembles a series:

n/2 - height 1: 1 operations
n/4 - height 2: 2 operation
n/8 - height 3: 3 operations
...
going to floor(n/2^h) - height h: h operations

n * (1/2 + 2/4 + 3/8 + 4/16 ....) = n * 1 = n",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
대기열은 보통 어떻게 구현되나요?,How are queues usually implemented?,원형 배열 또는 단일 링크 목록 사용.,Using a Circular Array or Singly Linked List.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
데크는 보통 어떻게 구현되나요?,How is a deque usually implemented?,원형 배열 또는 이중 링크 목록 사용하기.,Using a Circular Array or Doubly Linked List.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트 단위 연산만을 사용하여 2개의 정수를 어떻게 교환하시겠습니까?,How would you swap 2 integers using only bitwise operations?,"a ^ = b
b ^ = a
a ^ = b","a ^= b
b ^= a
a ^= b",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트 문자열에서 끝에서 세 번째 비트를 어떻게 켜시겠습니까?,How would you turn ON the 3rd bit from the end in a bitstring?,x |= (1 < < 2),x |= (1 << 2),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트 문자열에서 끝에서 세 번째 비트를 어떻게 끄시겠습니까?,How would you turn OFF the 3rd bit from the end in a bitstring?,x &= ~(1 << 2);,x &= ~(1 << 2);,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Binary Search Tree란 무엇인가요?,What is a Binary Search Tree?,"이진 트리는 각 노드가 비교 가능한 키를 가지고 있으며, 해당 노드의 키가 해당 노드의 왼쪽 하위 트리에 있는 모든 노드의 키보다 크고 해당 노드의 오른쪽 하위 트리에 있는 모든 노드의 키보다 작다는 제한을 만족하는 데이터 구조입니다.",A binary tree is a data structure where each node has a comparable key and satisfies the restriction that the key in any node is larger than the keys in all nodes in that node's left subtree and smaller than the keys in all nodes in that node's right subtree.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
AVL Tree란 무엇인가요?,What is an AVL tree?,각 노드의 높이와 형제 노드의 높이가 최대 1씩 다른 BST입니다.,A BST where the height of every node and that of its sibling differ by at most 1.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Red-Black Tree란 무엇인가요?,What is a red-black tree?,"빨간색과 검은색 링크가 만족하는 BST:
- 빨간색 링크가 왼쪽으로 기울어져 있습니다
- 두 개의 링크가 연결된 노드는 없습니다
- 나무는 완벽한 블랙 밸런스를 가지고 있습니다. 루트에서 널 링크까지의 모든 경로는 동일한 수의 블랙을 가지고 있습니다","BSTs having red and black links satisfying:
- Red links lean left
- No node has two links connected to it
- The tree has perfect black balance: every path from the root to a null link has the same number of blacks",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
플레이 트리란 무엇인가요?,What is a splay tree?,최근에 접근한 요소들이 다시 빠르게 접근할 수 있도록 루트로 이동하는 자동 조정 Binary Search Tree입니다.,A self-adjusting binary search tree where recently accessed elements are moved to the root so they are quick to access again.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
트랩이란 무엇인가요?,What is a treap?,"모든 키에 무작위 우선순위가 할당되며 두 가지 속성을 유지해야 합니다:
-그들은 일반적인 Binary Search Tree에서처럼 키에 대해 순서대로 배열되어 있습니다
-우선순위에 따라 힙 순서대로 정렬됩니다. 즉, 어떤 키도 우선순위가 낮은 키를 조상으로 사용하지 않습니다
O(로그 N) 모든 작업에 대한 예상 시간, O(N) 최악의 경우.","A random priority is assigned to every key and must maintain two properties:
-They are in order with respect to their keys, as in a typical binary search tree
-They are in heap order with respect to their priorities, that is, no key has a key of lower priority as an ancestor
O(log N) expected time for all operations, O(N) worst case.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
일반적인 캐시 라인 크기는 무엇인가요?,What is typical cache line size?,"64바이트.

-- 아래 추가 --

크기를 알기 위해서는 프로세서에 대한 설명서를 사용하여 이를 확인해야 합니다. 프로그램적인 방법이 없기 때문입니다. 그러나 긍정적인 측면에서는 대부분의 캐시 라인이 인텔 표준에 기반한 표준 크기입니다. 그러나 x86 캐시 라인은 64바이트이지만, 잘못된 공유를 방지하기 위해 목표로 하는 프로세서의 지침을 따라야 합니다(인텔은 넷버스트 기반 프로세서에 몇 가지 특별한 메모를 가지고 있습니다). 일반적으로 이를 위해 64바이트에 맞춰야 합니다(인텔은 16바이트 경계를 넘지 않아야 한다고 명시하고 있습니다).

C 또는 C++에서 이 작업을 수행하려면 aligned_malloc 또는 __attribute_(((align(64)) 또는 __declspec(align(64))과 같은 컴파일러 특정 지정자 중 하나를 사용해야 합니다. 구조 내의 구성원들 사이를 다른 캐시 라인으로 분할하기 위해 패드를 사용하려면, 다음 64바이트 바운더리에 정렬할 수 있을 만큼 큰 구성원을 삽입해야 합니다","64 bytes.

-- extra below --

To know the sizes, you need to look it up using the documentation for the processor, afaik there is no programatic way to do it. On the plus side however, most cache lines are of a standard size, based on intels standards. On x86 cache lines are 64 bytes, however, to prevent false sharing, you need to follow the guidelines of the processor you are targeting (intel has some special notes on its netburst based processors), generally you need to align to 64 bytes for this (intel states that you should also avoid crossing 16 byte boundries).

To do this in C or C++ requires that you use aligned_malloc or one of the compiler specific specifiers such as __attribute__((align(64))) or __declspec(align(64)). To pad between members in a struct to split them onto different cache lines, you need on insert a member big enough to align it to the next 64 byte boundery",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
지연 시간이란 무엇인가요?,What is latency?,지연 시간은 시스템 입력에서 원하는 결과로 지연되는 시간을 말합니다. 자극과 반응 사이의 시간 간격입니다.,Latency is the delay from input into a system to desired outcome. The time interval between between a stimulus and response.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Y-패스트 트라이란 무엇인가요?,What is a y-fast trie?,"y-패스트 트라이는 유한한 도메인에서 정수를 저장하기 위한 데이터 구조입니다. 이 구조는 O(log log M) 시간 내에 정확한 쿼리와 이전 쿼리 또는 후속 쿼리를 지원하며, 여기서 n은 저장된 값의 수이고 M은 도메인의 최대값입니다. 이 구조는 1982년 댄 윌라드에 의해 x-패스트 트라이가 사용하는 O(n log M) 공간을 줄이기 위해 제안되었습니다.","A y-fast trie is a data structure for storing integers from a bounded domain. It supports exact and predecessor or successor queries in time O(log log M), using O(n) space, where n is the number of stored values and M is the maximum value in the domain. The structure was proposed by Dan Willard in 1982 to decrease the O(n log M) space used by an x-fast trie.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
엑스패스트 트라이란 무엇인가요?,What is an x-fast trie?,"x-패스트 트라이(x-fast trie)는 유한한 도메인에서 정수를 저장하기 위한 데이터 구조입니다. 이 구조는 O(n log M) 공간을 사용하여 O(log log M) 시간 내에 정확한 쿼리와 이전 쿼리 또는 후속 쿼리를 지원합니다. 여기서 n은 저장된 값의 수이고 M은 도메인의 최대값입니다. 이 구조는 1982년 댄 윌라드(Dan Willard)에 의해 제안되었으며, 더 복잡한 y-패스트 트라이와 함께 반 엠데 보아스 트리의 공간 사용을 개선하면서 O(log log M) 쿼리 시간을 유지하기 위한 방법입니다.","An x-fast trie is a data structure for storing integers from a bounded domain. It supports exact and predecessor or successor queries in time O(log log M), using O(n log M) space, where n is the number of stored values and M is the maximum value in the domain. The structure was proposed by Dan Willard in 1982, along with the more complicated y-fast trie, as a way to improve the space usage of van Emde Boas trees, while retaining the O(log log M) query time.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
반 엠데 보아스 나무란 무엇인가요?,What is a van Emde Boas tree?,"The van Emde Boas tree supports insertions, deletions, lookups, successor queries, and predecessor queries in time O(log log U), where U is the universe of items to store. Items are stored in clusters of size sqrt(U). 

The van Emde Boas data structure divides the range {0,...,n−1} into blocks of size sqrt(n), which we call clusters. Each cluster is itself a vEB structure of size sqrt(n). In addition, there is a “summary” structure that keeps track of which clusters are nonempty.

More detail:
A van Emde Boas tree (or van Emde Boas priority queue), also known as a vEB tree, is a tree data structure which implements an associative array with m-bit integer keys. It performs all operations in O(log m) time, or equivalently in O(log log M) time, where M = 2m is the maximum number of elements that can be stored in the tree. The M is not to be confused with the actual number of elements stored in the tree, by which the performance of other tree data-structures is often measured. The vEB tree has good space efficiency when it contains a large number of elements, as discussed below. It was invented by a team led by Dutch computer scientist Peter van Emde Boas in 1975.","The van Emde Boas tree supports insertions, deletions, lookups, successor queries, and predecessor queries in time O(log log U), where U is the universe of items to store. Items are stored in clusters of size sqrt(U). 

The van Emde Boas data structure divides the range {0,...,n−1} into blocks of size sqrt(n), which we call clusters. Each cluster is itself a vEB structure of size sqrt(n). In addition, there is a “summary” structure that keeps track of which clusters are nonempty.

More detail:
A van Emde Boas tree (or van Emde Boas priority queue), also known as a vEB tree, is a tree data structure which implements an associative array with m-bit integer keys. It performs all operations in O(log m) time, or equivalently in O(log log M) time, where M = 2m is the maximum number of elements that can be stored in the tree. The M is not to be confused with the actual number of elements stored in the tree, by which the performance of other tree data-structures is often measured. The vEB tree has good space efficiency when it contains a large number of elements, as discussed below. It was invented by a team led by Dutch computer scientist Peter van Emde Boas in 1975.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
압축 트라이란 무엇인가요?,What is a compressed trie?,비가지 경로가 하나의 가장자리로 압축된 트라이입니다.,It's a trie where the non-branching paths are compacted into a single edge.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
해시 테이블에서는 어떤 키의 관계를 잃나요?,What relationship of the keys do you lose with a hash table?,열쇠의 순서.,The ordering of the keys.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
공백으로 구분된 파일을 새 줄로 변환한 다음 알파벳순으로 정렬하라는 명령입니다.,"Sed command to take a file separated by spaces, turn spaces into newlines, and then sort it alphabetically.",sed's/ /\n/g'words.txt | 정렬,sed 's/ /\n/g' words.txt | sort,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"Print columns 2, 3, and 6 from the date command.","Print columns 2, 3, and 6 from the date command.","date | awk '{print $2, $3, $6}'","date | awk '{print $2, $3, $6}'",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파일을 :로 구분하여 탭 구분으로 만듭니다.,Take a file delimited by : and make it tab-delimited.,고양이 /etc/passwd | sed 's/:/\\t/g',cat /etc/passwd | sed 's/:/\t/g',2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
줄 번호가 있는 파일을 출력합니다.,Output a file with line numbers.,고양이 -n 썸파일,cat -n somefile,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
퀵소트는 안정적인가요?,Is quicksort stable?,아니요.,No.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
퀵소트를 제자리에서 할 수 있나요?,Can quicksort be done in-place?,네.,Yes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Merge Sort을 제자리에서 수행할 수 있나요?,Can merge sort be done in-place?,아니요. O(n) 공간이 필요합니다. 제자리 버전이 있나요?,No. It requires O(n) space. There is an in-place version?,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Merge Sort이 안정적인가요?,Is merge sort stable?,네.,Yes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Insertion Sort이 안정적인가요?,Is insertion sort stable?,네.,Yes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Insertion Sort을 제자리에서 할 수 있나요?,Can insertion sort be done in-place?,네.,Yes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Selection Sort을 제자리에서 할 수 있나요?,Can selection sort be done in-place?,네.,Yes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
선택 항목이 안정적인가요?,Is selection sort stable?,아니요.,No.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Heap Sort은 안정적인가요?,Is heap sort stable?,아니요.,No.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Heap Sort을 제자리에서 할 수 있나요?,Can heap sort be done in-place?,네.,Yes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
어떤 경우에 완벽한 해싱이 실용적일까요?,In what case would perfect hashing be practical?,삽입이나 삭제를 지원할 필요가 없을 때. 데이터는 정적입니다.,When you don't need to support inserts or deletes. The data is static.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
완벽한 해싱은 충돌을 어떻게 처리하나요?,How does perfect hashing handle collisions?,두 번째 해시 함수와 k^2 공간을 사용하여 여러 항목(k)이 있는 버킷에 두 번째 해시 테이블을 생성합니다. 해시 테이블에는 두 가지 해시 레벨이 있습니다. k^2는 마르코프 부등식(생일 역설)이 버킷에서 충돌이 발생하지 않도록 보장하기 때문에 선택됩니다.,"It creates a second hash table in the buckets where there are multiple items (k), using a second hash function, and k^2 space. The hash table has two hashing levels. k^2 is chosen because the Markov inequality (birthday paradox) ensures we will not have collisions in bucket.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
해시 테이블의 최적 부하 계수는 무엇인가요?,What is the optimal load factor for a hash table?,O(sqrt(n)),O(sqrt(n)),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
해시 테이블의 예상 부하 계수는 얼마인가요?,What is the expected load factor for a hash table?,"n/m, 여기서 n = 항목, m = 버킷) n/m은 알파라고도 불립니다.","n/m,  where n = items, m = buckets) n/m is also called alpha.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
해시 테이블에서 작업의 기술적 실행 시간은 어떻게 되나요?,What is the technical running time for operations on a hash table?,"O(1 + alpha), 여기서 alpha는 하중 계수(n/m)입니다. 테이블 더블링 연산은 상각됩니다.","O(1 + alpha), where alpha is the load factor (n/m). Table doubling operations are amortized.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
완벽한 해싱의 최악의 검색 시간은 언제인가요?,What is the worst-case search time of perfect hashing?,O(1),O(1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
완벽한 해싱을 위해 필요한 최악의 공간은 무엇인가요?,What is the worst-case space required for perfect hashing?,O(n),O(n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이진 검색의 가장 좋은 실행 시간은 언제인가요?,What's the best-case running time of binary search?,O(1) - 운이 좋게도 중간 지점에서 요소를 찾습니다.,O(1) - we get lucky and find the element right at the midpoint.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이진 검색의 최악의 실행 시간은 언제인가요?,What's the worst-case running time of binary search?,O(로그 n),O(log n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 행렬을 사용하여 그래프를 표현하는 것의 단점은 무엇인가요?,What are the downsides of using an adjacency matrix to represent a graph?,"정점에서 나가는 모든 간선을 찾는 데는 O(n) 시간이 걸리고, n^2보다 훨씬 적은 간선을 가진 ""희소 그래프""의 경우 O(n^2) 공간 비용이 높습니다.","Finding all the outgoing edges from a vertex takes O(n) time even if there aren't very many, and the O(n^2) space cost is high for ""sparse graphs,"" those with much fewer than n^2 edges.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 목록을 사용하는 것은 언제 비용이 많이 드나요?,When is using an adjacency list expensive?,"노드 u의 이전 노드를 찾는 것은 매우 비용이 많이 들기 때문에 O(n + e) 시간 내에 모든 노드 목록을 살펴봐야 합니다. 여기서 e는 총 엣지 수를 의미하지만, 실제로 자주 해야 하는 작업이라면 엣지가 반전된 두 번째 그래프 사본을 저장할 수 있습니다.","Finding predecessors of a node u is extremely expensive, requiring looking through every list of every node in time O(n + e), where e is the total number of edges, although if this is something we actually need to do often we can store a second copy of the graph with the edges reversed.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 목록은 언제 가장 유용하나요?,When are adjacency lists most useful?,"인접 목록은 주로 각 노드의 나가는 간선을 열거하고자 할 때 가장 유용합니다. 이는 한 노드에서 다른 노드로 가는 경로를 찾거나 노드 쌍 간의 거리를 계산하는 검색 작업에서 흔히 볼 수 있습니다. 다른 작업이 중요한 경우 인접 목록 표현을 보강하여 최적화할 수 있습니다. 예를 들어, 인접 목록에 정렬된 배열을 사용하면 간선 존재 테스트 비용을 O(log(d+(u))로 줄이고, 간선이 반대인 그래프의 두 번째 복사본을 추가하면 O(d-(u)) 시간 내에 u의 모든 선행 변수를 찾을 수 있습니다. 여기서 d-(u)는 u의 차수입니다.","Adjacency lists are most useful when we mostly want to enumerate outgoing edges of each node. This is common in search tasks, where we want to find a path from one node to another or compute the distances between pairs of nodes. If other operations are important, we can optimize them by augmenting the adjacency list representation; for example, using sorted arrays for the adjacency lists reduces the cost of edge existence testing to O(log(d+ (u))), and adding a second copy of the graph with reversed edges lets us find all predecessors of u in O(d− (u)) time, where d− (u) is u's in-degree.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 목록을 사용하는 그래프에 필요한 공간은 무엇인가요?,What is the space required for a graph using an adjacency list?,O(n + e),O(n + e),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
4비트로 표현할 수 있는 최대 부호 없는 숫자는 얼마인가요?,What's the maximum unsigned number you can represent with 4 bits?,15,15,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
8비트로 표현할 수 있는 최대 부호 없는 숫자는 얼마인가요?,What's the maximum unsigned number you can represent with 8 bits?,255,255,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16비트로 표현할 수 있는 최대 부호 없는 숫자는 얼마인가요?,What's the maximum unsigned number you can represent with 16 bits?,"65,535","65,535",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
6비트로 표현할 수 있는 최대 부호 없는 숫자는 얼마인가요?,What's the maximum unsigned number you can represent with 6 bits?,63,63,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
15비트로 표현할 수 있는 최대 부호 없는 숫자는 얼마인가요?,What's the maximum unsigned number you can represent with 15 bits?,"32,767","32,767",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
4비트로 표현할 수 있는 최대 부호 수는 얼마인가요?,What's the maximum signed number you can represent with 4 bits?,7,7,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16비트로 표현할 수 있는 최대 부호 수는 얼마인가요?,What's the maximum signed number you can represent with 16 bits?,"32,767","32,767",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
8비트로 표현할 수 있는 최대 부호 수는 얼마인가요?,What's the maximum signed number you can represent with 8 bits?,127,127,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
9비트로 표현할 수 있는 최대 부호 수는 얼마인가요?,What's the maximum signed number you can represent with 9 bits?,255,255,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
32비트로 표현할 수 있는 최대 부호 없는 숫자는 얼마인가요?,What's the maximum unsigned number you can represent with 32 bits?,"42억 9,400만",4.294 Billion,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
32비트로 표현할 수 있는 최대 부호 수는 얼마인가요?,What's the maximum signed number you can represent with 32 bits?,"21억 4,700만",2.147 Billion,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
밑 b가 주어졌을 때 숫자 n의 로그는 어떻게 구할 수 있나요?,How do you get the logarithm of a number n given a base b?,숫자 <= 1이 될 때까지 n을 b로 계속 나눕니다.,Keep dividing n by b until you get to a number <= 1.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
log(base b)(ac)는 어떻게 쓸 수 있나요?,How can you write log(base b)(ac)?,log(base b)a + log(base b)c,log(base b)a + log(base b)c,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
log(base b)(a/c)를 어떻게 쓸 수 있나요?,How can you write log(base b)(a/c)?,log(base b)a - log(base b)c,log(base b)a - log(base b)c,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
다른 방법으로 log(base b)(a^c)를 쓸 수 있나요?,How else can you write log(base b)(a^c)?,c * log(base b)a,c * log(base b)a,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
log(base b)a를 다른 베이스로 어떻게 표현할 수 있나요?,How you can express log(base b)a as another base?,log(base d)a / log(base d)b,log(base d)a / log(base d)b,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Why is log(base2)(2^n) == n?,Why is log(base2)(2^n) == n?,log(base2)(2^n) = n * log(base 2)2 = n * 1 = n,log(base2)(2^n) = n * log(base 2)2 = n * 1 = n,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
산술 급수란 무엇인가요? 1 + 2 + 3 + 4 + ... (n - 1) + n?,What is the arithmetic series: 1 + 2 + 3 + 4 + ... (n - 1) + n?,(n(n+1)) / 2,(n(n+1)) / 2,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
x!= 1: 1 + x + x^2 + x^3 + ... x^n일 때 기하급수의 값은 얼마입니까?,What is the value of the geometric (exponential) series when x != 1: 1 + x + x^2 + x^3 + ... x^n ?,(x^(n + 1) - 1) / (x - 1),(x^(n + 1) - 1) / (x - 1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이 급수가 무한이고 x < 1일 때의 합은 얼마인가요? 1 + x + x^2 + x^3 + ... x^n?,What is the sum of this series when it's infinite and x < 1? 1 + x + x^2 + x^3 + ... x^n ?,1 / (1 - x),1 / (1 - x),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n번째 조화수에 대한 조화급수의 합은 얼마입니까? 1 + 1/2 + 1/3 + 1/4 .... + 1/n,What is the sum of the harmonic series for the nth harmonic number: 1 + 1/2 + 1/3 + 1/4 .. + 1/n,"닫힌 형식은 없고, 좋은 근사치만 있습니다:

≈ 0.57721
오일러-마스케로니 상수.","No closed form, only good approximations:

≈ 0.57721
the Euler-Mascheroni constant.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n비트로 표현할 수 있는 최대 부호 없는 정수는 얼마인가요?,What is the maximum unsigned integer you can represent with n bits?,2^n - 1,2^n - 1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"x개의 노드가 있는 완전히 균형 잡힌 이진 트리가 주어졌을 때, 노드에서 트리의 높이는 얼마인가요?","Given a fully balanced binary tree with x nodes, what is the height of the tree in nodes?",log(base2) x + 1,log(base2) x + 1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"x개의 노드가 있는 완전히 균형 잡힌 k-진 트리가 주어졌을 때, 노드에서 트리의 높이는 얼마인가요?","Given a fully balanced k-ary tree with x nodes, what is the height of the tree in nodes?",log(basek) x + 1,log(basek) x + 1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
높이가 h인 이진 트리는 최대 몇 개의 노드를 포함할 수 있나요?,A binary tree with height h can contain at most how many nodes?,2^(h+1) − 1 nodes,2^(h+1) − 1 nodes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
높이가 h인 k-ary 트리의 경우 최대 잎 수에 대한 상한은 다음과 같습니다:,"For a k-ary tree with height h, the upper bound for the maximum number of leaves is:",k^h,k^h,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
다이크스트라의 최단 경로 알고리즘의 복잡성은 무엇인가요?,What is the complexity of Dijkstra's shortest-path algorithm?,"O(e 로그 v), 여기서 e는 간선의 수입니다. 
각 가장자리를 스캔하고 힙의 값을 가져와 업데이트해야 합니다.","O(e log v), where e is the number of edges. 
It must scan each edge, and gets and updates values on the heap.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
무방향 그래프에 인접 행렬을 사용하는 것의 단점은 무엇인가요?,What is a drawback of using an adjacency matrix for an undirected graph?,행렬의 항목 중 절반이 중복됩니다.,Half of the entries in the matrix are duplicates.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 목록을 저장하는 데 필요한 메모리는 무엇인가요?,What is the memory needed to store an adjacency list?,세타( |V| + |E| ),Theta( |V| + |E| ),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 행렬을 저장하는 데 필요한 메모리는 무엇인가요?,What is the memory needed to store an adjacency matrix?,세타(|V|^2),Theta(|V|^2),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
링크된 목록으로 대기열을 어떻게 구현하시겠습니까?,How would you implement a queue with a linked list?,꼬리 포인터를 사용합니다. 꼬리에서 새 항목을 밀고 머리에서 항목을 터뜨립니다. 두 작업 모두 일정한 시간 동안 진행됩니다.,"Use a tail pointer. Push new items at the tail, pop items at the head. Both operations are constant-time.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
링크된 목록이 있는 스택을 어떻게 구현하시겠습니까?,How would you implement a stack with a linked list?,머리에 물건을 밀고 터뜨립니다. 두 작업 모두 일정한 시간 동안 진행됩니다.,Push and pop items at the head. Both operations are constant-time.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
사전 주문 트래버스가 트리에 제공하는 노드와 잎의 선호도는 무엇인가요?,What preference of nodes vs leaves does preorder traversal give on a tree?,"노드가 먼저 있고, 나중에 떠납니다.","Nodes first, leaves later.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
포스트오더 트래버스가 트리에 주는 노드와 잎의 선호도는 무엇인가요?,What preference of nodes vs leaves does postorder traversal give on a tree?,"먼저 떠나고, 내부 노드는 나중에 떠납니다.","Leaves first, internal nodes later.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DFS에서 재귀 알고리즘을 상호작용 알고리즘으로 변환하는 데 무엇을 사용할 수 있나요?,What could you use in DFS to turn a recursive algorithm into an interative one?,스택.,A stack.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
BFS에서 방문할 노드를 추적하려면 무엇을 사용하나요?,What do you use to keep track of nodes to visit in BFS?,대기열.,A queue.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스택을 사용하여 방문하지 않은 노드를 추적하면 어떤 종류의 탐색이 가능할까요?,Using a stack to keep track of unvisited nodes gives what kind of traversal?,DFS,DFS,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
방문하지 않은 노드를 추적하기 위해 대기열을 사용하면 어떤 종류의 이동 경로가 제공되나요?,Using a queue to keep track of unvisited nodes gives what kind of traversal?,BFS,BFS,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n개의 정점으로 이루어진 고도로 연결된 그래프에서 사이클은 몇 개일 수 있나요?,"In a highly connected graph of n vertices, how many cycles can there be?","(n - 1)! - 역추적을 사용하여 열거하는 것은 가능하지만, 많을 것입니다.","(n - 1)! - enumerating is possible (using backtracking), but there will be a lot.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프가 이분형인 경우 무엇을 사용하여 찾을 수 있나요?,What can use to find if a graph is bipartite?,BFS. 두 가지 색상만 사용합니다. 새 정점을 만나면 색상이 없는 경우 부모 정점의 반대 색상을 지정합니다. 이미 동일한 색상으로 표시되어 있다면 그래프는 이분법적이지 않습니다.,"BFS. Using only 2 colors. When you encounter a new vertex, if it has no color, give it the opposite color of its parent vertex. If it is already colored the same, the graph is not bipartite.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프에서 주기를 어떻게 찾을 수 있나요?,How can you find a cycle in a graph?,DFS. 이전에 발견된 정점(이전에 발견된 정점)에 연결된 간선을 발견하면 주기가 생깁니다.,"DFS. If you discover an edge that connects to an ancestor (previously discovered vertex), you have a cycle.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
관절 정점이란 무엇인가요?,What is an articulation vertex?,삭제가 그래프를 분리하는 그래프의 정점입니다.,A vertex of a graph whose deletion disconnects the graph.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
관절 정점을 어떻게 찾을 수 있나요?,How can you find an articulation vertex?,"DFS를 여러 번 반복합니다. 각 엣지를 하나씩 제거하고, 각 엣지마다 DFS를 수행하여 1개 이상의 연결된 구성 요소가 있는지 확인합니다. 노드를 제거한 다음 DFS를 사용하여 m - 1개 미만의 엣지를 발견하면, 아티큘레이션 버텍스를 삭제한 것입니다. O(n(n+m))

DFS를 수행하고 부모를 추적하며 조상과 연결되는 백 엣지에 도달하면 메모를 작성하면 조금 더 많은 부기를 통해 O(n+m) 시간 내에 더 빠른 방법을 사용할 수 있습니다.","DFS multiple times. Remove each edge one at a time, doing a DFS after each, so see if you end up with > 1 connected components. If you remove a node and then DFS and find you have fewer than m - 1 edges, you've deleted an articulation vertex. O(n(n+m))

A faster way, with a little more bookkeeping, can be done in O(n+m) time, if you do DFS and keep track of parents and make a note when you reach a back edge, which connects to an ancestor.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"더 큰 서열에서 항목 A가 B 앞에 나타나야 하는 많은 서열 쌍이 주어졌을 때, DNA 단편 어셈블리의 오류를 어떻게 식별할 수 있을까요?","How could you identify errors in a DNA fragment assembly given many pairs of sequences, where item A must appear before B in the larger sequence?",모든 좌우 제약 조건을 나타내는 DAG를 구축합니다. 모든 토폴로지 유형의 DAG는 일관된 순서입니다. 주기가 있는 경우 오류가 있어야 합니다.,"Build a DAG representing all the left-right constraints. Any topological sort of the DAG is a consistent ordering. If there are cycles, there must be errors.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
BFS는 그래프에서 어떤 경로를 찾나요?,What path does BFS find in a graph?,시작부터 모든 노드까지의 최단 경로 트리(가중치 없음),The shortest path tree from start to all nodes (unweighted),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"그래프 G(V, E)의 간선 수에 대한 상한은 얼마인가요?","What's the upper bound on the number of edges in a graph G(V, E)?",|V|^2,|V|^2,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 100개의 원소로 구성된 x라는 목록을 초기화합니다.,"In Python, initialize a list of lists called x with 100 elements.",x = [[] for _ in range(100)],x = [[] for _ in range(100)],2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최단 경로에 대해 알려주는 최적의 하부 구조 속성은 무엇인가요?,What is the optimal substructure property tell us about shortest paths?,가장 짧은 경로의 하위 경로도 가장 짧은 경로입니다.,That a subpath of a shortest path is also a shortest path.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
던더 방식이란 무엇인가요?,What is a Dunder method?,"파이썬의 마법 방법, 예를 들어 __getitem__ 및 __len__.","A magic method in Python, such as __getitem__ and __len__.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
1에서 2^n까지의 숫자의 합은 무엇인가요?,What is the sum of numbers from 1 to 2^n?,"2^(n+1) - 1
일련의 거듭제곱의 합은 대략 그 수열의 다음 값과 같습니다.","2^(n+1) - 1
The sum of a sequence of powers is roughly equal to the next value in the sequence.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n개의 고유 문자 문자열을 몇 가지 방법으로 재배열할 수 있나요?,How many ways can you rearrange a string of n unique characters?,"n!
순열.","n!
Permutations.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n개의 고유 문자 중 k개의 문자를 배열하는 방법은 몇 가지가 있나요?,How many ways can you arrange k characters from n unique characters?,"n! / (n - k)!
크기 k의 n개 원소의 순열.","n! / (n - k)!
Permutation of n elements of size k.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n개의 고유 문자에 크기 k의 하위 집합(순서는 상관없습니다)이 몇 개 있나요?,How many subsets (ordering doesn't matter) of size k are there in n unique characters?,"n! / k!(n - k)!
이것은 n 선택 k입니다.","n! / k!(n - k)!
This is n choose k.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
재귀 시 기본 케이스에서 피해야 할 것은 무엇인가요?,What should you avoid in your base case in recursion?,"Too many base case scenarios. Just have one base case so you can return as quickly as possible. Avoid ""arm's length"" recursion.","Too many base case scenarios. Just have one base case so you can return as quickly as possible. Avoid ""arm's length"" recursion.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프의 대역폭은 얼마인가요?,What is the bandwidth of a graph?,가장 짧은 간선을 제공하는 순열에서 가장 긴 변입니다.,The longest edge in the permutation that gives you the shortest edges.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동적 프로그래밍에 대해 이야기할 때 실현 가능성이란 무엇인가요?,"When talking dynamic programming, what is feasibility?",알고리즘이 해결책에 도달하기 위해 준수해야 하는 규칙.,The rules the algorithm must adhere to in reaching its solution.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동적 프로그래밍에 대해 이야기할 때 최적성이란 무엇인가요?,"When talking dynamic programming, what is optimality?",알고리즘은 문제의 최적 해의 부분 해가 그들의 부분 문제에 대한 최적 해일 때 최적성을 갖습니다.,An algorithm has optimality if the subsolutions of an optimal solution of the problem are themsleves optimal solutions for their subproblems.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동적 프로그래밍이란 무엇인가요?,What is dynamic programming?,"동적 프로그래밍은 조합 최적화 문제를 해결하는 데 가장 자주 사용되는 범용 알고리즘 설계 기법으로, 기하급수적으로 큰 검색 공간에서 선택한 함수에 최적의 입력을 찾습니다.

동적 프로그래밍에는 두 가지 부분이 있습니다. 첫 번째 부분은 프로그래밍 기법입니다: 동적 프로그래밍은 본질적으로 역방향으로 실행되는 분할 및 정복입니다: 우리는 문제의 큰 인스턴스를 작은 인스턴스로 재귀적으로 분해하여 해결하지만, 계산을 위에서 아래로 재귀적으로 수행하는 대신, 문제의 가장 작은 인스턴스부터 시작하여 점점 더 큰 인스턴스를 차례로 해결하고 결과를 표에 저장합니다. 두 번째 부분은 설계 원칙입니다: 테이블을 구축할 때, 우리는 가능한 한 특정 선택에 대한 약속을 지연시킴으로써 나중에 필요할 수 있는 대체 솔루션을 항상 보존하도록 주의합니다.

동적 프로그래밍의 상향식 측면은 간단한 재귀를 통해 많은 중복 하위 문제를 생성할 때 가장 유용합니다. 원래 문제에 필요하지 않은 불필요한 경우가 너무 많지 않은 하위 문제 클래스를 열거할 수 있을 때 가장 효율적입니다.","Dynamic programming is a general-purpose algorithm design technique that is most often used to solve combinatorial optimization problems, where we are looking for the best possible input to some function chosen from an exponentially large search space.

There are two parts to dynamic programming. The first part is a programming technique: dynamic programming is essentially divide and conquer run in reverse: we solve a big instance of a problem by breaking it up recursively into smaller instances; but instead of carrying out the computation recursively from the top down, we start from the bottom with the smallest instances of the problem, solving each increasingly large instance in turn and storing the result in a table. The second part is a design principle: in building up our table, we are careful always to preserve alternative solutions we may need later, by delaying commitment to particular choices to the extent that we can.

The bottom-up aspect of dynamic programming is most useful when a straightforward recursion would produce many duplicate subproblems. It is most efficient when we can enumerate a class of subproblems that doesn't include too many extraneous cases that we don't need for our original problem.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
순진한 재귀 피보나치 함수의 복잡도는 무엇인가요?,What is the complexity for a naive recursive Fibonacci function?,"θ(φ^n), 여기서 phi(φ)는 황금 비율 (1 + sqrt(5)) / 2입니다. 
약: 1.618","Θ(φ^n), where phi(φ) is the golden ratio (1 + sqrt(5)) / 2. 
approx: 1.618",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
수업에서 __getitem__는 무엇을 사용할 수 있게 하나요?,What does __getitem__ in a class allow us to use?,"- 반복
- 슬라이싱
- 역반복
- 무작위 선택","- iteration
- slicing
- reverse iteration
- random.choice",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n개의 항목에 몇 개의 하위 집합이 있나요?,How many subsets are there in n items?,2^n,2^n,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"연속적으로 할당된 구조란 무엇이며, 예를 들어 설명해 주세요.","What is a contiguously-allocated structures, and give examples.","연속적으로 할당된 구조는 단일 메모리 슬래브로 구성되며 배열, 행렬, 힙, 해시 테이블을 포함합니다.","Contiguously-allocated structures are composed of single slabs of memory, and include arrays, matrices, heaps, and hash tables.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
연결된 데이터 구조란 무엇이며 예시를 제공합니다.,What are linked data structures and give examples.,"연결된 데이터 구조는 포인터로 결합된 별개의 메모리 덩어리로 구성되며, 리스트, 트리, 그래프 인접 리스트를 포함합니다.","Linked data structures are composed of distinct chunks of memory bound together by pointers, and include lists, trees, and graph adjacency lists.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
배열의 장점은 무엇인가요?,What are some benefits of arrays?,"- 인덱스가 지정된 일정 시간 액세스
- 공간 효율성
- 기억 지역성","- Constant-time access given the index
- Space efficiency
- Memory locality",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
기억의 국소성이 중요한 이유는 무엇인가요?,Why is memory locality important?,연속적인 데이터 접근 간의 물리적 연속성은 현대 컴퓨터 아키텍처에서 고속 캐시 메모리를 활용하는 데 도움이 됩니다.,Physical continuity between successive data accesses helps exploit the high-speed cache memory on modern computer architectures.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
연결된 목록이 배열에 비해 어떤 장점이 있나요?,What are some advantages to linked lists over arrays?,"- 메모리가 실제로 가득 차 있지 않으면 연결된 구조물에서 오버플로우가 발생할 수 없습니다.
- 삽입 및 삭제는 연속적인 (어레이) 목록보다 더 간단합니다.
- 큰 기록에서는 포인터를 이동하는 것이 항목 자체를 이동하는 것보다 더 쉽고 빠릅니다.","- Overflow on linked structures can never occur unless the memory is actually full.
- Insertions and deletions are simpler than for contiguous (array) lists.
- With large records, moving pointers is easier and faster than moving the items themselves.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
연결된 목록에 비해 배열의 장점은 무엇인가요?,What are some advantages to arrays over linked lists?,"- 연결된 구조는 포인터 필드를 저장하기 위한 추가 공간이 필요합니다.
- 연결된 목록은 항목에 대한 효율적인 무작위 접근을 허용하지 않습니다.
- 배열은 랜덤 포인터 점프보다 메모리 로컬리티와 캐시 성능을 향상시킵니다.","- Linked structures require extra space for storing pointer fields.
- Linked lists do not allow efficient random access to items.
- Arrays allow better memory locality and cache performance than random pointer jumping.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
코드 없는 질문: 단일 링크 목록의 중간 노드를 찾기 위한 함수를 작성합니다.,Codeless question: Write a function to find the middle node of a singly-linked list.,그걸 어떻게 하시겠어요?,How would you do it?,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
코드 없는 질문: 두 이진 트리가 동일한지 비교하는 함수를 작성합니다. 동일한 트리는 각 위치와 구조에서 동일한 키 값을 갖습니다.,Codeless question: Write a function to compare whether two binary trees are identical. Identical trees have the same key value at each position and the same structure.,어떻게?,How?,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
코드리스 질문: Binary Search Tree를 연결된 목록으로 변환하는 프로그램을 작성합니다.,Codeless quesiton: Write a program to convert a binary search tree into a linked list.,그걸 어떻게 하시겠어요?,How would you do it?,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
코드 없는 질문: 검색 문자열과 잡지가 주어집니다. 잡지에서 모든 문자를 잘라내어 검색 문자열에 있는 모든 문자를 생성하려고 합니다. 잡지에 검색 문자열에 모든 문자가 포함되어 있는지 효율적으로 판단할 수 있는 알고리즘을 제시합니다.,Codeless Question: You are given a search string and a magazine. You seek to generate all the characters in search string by cutting them out from the magazine. Give an algorithm to efficiently determine whether the magazine contains all the letters in the search string.,그걸 어떻게 하시겠어요?,How would you do it?,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"코드 없는 질문: 주어진 웹페이지에서 가장 높은 빈도로 발생하는 정렬된 단어 쌍(예: ""뉴욕"")을 찾기 위한 알고리즘을 제시하세요. 어떤 데이터 구조를 사용하시겠습니까?","Codeless question: Give an algorithm for finding an ordered word pair (e.g., “New York”) occurring with the greatest frequency in a given webpage. Which data structures would you use?","해시 테이블을 사용하여 각 쌍에 대한 항목을 만들거나 업데이트할 수 있습니다. 
max_frequency와 most_frequency_phrase를 추적하세요.
카운트를 늘리기만 하면 새 카운트가 max_frequency보다 >인 것을 확인하고 max_frequency 및 most_frequency_frequency를 업데이트합니다","You could use a hash table, creating or updating an entry for each pair. 
Keep track of max_frequency and most_frequent_phrase.
Just increment the count, and when you see the new count is > than max_frequency, update max_frequency and most_frequent_phrase",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"코드 없는 질문: n개의 숫자 집합이 주어졌을 때, 두 숫자 사이의 차이가 가장 작은 두 숫자를 어떻게 찾을 수 있을까요?","Codeless question: Given a set of n numbers, how do you find the pair of numbers that have the smallest difference between them?",정렬하기: 숫자가 정렬되면 가장 가까운 숫자 쌍이 정렬된 순서대로 서로 옆에 있어야 합니다. 따라서 정렬을 포함하여 총 O(n 로그 n) 시간 동안 숫자를 선형 시간 스캔하면 작업이 완료됩니다.,"Sort them: Once the numbers are sorted, the closest pair of numbers must lie next to each other somewhere in sorted order. Thus, a linear-time scan through them completes the job, for a total of O(n log n) time including the sorting.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
코드 없는 질문: 주어진 n개의 항목 집합에 중복되는 항목이 있나요?,Codeless question: Are there any duplicates in a given set of n items?,"이것은 가장 가까운 쌍 문제의 특별한 경우로, 0의 간격으로 분리된 쌍이 있는지 묻는 문제입니다. 가장 효율적인 알고리즘은 숫자를 정렬한 다음 인접한 모든 쌍을 확인하여 선형 스캔을 수행합니다.","This is a special case of the closest-pair problem, where we ask if there is a pair separated by a gap of zero. The most efficient algorithm sorts the numbers and then does a linear scan though checking all adjacent pairs.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"코드 없는 질문: n개의 항목 집합이 주어졌을 때, 집합에서 가장 많이 발생하는 요소는 무엇인가요? 보너스: 어떤 요소 k가 몇 번이나 나타나는지 어떻게 알 수 있나요?","Codeless question: Given a set of n items, which element occurs the largest number of times in the set? Bonus: How do you find out how many times some element k appears?","항목이 정렬되면 정렬 중에 모든 동일한 항목이 함께 모이게 되므로 왼쪽에서 오른쪽으로 쓸어 세어볼 수 있습니다.

임의의 요소 k가 얼마나 자주 발생하는지 알아보려면 정렬된 키 배열에서 이진 검색을 사용하여 k를 찾아보세요. 그런 다음 각 방향에서 이진 검색을 사용하여 숫자의 시작과 끝을 찾습니다.","If the items are sorted, we can sweep from left to right and count them, since all identical items will be lumped together during sorting.

To find out how often an arbitrary element k occurs, look up k using binary search in a sorted array of keys. Then use binary search in each direction to find where that run of the number begins and ends.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
코드 없는 질문: 두 집합(각각 크기 m과 n)이 서로 분리되어 있는지 여부를 결정하는 효율적인 알고리즘을 제시합니다.,"Codeless question: Give an efficient algorithm to determine whether two sets (of size m and n, respectively) are disjoint.","작은 집합은 O(m log m) 시간 내에 정렬할 수 있습니다. 이제 큰 집합의 n개 원소 각각으로 이진 검색을 수행하여 작은 집합에 존재하는지 확인할 수 있습니다. 총 시간은 O((n + m) log m입니다.

이것은 더 큰 배열을 정렬하거나 두 집합을 정렬하고 목록을 살펴보는 것보다 낫습니다.","The small set can be sorted in O(m log m) time. We can now do a binary search with each of the n elements in the big set, looking to see if it exists in the small one. The total time will be O((n + m) log m).

This is better than sorting the larger array or sorting both sets and going through the list.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
균일 분포란 무엇인가요?,What is a uniform distribution?,알려진 유한한 수의 결과가 동일하게 발생할 가능성이 있는 경우. 발생 히스토그램으로 그래프로 표시하면 평평한 선이 됩니다. N개의 항목은 각각 1/n의 확률을 갖습니다.,"When a known finite number of outcomes are equally likely to occur. When graphed as a histogram of occurrences, it's a flat line. N items each have 1/n probability.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정규 분포란 무엇인가요?,What is a normal distribution?,표준 정규 확률 밀도 함수는 거의 모든 사람에게 알려진 유명한 종 모양을 가지고 있습니다.,The standard normal probability density function has the famous bell shape that is known to just about everyone.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n그램이란 무엇인가요?,What is an n-gram?,N개의 순차 단어 집합이 함께 나타납니다.,A set of N sequential words appearing together.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
9비트로 표현할 수 있는 최대 부호 없는 숫자는 얼마인가요?,What's the maximum unsigned number you can represent with 9 bits?,511,511,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n번의 삽입 후 Binary Search Tree의 평균 높이는 얼마인가요?,Whats the average height of a binary search tree after n insertions?,"2 ln n
완벽하게 균형 잡힌 BST보다 약 39% 더 큽니다","2 ln n
About 39% taller than a perfectly balanced BST",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
무작위 퀵소트의 실행 시간은 어떻게 되나요?,What is the runtime of randomized quicksort?,"모든 입력에 대한 Theta(n 로그 n) 시간, 높은 확률로.","Theta(n log n) time on any input, with high probability.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Python: 기본 인수는 다음 주의사항과 함께 사용해도 괜찮습니다.,Python: Default arguments are okay to use with the following caveat.,"함수나 메서드 정의에서 기본값으로 변경 가능한 객체를 사용하지 마십시오.

목록이 좋지 않습니다.","Do not use mutable objects as default values in the function or method definition.

Lists are not ok.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬: 조건부 표현의 예를 들어보세요.,Python: Give an example of a conditional expression.,x = 1 if cond else 2,x = 1 if cond else 2,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"파이썬: 이 문자열 'a/b/c'를 [a', 'b', c']의 목록으로 나눕니다","Python: break this string 'a/b/c' into a list of ['a', 'b', c']",'a/b/c'.split('/','a/b/c'.split('/'),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬: 단어나 문장을 문자로 나눕니다.,Python: split a word or sentences into characters.,몇 단어 나열하기'),list('some words'),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
foo.sort()와 sorted(foo)의 차이점은 무엇인가요? 여기서 foo는 목록입니다?,What's the difference between foo.sort() and sorted(foo) where foo is a list?,"foo.sort()가 목록을 정렬된 상태로 변경합니다
정렬된(foo)은 foo를 변경하지 않고 정렬된 목록만 반환합니다.","foo.sort() changes the list to its sorted state
sorted(foo) doesn't change foo, just returns a sorted list.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
튜플을 분류할 수 있나요?,Can you sort a tuple?,"예, 정렬된(foo)을 사용합니다
하지만 foo.sort()는 안 돼요","Yes, using sorted(foo)
but not with foo.sort()",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬: 리스트 푸에서 인덱스 6에서 11을 어떻게 제거하시겠습니까?,Python: How would you remove indices 6 to 11 in a list foo?,del foo[6:12],del foo[6:12],2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬: 인덱스가 목록에 있는지 어떻게 알 수 있나요?,Python: How can you tell if an index is in a list?,만약 0 < i < len(foo)):,if 0 < i < len(foo):,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
두 번 앞면이 나올 확률은 얼마인가요? P(HH),What's the probability of getting heads twice? P(HH),"1/4 
= 1/2 * 1/2","1/4 
= 1/2 * 1/2",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"앞면, 뒷면, 앞면이 나올 확률은 얼마인가요? P(HTH)","What's the probability of getting heads, tails, heads? P(HTH)","1/8 
= 1/2 * 1/2 * 1/2
HTH의 순서는 중요하지 않습니다. TTH일 수도 있고, HHH일 수도 있고, TTT일 수도 있습니다. 둘 다 키가 큽니다.","1/8 
= 1/2 * 1/2 * 1/2
the ordering of HTH doesn't matter. It could be TTH or HHH or TTT, they are tall the same.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
200번 연속으로 앞면이 나올 확률은 얼마인가요?,What's the probability of getting heads 200 times in a row?,(1/2)^200,(1/2)^200,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"앞면, 뒷면 또는 뒷면, 앞면이 나올 확률은 얼마인가요? P(HT U TH)","What's the Probability of getting head, tails or tails, heads? P(HT U TH)",(1/2 * 1/2) + (1/2 * 1/2) = 2/4 = 1/2,(1/2 * 1/2) + (1/2 * 1/2) = 2/4 = 1/2,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
8번의 플립에서 정확히 3개의 헤드가 나올 확률은 얼마인가요?,What's the probability of getting exactly 3 heads in 8 flips?,"56/256 = 7/32

(8 choose 3)/2^8","56/256 = 7/32

(8 choose 3)/2^8",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
알파벳에는 26개의 문자가 있습니다. 반복되는 문자가 괜찮은 알파벳에서 3개의 문자를 배열할 수 있는 방법은 몇 가지인가요?,You have 26 letters in an alphabet. How many ways you can arrange 3 letters from that alphabet where repeated letters is OK?,"26*26*26 = 26^3 = 17,576","26*26*26 = 26^3 = 17,576",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
알파벳에는 26개의 글자가 있습니다. 알파벳에서 글자를 반복하지 않고 3개의 글자를 배열할 수 있는 방법은 몇 가지인가요?,You have 26 letters in an alphabet. How many ways you can arrange 3 letters from that alphabet without repeating a letter?,"26*25*24 = 26 permute 3 = 15,600","26*25*24 = 26 permute 3 = 15,600",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"알파벳 26글자가 주어졌을 때, 글자 순서가 상관없다면 3글자를 몇 번이나 선택할 수 있나요?","Given an alphabet of 26 letters, how many times you can you choose 3 letters, if ordering of the letters doesn't matter?",26*25*24 / 3! = 2600,26*25*24 / 3! = 2600,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
0이란 무엇인가요?,What is 0! ?,1,1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
4명이 있습니다. 같은 사람의 손을 두 번 흔들지 않고 서로 악수할 수 있는 방법은 몇 가지일까요?,There are 4 people. How many ways can they shake each other's hands without shaking the same person's hand twice?,"6
= 4 선택 2
= 4 * 3 / 2","6
= 4 choose 2
= 4 * 3 / 2",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가장 오른쪽에 있는 1비트를 오른쪽으로 전파하여 x = 0인 경우 모든 1을 생성합니다(예: 01011000 01011111):,"Right-propagate the rightmost 1-bit, producing all 1's if x = 0 (e.g., 01011000 01011111):",x |= (x - 1),x |= (x - 1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
x에서 가장 오른쪽 비트를 분리하세요.,Isolate the right-most bit in x.,x & ~(x - 1),x & ~(x - 1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
P란 무엇인가요?,What is P?,다항 시간 내에 풀 수 있는 모든 문제의 집합.,The set of all problems solvable in polynomial time.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
EXP란 무엇인가요?,What is EXP?,지수 시간 내에 풀 수 있는 모든 문제의 집합.,The set of all problems solvable in exponential time.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
R이란 무엇인가요? (실수가 아님),What is R? (not real numbers),유한한 시간 내에 해결할 수 있는 문제들의 집합.,The set of problems solvable in finite time.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정지 문제는 R에 있나요?,Is the Halting Problem in R?,아니요.,No.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
NP는 무엇을 의미하나요? NP 알고리즘이란 무엇인가요?,What does NP mean? What is an NP algorithm?,NP는 비결정적 다항식 시간 내에 해결할 수 있는 결정 문제의 집합입니다. NP 문제는 마법처럼 항상 '예' 결정을 찾는 행운의 알고리즘으로 해결할 수 있습니다. NP 문제는 다항식 시간 내에 확인할 수 있습니다.,NP is the set of decision problem solvable in non-deterministric polynomial time. An NP problem can be solved by a lucky algorithm that magically always finds a yes decision. NP problems can be checked in polynomial time.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
NP-완전 문제의 원인은 무엇인가요?,What makes a problem NP-Complete?,"x가 NP와 NP-난해의 원소인 경우. NP-완전은 NP와 NP-난해의 좁은 교차점입니다.

NP는 매우 큰 종류의 문제이기 때문에, 대부분의 NP-난해 문제는 실제로 완전할 것입니다.","If x is an element of NP and of NP-hard. NP-Complete is the narrow intersection of NP and NP-hard.

Because NP is such a large class of problems, most NP-hard problems you encounter will actually be complete.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Fib(0)이란 무엇인가요?,What is Fib(0) ?,0,0,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Fib(3)이란 무엇인가요?,What is Fib(3) ?,2,2,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Fib(2)란 무엇인가요?,What is Fib(2) ?,1,1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
PTAS란 무엇인가요?,What is a PTAS?,다항 시간 근사 방식.,Polynomial-time approximation scheme.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
포인터란 무엇인가요?,What is a pointer?,메모리에 저장된 메모리 주소.,A memory address stored in memory.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
참조 주기를 포함하는 일반적인 데이터 구조의 두 가지 예를 들어보세요.,Give 2 examples of common data structures that contain reference cycles.,"- 이중 연결 목록
- 부모 및 자식 포인터가 있는 트리","- Doubly-linked lists
- Trees with parent and child pointers",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 약한 참조란 무엇인가요?,What is a weak reference in Python?,"객체에 대한 약한 참조는 참조 횟수에 영향을 미치지 않습니다. 
참조에 대한 유일한 참조가 약한 참조인 경우, 가비지 컬렉션은 참조를 파괴하고 메모리를 다른 용도로 재사용할 수 있습니다. 약한 참조의 주요 용도는 캐시나 매핑에 나타난다고 해서 큰 객체를 유지하지 않는 캐시나 매핑을 구현하는 것입니다.","A weak reference to an object does not affect its reference count. 
When the only remaining references to a referent are weak references, garbage collection is free to destroy the referent and reuse its memory for something else. A primary use for weak references is to implement caches or mappings holding large objects, where it’s desired that a large object not be kept alive solely because it appears in a cache or mapping.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CPython에서는 쓰레기 수거가 어떻게 작동하나요?,How does garbage collection work in CPython?,"CPython은 참조 카운팅과 세대 쓰레기 수집을 사용합니다. 객체가 기억 속에 존재하는 연령 단계는 3단계가 있습니다. 이 단계들은 모두 ""양육""인 0단계에서 시작하여 쓰레기 수집에서 살아남으면 1단계로 이동하고, 1단계에서 계속 생존하는 가장 오래된 객체는 2단계로 승격됩니다. GC 모듈에는 각 단계마다 임계값이 700, 10, 10입니다. 실행 시기를 결정하기 위해 수집기는 마지막 수집 이후의 객체 할당 및 할당 해제 횟수를 추적합니다. 할당 횟수에서 할당 해제 횟수를 뺀 값이 임계값 0을 초과하면 수집이 시작됩니다. 1세대가 검토된 이후 0세대가 임계값 1번 이상 검토된 경우, 1세대도 검토됩니다. 마찬가지로 임계값 2는 2세대를 수집하기 전에 1세대의 수집 횟수를 제어합니다.","CPython uses reference counting and generational garbage collection. There are 3 age stages where objects live in memory. They all start in the ""nursery"", stage0, then if they survive a garbage collection, they are moved to stage1, the oldest objects that continue to survive in stage1 are promoted to stage2. The gc module has thresholds 700, 10, 10 for each stage. In order to decide when to run, the collector keeps track of the number object allocations and deallocations since the last collection. When the number of allocations minus the number of deallocations exceeds threshold0, collection starts. If generation 0 has been examined more than threshold1 times since generation 1 has been examined, then generation 1 is examined as well. Similarly, threshold2 controls the number of collections of generation 1 before collecting generation 2.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
참조 카운팅이란 무엇인가요?,What is reference counting?,"RC는 가비지 컬렉션의 한 방법입니다. 런타임은 각 할당과 삭제(del)에서 참조 카운트를 조작하여 객체에 대한 참조를 추적하며, 참조 카운트가 0에 도달하면 객체에 거의 도달할 수 없음을 의미합니다. 다음 컬렉션이 실행되면 객체의 메모리가 새 객체에 할당되도록 예약됩니다.","RC is a method of garbage collection. The runtime keeps track of references to an object by manipulating the reference count on each assignment and delete (del), and when the reference count reaches 0 it means the object is practically unreachable. When the next collection runs, the object's memory will be reserved to allocate for new objects.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 피니셔란 무엇인가요?,What is a finalizer in Python?,"파이널라이저는 __del_. __del_()이라는 이름의 디스트럭터로, 런타임이 객체를 파괴하려고 할 때 실행됩니다.","A finalizer is a destructor, named __del__. __del__() is run when the runtime is about to destroy the object.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
참조 카운팅의 두 가지 장점은 무엇인가요?,What are 2 advantages of reference counting?,"- 구현하기 쉬운
- 실행 중에 큰 멈춤 없이 부수적으로 쓰레기를 수집합니다.","- easy to implement
- collects garbage incidentally without large pauses in execution.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
참조 카운팅의 두 가지 단점은 무엇인가요?,What are 2 disadvantages of reference counting?,"- 순환 참조를 수집할 수 없습니다
- 각 과제에서 참조 횟수를 조작하는 것은 매우 느립니다.","- it cannot collect circular references
- manipulating reference counts at each assignment is very slow.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
순환 쓰레기 수거란 무엇인가요?,What is cyclic garbage collection?,프로그램이 도달할 수 없는 사이클을 감지하고 제거합니다.,Detects and removes cycles unreachable by the program.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
PyPy에서는 쓰레기 수거를 어떻게 하나요?,How is garbage collection done in PyPy?,"GC 구현은 런타임에 선택할 수 있습니다. 플러그인이 가능합니다.
PyPy는 마크 앤 스윕과 세대 GC 최적화를 사용합니다. 마크된 객체는 보육원에서 이전 세대로 승격됩니다.
PyPy는 점진적인 가비지 컬렉션을 사용하며, 주요 컬렉션은 여러 번의 패스로 나뉘며 각 패스는 몇 밀리초 동안만 지속됩니다.","The GC implementation can be chosen at runtime. It's pluggable.
PyPy uses mark and sweep, and generational gc optimization. Marked objects are promoted from the nursery to an older generation.
PyPy uses incremental garbage collection, where major collection is split into multiple passes, each lasting only a few milliseconds.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
포인터란 무엇인가요?,What is a pointer?,포인터는 메모리에 저장된 메모리 주소입니다.,A pointer is a memory address stored in memory.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
표시와 스위프는 어떻게 작동하나요?,How does mark and sweep work?,(Java에서) 객체에 대한 참조 그래프에 대해 DFS를 수행합니다. 이 그래프는 여러 루트를 가질 수 있습니다. 각 루트는 변수와 같이 프로그램이 직접 액세스할 수 있는 참조입니다. 그래프를 가로지르며 각 객체에 표시 비트를 설정합니다. 스윕 단계에서는 표시되지 않은 메모리가 목록에서 서로 연결되어 메모리를 재할당할 수 있습니다. 때때로 이는 메모리에서 서로 인접한 사용된 객체를 이동시키는 압축을 유발하기도 합니다. 이로 인해 빈 메모리도 빈 메모리에 인접하여 큰 블록을 할당할 수 있다는 부작용이 있습니다.,"(In Java) Perform a DFS on the graph of references to objects. This graph can have multiple roots. Each root is a reference that the program can access directly, such as a variable. Traverse the graph, setting a mark bit in each object. The sweep phase causes unmarked memory to be linked together in a list, so that memory can be reallocated. Sometimes this also triggers compaction, which moves used objects adjacent to each other in memory. The side effect of this is that free memory is also adjacent to free memory so large blocks can be allocated.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
쓰레기 수거(정지 및 복사)를 복사하는 것은 무엇인가요?,What is copying garbage collection (stop and copy)?,힙 메모리는 두 개의 partition으로 나뉩니다: 오래된 공간과 새로운 공간. 참조 그래프의 DFS를 통해 살아있는 객체를 찾아 새로운 공간으로 이동합니다. 이제 새로운 공간을 이전 공간이라고 합니다. 도달할 수 없는 객체는 다음 컬렉션이 발생할 때 덮어쓰기 위해 이전 공간에 그대로 둡니다. 객체의 움직임은 암묵적으로 객체를 압축합니다. 단점: 힙 공간의 절반만 사용할 수 있습니다.,"Heap memory is split into 2 partitions: an old space and a new space. Find live objects by DFS of their reference graph, and move live objects into the new space. The new space is now called the old space. Unreachable objects are simply left in the old space to be overwritten the next time collection occurs. The movement of objects implicitly compacts the objects. Disadvantage: you can only use half of the heap space.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
LRU 캐시를 어떻게 구현할 수 있나요?,How could you implement an LRU cache?,"해시 테이블 또는 이진 트리와 같은 빠른 조회 테이블과 사용 용도별 항목 목록입니다. 항목에 액세스하거나 추가할 때는 링크된 목록에서 항목을 삭제하고 목록의 맨 앞에 추가합니다. 그런 다음 연결된 목록을 가지치기하고 후행 요소를 제거한 다음 저장소(트리 또는 해시 테이블)에서 삭제합니다.
뿌리로 접근할 수 있도록 이동하기 때문에 스플레이 트리를 사용할 수도 있습니다. 잎의 수는 n/2 정도이므로 항목을 가지치기하려면 어떻게든 잎을 찾아서 제거하세요.","A fast lookup table, like a hash table or binary tree, and a linked list of items by use. When you access or add an item, you delete it from the linked list and add it to the head of the list.  Then to prune, traverse the linked list and remove trailing elements, and delete them from the storage (tree or hash table).
You can also use a splay tree, since it moves accesses to the root. To prune items, somehow find and remove the leaves, since the number of leaves will be about n/2.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
직접 매핑 캐시란 무엇인가요?,What is a direct mapped cache?,"CPU에서 사용되는 캐시 유형으로, 주어진 메모리 주소의 하위 비트를 캐시에 배치하거나 조회할 캐시 라인의 수에 따라 모듈로 사용합니다. 충돌은 덮어쓰기로 처리됩니다.","It's a type of cache used in the CPU, where the lower order bits of a given memory address are used modulo the number of cache lines to place or lookup in the cache. Collisions are treated as overwrites.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
완전 결합 캐시란 무엇인가요?,What is a fully-associative cache?,"CPU에서 사용되는 캐시 유형으로, 모든 캐시 라인에서 조회가 병렬로 수행되어 히트 또는 미스를 결정합니다.

이를 위해서는 대규모 캐시 구현의 복잡성과 비용을 증가시키는 매우 많은 수의 비교기가 필요합니다. 따라서 이러한 유형의 캐시는 일반적으로 4K 미만의 소규모 캐시에만 사용됩니다.","It's a type of cache used in the CPU, where lookups are done on all cache lines in parallel to determine a hit or miss.

This requires a very large number of comparators that increase the complexity and cost of implementing large caches. Therefore, this type of cache is usually only used for small caches, typically less than 4K.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
완전 결합 캐시의 단점은 무엇인가요?,Disadvantage of a fully-associative cache?,"- 병렬 검사로 인해 비용이 많이 듭니다
- 이 계획을 구현하는 복잡성","- expensive due to parallel checks
- complexity of implementing this scheme",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
일부 프로세서는 데이터와 명령어에 대한 캐싱을 어떻게 처리하나요?,How do some processors handle caching for data and instructions?,데이터에 대해 약간 느린(3-4 클럭 지연 시간) 별도의 캐시가 있을 것입니다.,There will be a slightly slower (3-4 clocks latency) separate cache for data.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
N-way 집합 연관 캐시란 무엇인가요?,What is an N-way set associative cache?,집합 연관 캐시 방식은 완전 연관 캐싱 방식과 직접 매핑 캐싱 방식의 조합입니다. 집합 연관 방식은 캐시 SRAM을 캐시웨이라고 하는 동일한 섹션(일반적으로 2개 또는 4개 섹션)으로 나누어 작동합니다. 캐시 페이지 크기는 캐시웨이의 크기와 동일합니다. 각 캐시웨이는 작은 직접 매핑 캐시처럼 취급됩니다.,A Set-Associative cache scheme is a combination of Fully-Associative and Direct Mapped caching schemes. A set-associate scheme works by dividing the cache SRAM into equal sections (2 or 4 sections typically) called cache ways. The cache page size is equal to the size of the cache way. Each cache way is treated like a small direct mapped cache.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Core i7 프로세서의 메모리 계층 구조를 설명하세요.,Describe the memory hierarchy of a Core i7 processor.,"각 코어 내부에는 32kB L1 명령어 캐시, 32kB L1 데이터 캐시(8방향 집합 연관), 그리고 전용 256kB L2 캐시(8방향 집합 연관)가 있습니다. 
코어 외부에는 L3가 있으며, 이는 L2보다 8MB로 훨씬 크고 더 똑똑합니다(16방향 연관성).","Inside of each core is a 32 kB L1 instruction cache, a 32 kB L1 data cache (it's 8-way set associative), and a dedicated 256 kB L2 cache (also 8-way set associative). 
Outside of the cores is the L3, which is much larger at 8 MB and smarter (16-way associative) than the L2s.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
엔트로피는 언제 최대치인가요?,When is entropy at its maximum?,모든 결과가 같을 때.,When all outcomes are equal.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
예측 가능성이 증가하면 엔트로피는 어떻게 될까요?,"As predictability increases, what happens to entropy?",감소합니다.,It decreases.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
압축과 관련하여 엔트로피가 증가함에 따라 우리의 압축 능력이 증가하나요?,"As it relates to compression, as entropy increases, does our ability to compress increase?","아니요, 감소합니다.","No, it decreases.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
낮은 엔트로피는 무엇을 의미하나요?,What does low entropy mean?,매우 예측 가능합니다.,Very predictable.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
엔트로피란 무엇인가요?,What is entropy?,"x개의 상태를 나타내기 위해 필요한 최소 비트 수입니다. 또한, 우리가 모르는 정보도 포함됩니다.","The minimum number of bits needed to represent x number of states. Also, information we don't know.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
시저 암호란 무엇인가요?,What is a Caesar cipher?,알파벳을 이전에 합의된 특정 숫자만큼 이동하거나 회전시켜 만든 암호입니다.,The cipher created by shifting/rotating an alphabet by a specific number previously agreed upon.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
다항식 암호란 무엇인가요?,What is a polyalphabetic cipher?,각 문자가 주요 단어의 문자 이동에 따라 이동되는 암호입니다.,A cipher where each letter is shifted based on the shifts of letters in a key word.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n개의 동등하게 가능한 결과의 엔트로피는 얼마인가요?,What is the entropy of n equally likely outcomes?,로그(n),log(n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
GET는 무력한가요?,Is GET idempotent?,네.,Yes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
PUT는 무력한가요?,Is PUT idempotent?,네.,Yes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
POST는 무력한가요?,Is POST idempotent?,아니요.,No.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DELETE는 idempotent인가요?,Is DELETE idempotent?,REST 사양에 따르면 그렇습니다. 하지만 이를 준수하는 것은 개발자의 몫입니다. 리소스를 완전히 제거하는 대신 삭제된 플래그를 사용하여 리소스를 달성할 수 있습니다.,"According to the REST spec, yes, but it's up to the developer to conform to that. It can be achieved by using a deleted flag for a resource instead of completely removing the resource.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
발기부전이란 무엇인가요?,What is idempotent?,메서드가 여러 개의 동일한 요청을 하는 부작용이 있는 속성은 단일 요청의 속성과 동일합니다.,The property that a method has side-effects of making more than one identical requests is the same as for a single request.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
HMAC이란 무엇인가요?,What is HMAC?,"HMAC는 메시지의 체크섬을 제공하는 데 사용되는 키 해시 메시지 인증 코드로, 메시지가 변조되지 않았다는 확신을 주기 위해 메시지와 함께 전송됩니다.","HMAC is a keyed-hash message authentication code used to provide a checksum for a message, sent along with the message to provide confidence that the message has not been tampered.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
MAC이란 무엇인가요?,What is a MAC?,"MAC은 메시지의 체크섬을 제공하는 데 사용되는 메시지 인증 코드로, 메시지가 변조되지 않았다는 확신을 주기 위해 메시지와 함께 전송됩니다.","MAC is a message authentication code used to provide a checksum for a message, sent along with the message to provide confidence that the message has not been tampered.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
RSA는 어떻게 작동하나요?,How does RSA work?,"공개/개인 키 암호화 방법입니다. 공개 키는 메시지를 암호화하여 키 소유자만 해독할 수 있는 암호문으로 암호화하는 데 사용할 수 있습니다. 키 소유자는 비밀 키를 사용하여 메시지를 암호화하고, 비밀 키를 사용하여 공개 키로 암호화된 메시지를 해독합니다.","It's a public/private key cryptography method. The public key can be used to encrypt a message into ciphertext that only the owner of the key can decrypt. The owner of the key uses their secret key to encrypt messages, and their secret key to decrypt messages encrypted with their public key.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이 함수란 무엇인가요?,What is the phi function?,n과 공통 인수를 공유하지 않는 정수의 수 <= n에 답합니다.,It answers the number of integers <= n that do not share a common factor with n.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n이 소수라면 phi(n)은 무엇인가요?,What is phi(n) if n is prime?,n - 1,n - 1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
p가 소수일 때 숫자 a와 소수 p의 gcd는 무엇인가요?,What is the gcd of a number a and prime p when p is prime?,"1, a가 의사 소수(카마이클 수)가 아닌 경우","1, unless a is a pseudoprime (Carmichael number)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SHA는 무엇을 의미하나요?,What does SHA stand for?,보안 해싱 알고리즘 계열 중 하나입니다.,One of the family of Secure Hashing Algorithms.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SHA-3의 가장 큰 출력 크기는 무엇인가요?,What is the largest output size of SHA-3?,512비트,512 bits,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
단방향 함수의 바람직한 특성은 무엇인가요?,What are desirable properties of one-way functions?,"- 충돌 저항성
- 목표 충돌 저항성
- 가단성이 없는","- collision resistant
- target collision resistant
- non-malleable",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"단방향 함수가 충돌 저항성이 있다면, 그것도 목표 충돌 저항성이 있다는 뜻인가요?","If a one-way function is collision-resistant, does that mean it's also target collision-resistant?",네.,Yes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"단방향 함수가 목표 충돌에 강하다면, 그것도 충돌에 강하다는 뜻인가요?","If a one-way function is target collision-resistant, does that mean it's also collision-resistant?",아니요.,No.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
대칭 키 암호화란 무엇인가요?,What is symmetric key encryption?,"알려진 암호화 기능이 있으며, 하나의 키는 암호화 및 복호화에 사용됩니다. 키는 두 당사자가 공유해야 합니다.","There is a known encryption function, and one key is used to encrypt and decrypt. The key has to be shared between 2 parties.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
디피-헬만 키 교환은 어떻게 작동하나요?,How does Diffie-Hellman key exchange work?,두 당사자는 G와 모듈러스 p에 동의하고 각 당사자는 숫자를 제시합니다. 한 당사자는 g^a를 하고 다른 당사자는 g^b를 합니다. 그들은 이 정보를 전달합니다. 한 당사자 A는 B에서 키를 b^a mod p로 계산합니다. B는 키를 얻기 위해 a^b mod p를 계산합니다.,"2 parties agree on a G and a modulus p, and each party comes up with a number. One party does G^a and the other G^b. They pass this information. One party A computes the key from B as B^a mod p. B computes A^b mod p to get the key.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
디피-헬만 키 교환이 완벽한가요?,Is Diffie-Hellman key exchange perfect?,아니요. 중간에 있는 사람은 한쪽을 가로채서 A와 B 당사자와 독립적으로 소통할 수 있습니다.,"No. A man in the middle can intercept one side, and communicate with parties A and B independently.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
RSA(큰 소수의 곱을 사용하는 것)가 암호화를 위해 NP-Complete 알고리즘을 사용하는 것보다 어떻게 더 나은가요?,How is RSA (using product of large primes) better than using NP-Complete algorithms for encryption?,NP-완전 알고리즘은 최악의 경우 어렵지만 평균적인 경우 선형 시간으로 해결할 수도 있습니다. 큰 소수의 곱을 합성하는 것은 평균적인 경우 어렵습니다.,"NP-Complete algorithms are hard in the worst case, but can be sometimes solved in linear time in the average case. Compositing the product of large primes is hard in the average case.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비게네르 암호란 무엇인가요?,What is Vigenere cipher?,"시저 암호의 개선. 문자는 이동된 사전을 기반으로 이동됩니다. ""다중 알파벳 암호""","Improvement on Caesar cipher. Letters are shifted based on a shifted dictionary. ""Polyalphabetic cipher""",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
일회용 패드 암호화란 무엇인가요?,What is a one-time pad encryption?,"""완벽한"" 간단한 암호화 방식입니다. 패드/키는 암호화되는 메시지의 크기와 동일합니다. 키는 무작위로 생성되어 일반 텍스트에 대해 탐색됩니다. 또는 각 문자가 이동해야 하는 양을 결정하는 데 사용되는 키입니다.","The ""perfect"" simple encryption scheme. Pad/key is the same size as the message being encrypted. The key is randomly generated and xored against the plain text. Or key used to determine the amount each letter should be shifted.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
암호화에서 블록 크기란 무엇인가요?,What is block size in cryptography?,"대칭 키 암호는 일반적으로 스트림 암호와 블록 암호로 나뉩니다. 블록 암호는 고정된 길이의 비트 문자열에서 작동합니다. 이 비트 문자열의 길이는 블록 크기입니다. 입력(평면 텍스트)과 출력(암호문)의 길이는 모두 동일하며, 출력은 입력보다 짧을 수 없습니다. 이는 Pionehole 원리와 암호가 가역적이어야 한다는 사실에 의해 논리적으로 요구되며, 출력이 입력보다 길어지는 것은 바람직하지 않습니다.",Symmetric key ciphers are generally divided into stream ciphers and block ciphers. Block ciphers operate on a fixed length string of bits. The length of this bit string is the block size. Both the input (plaintext) and output (ciphertext) are the same length; the output cannot be shorter than the input – this is logically required by the Pigeonhole principle and the fact that the cipher must be invertible – and it is simply undesirable for the output to be longer than the input.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
압축의 한계 요인은 무엇인가요?,What is the limiting factor of compression?,무손실 압축의 경우 엔트로피입니다. 무손실 압축의 경우 손실의 양에 대한 우리의 수용입니다.,"For lossless compression, it's entropy. For lossy compression, it's our acceptance with the amount of loss.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
LZ* 압축은 무엇을 기반으로 하나요?,What is LZ* compression based on?,중복 패턴의 위치와 길이를 목록화하고 값을 사전과 결합합니다.,Cataloging the positions and lengths of redundant patterns and combining the values with a dictionary.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
What is LZMA?,What is LZMA?,마르코프 체인을 사용하는 LZ77의 변형입니다. 7-zip에서 사용되는 7z 압축 알고리즘에 사용됩니다.,It's a variant of LZ77 that uses Markov chains. It's used in the 7z compression algorithms used in 7-zip.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
디플레이션이란 무엇인가요?,What is DEFLATE?,"Gzip, WinZip, mod_deflate에서 사용되는 LZ77 기반의 무손실 압축 알고리즘으로, HTTP 서비스 콘텐츠의 자동 Gzip 압축을 위해 Apache 웹 서버와 번들로 제공됩니다. LZ77과 허프만 코딩을 사용합니다.","It's an lossless compression algorithm based on LZ77 used in Gzip, WinZip, and mod_deflate, which is bundled with Apache web server for automated gzip compression of HTTP served content. It uses LZ77 and Huffman coding.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
LZ77 기반 압축은 어떻게 작동하나요?,How does LZ77-based compression work?,"LZ77은 통계 인코딩 알고리즘인 사전 인코딩 알고리즘입니다. LZ77 알고리즘의 압축은 압축 중인 메시지에서 문자 문자열(단어, 구문 등)이 반복적으로 발생한다는 개념에 기반합니다.

입력은 검색 버퍼와 룩어헤드 버퍼의 두 세그먼트로 나뉩니다. 검색 버퍼는 32KB에서 최대치를 기록합니다. LA 버퍼에서 한 문자로 시작하여 검색 버퍼를 다시 찾아 심볼의 복사본을 찾습니다. 하나가 발견되면 LA 버퍼의 두 번째 심볼을 찾아 이전 심볼과도 일치하는지 확인합니다. 이 방법을 사용하면 심볼의 긴 구문을 감지하여 하나의 단위로 인코딩할 수 있습니다.

이 과정은 각 기호/구에 대해 암묵적으로 롤링 통계 확률을 생성합니다.","LZ77 is a dictionary encoding algorithm, which is a statistical encoding algorithm. Compression in the LZ77 algorithm is based on the notion that strings of characters (words, phrases, etc.) occur repeatedly in the message being compressed.

The input is partitioned into 2 segments: a search buffer and a look-ahead buffer. The search buffer maxes out at 32KB. Starting with one character in the LA buffer, it looks back in the search buffer to find a copy of the symbol. If one is found, it looks at the second symbol of the LA buffer to see if it also matches the predecessor. Using this method, it can detect long phrases of symbols and encode them as one unit.

This process implicitly creates a rolling statistical probability for each symbol/phrase.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
허프만 인코딩이란 무엇인가요?,What is Huffman encoding?,"허프만 인코딩 알고리즘은 개별 심볼의 발생을 분석하여 공통 심볼이 루트에 가장 가까운 이진 트리를 생성하고, 인코딩하는 비트 수가 적고, 공통/희귀 심볼이 적은 경우 트리의 경로가 길며, 인코딩하는 길이가 길어집니다. 루트에서 리프까지 트리를 탐색하고 각 노드에서 1 또는 0을 추적하여 심볼의 인코딩을 결정할 수 있습니다.","Huffman encoding algorithm analyzes the occurrence of individual symbols and creates a binary tree where the common symbols are closest to the root, using fewer bits to encode, and less common/rare symbols have longer paths on the tree, with longer encodings to accommodate. By traversing the tree, from root to leaf, and keeping track of 1 or 0 at each node, we can determine the encoding of the symbol.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
압축의 주요 요인은 무엇인가요?,What is the primary factor of compression?,입력의 중복된 부분이 있을 확률.,Probability of redundant portions of input.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
압축을 최대화하려면 어떻게 해야 하나요?,How can you maximize compression?,주어진 입력을 깊이 분석하여 중복성을 최대한 줄입니다.,By deeply analyzing the given input to reduce redundancy as much as possible.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
버로우스 휠러 변환을 사용하는 압축 방식은 무엇인가요?,What compression scheme uses Burrows-Wheeler transform?,BZip2,BZip2,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
버로우스-휠러 변환은 무엇인가요?,What is the Burrows-Wheeler transform?,"입력 텍스트의 모든 가능한 회전을 사전 순서로 정렬하는 압축 방법입니다. 원본 텍스트가 표시되는 행의 마지막 열과 인덱스를 출력으로 사용합니다. 

디코딩하려면 단일 열을 가져와 각 행에 최종 열 문자를 반복적으로 추가하고 매번 정렬합니다. 열의 높이 길이에 도달하면 인덱스를 사용하여 출력 문자열을 찾습니다.","It's a compression method involving the sorting of all possible rotations of the input text into lexicographic order. Take as output the last column and the index of the row that the original text appears in. 

To decode, take the single column and repeatedly add the final columns characters to each of the rows, sorting each time. Once you've reached the length of the column's height, use the index to find the output string.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
웹 서버에서 Gzip의 일반적인 설정은 무엇인가요?,"For Gzip in web servers, what is the usual setting?",6,6,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
명령줄 gzip에서 최소 및 최대 압축 설정은 무엇인가요?,What is the min and max compression settings in command line gzip?,0-9,0-9,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Gzip으로 JSON을 더 잘 압축할 수 있도록 하려면 어떻게 해야 하나요?,How can you make JSON better compressable with Gzip?,"여러 개의 미니 딕트에서 하나의 딕트로 전환하고, 배열을 값으로 사용합니다. 이렇게 하면 배열의 항목들이 LZ 기반 압축에 공통적으로 사용되는 32KB 검색 버퍼 내에 들어갈 수 있습니다.",Transpose from multiple mini-dicts into one dict with arrays as the values. This allows the items in an array to fit within the 32KB search buffer common to LZ-based compression.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
밀집 코드란 무엇인가요?,What are Dense Codes?,"기호나 단어를 사전이나 배열에 넣고, 인덱스를 텍스트의 값으로 사용하여 단어가 반복되지 않도록 공간을 절약하는 방법입니다.","A way to put symbols or words into a dictionary or array, and use the indices as the values in the text to save space so that words are not repeated.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
LZ 압축에서 LZ는 무엇인가요?,What is the LZ in LZ compression?,렘펠-지브,Lempel-Ziv,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OS 하드웨어 가상화란 무엇인가요?,What is OS hardware virtualization?,운영 체제에서 제공하는 이기종 하드웨어의 추상화는 다양한 하드웨어와의 인터페이스 세부 사항을 숨겨 해당 유형에 대한 공통 인터페이스를 공유하도록 합니다.,"The abstraction of heterogeneous hardware provided by the operating system, to hide the details of interfacing with various hardware so that they share a common interface for that type.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로세스란 무엇인가요?,What is a process?,"주소 공간과 하나 이상의 제어 스레드로 구성된 실행 프로그램의 인스턴스입니다. 권한이 제한되어 있습니다. 메모리 영역을 소유하고 있습니다. 파일 설명자, 파일 시스템 컨텍스트를 소유하고 있습니다. 프로세스의 리소스를 공유하는 하나 이상의 스레드를 캡슐화합니다. 다른 프로세스와 분리되어 있습니다.","An instance of an executing program consisting of an address space and one or more threads of control. It has restricted rights. It owns a region of memory. It owns file descriptors, file system context. It encapsulates one or more threads sharing the process' resources. It is isolated from other processes.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
컨텍스트 전환이란 무엇인가요?,What is a context switch?,한 프로세스를 실행하는 것에서 다른 프로세스로 전환하기 위해 레지스터 상태를 복사하거나 복사하는 것입니다.,The copying out and in of register state to switch from running one process to running another.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스케줄러가 무엇인가요?,What is the scheduler?,스케줄러는 사용자 및 운영 체제 프로세스의 우선순위를 관리합니다.,The scheduler manages the priorities of user and OS processes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
운영 체제가 대부분의 경우 충돌하는 원인은 무엇인가요?,What causes operating systems to crash most of the time?,장치 드라이버. 커널에 있고 매우 낮은 수준입니다. 메모리를 포함한 모든 하드웨어에 액세스할 수 있습니다. 운영 체제 외부의 저자가 작성한 것입니다.,"Device drivers. They are in the kernel and very low level. They have access to all the hardware, including memory. They are written by authors outside of the operating system.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로세스 VM이란 무엇인가요?,What is a process VM?,단일 프로그램 실행을 지원하는 가상 환경입니다. 운영 체제에서 제공합니다.,A virtual environment that supports the execution of a single program. This is provided by an operating system.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
시스템 VM이란 무엇인가요?,What is a system VM?,전체 운영 체제와 그 응용 프로그램의 실행을 지원하는 가상 환경입니다.,A virtual environment that supports the execution of an entire operating system and its applications.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OS는 프로세스 환경을 어떻게 추상화하나요?,How does the OS abstract the environment for a process?,"각 프로세스는 모든 메모리와 CPU 시간을 가지고 있다고 생각하며, 모든 장치를 소유하고 있다고 생각합니다.","Each process thinks it has all the memory and CPU time, and thinks it owns all devices.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
결함 격리란 무엇인가요?,What is fault isolation?,프로세스는 다른 프로세스에 직접적인 영향을 미칠 수 없습니다. 버그는 전체 기계를 충돌시킬 수 없습니다.,Processes are unable to directly impact other processes. Bugs can't crash the whole machine.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
실이란 무엇인가요?,What is a thread?,하나의 독특한 실행 컨텍스트.,"A single, unique execution context.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
32비트 프로세서의 메모리 최대 주소는 얼마인가요?,What's the maximum address in memory for a 32 bit processor?,2^32 - 1,2^32 - 1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로그램의 실행 순서는 무엇인가요?,What is the execution sequence for a program?,"- 가져오기 지침
- 디코딩
- 실행(아마도 ALU를 사용하여 레지스터에 결과를 작성하는 것)
- 레지스터 또는 메모리에 결과 쓰기
- 증분 프로그램 카운터
- 반복","- Fetch instruction
- Decode
- Execute (perhaps using ALU and writing result to a register)
- Write results to registers or memory
- Increment program counter
- Repeat",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로그램 카운터는 무엇을 의미하나요?,What does the program counter point to?,현재 명령어를 포함하는 메모리 내 주소입니다.,An address in memory that contains the current instruction.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스택 포인터란 무엇인가요?,What is the stack pointer?,프로세스 메모리의 스택 부분 상단 주소를 저장하는 레지스터입니다.,A register that holds the address of the top of the stack portion of a process' memory.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
힙 포인터란 무엇인가요?,What is the heap pointer?,프로세스 메모리의 힙 부분 상단 주소를 저장하는 레지스터입니다.,A register that holds the address of the top of the heap portion of a process' memory.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
멀티프로그래밍이란 무엇인가요?,What is multiprogramming?,"하나의 프로세서를 여러 개의 프로세서로 보이게 하고, 각 프로세서는 각각 하나의 프로세스를 처리합니다.","Making one processor appear as multiple processors, each handling one process each.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
컨텍스트 전환의 원인은 무엇인가요?,What triggers a context switch?,"타이머 인터럽트, 하드웨어 인터럽트, 읽기나 쓰기가 완료되기를 기다리는 입출력(OS는 기다리는 시간을 낭비하고 싶지 않습니다), 자발적인 수율.","Timer interrupt, hardware interrupt, I/O where we're waiting for a read or write to complete (OS doesn't want to waste time waiting), voluntary yield.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
듀얼 모드 작동이란 무엇인가요?,What is dual-mode operation?,"하드웨어는 최소 두 가지 모드를 제공합니다: 사용자 모드와 커널 모드(일명: 슈퍼바이저, 보호됨).","Hardware provides at least 2 modes: user mode and kernel (aka: supervisor, protected) mode.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OS는 프로그램을 어떻게 실행하나요?,How does the OS run a program?,"커널 모드(시스템 모드 1)에서 실행을 수행합니다. 시스템 모드 0, 사용자 모드로 이동합니다. 프로그램이 종료되면 커널 모드로 다시 전환합니다.","It does an exec from kernel mode (system mode 1). We go to system mode 0, user mode. When the program exits, we switch back to kernel mode.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
사용자 프로그램은 커null과 어떻게 상호작용하나요?,How does a user program interact with the kernel?,시스템 호출을 수행하면 커널이 작업을 완료하고 커널이 프로세스로 돌아갑니다(사용자 모드로 돌아갑니다).,"It makes a system call, and the kernel takes over, completes the action, and the kernel returns to the process (back to user mode).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
하드웨어에 무언가가 필요할 때는 어떻게 되나요?,What happens when the hardware needs something to happen?,"It does an interrupt, and the kernel takes control, switches the process, and once hardware task is complete, does a return from interrupt back to user mode.","It does an interrupt, and the kernel takes control, switches the process, and once hardware task is complete, does a return from interrupt back to user mode.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로그램이 예외를 만들면 어떻게 되나요?,What happens when a program makes an exception?,프로그램이 종료되고 커널 모드로 전환됩니다.,"The program terminates, and switches to kernel mode.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
베이스 앤 바운드란 무엇인가요?,What is base and bound?,프로세스가 기본 주소와 바인딩 + 기본 주소 사이에서만 메모리에 액세스할 수 있는 메모리 주소 지정 제한입니다. 각 프로세스에는 고유한 기본 및 바인딩이 있습니다. 단점은 주소 0을 얻지 못한다는 것입니다. 주소 변환을 통해 이 문제를 해결할 수 있습니다.,It's a memory addressing restriction where a processes are only allowed access to the memory between a base address and the bound + base addresses. Each process has its own base and bound. A drawback is you don't get address 0. Address translation fixes this.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OS는 인터럽트를 어떻게 처리하는지 알고 있나요?,How does the OS know how to handle an interrupt?,OS의 메모리에 인터럽트 벡터를 유지합니다. 각 인터럽트 유형은 실행할 주소로 매핑됩니다. 이는 OS의 코드에 대한 포인터일 뿐입니다.,It keeps an interrupt vector in the memory of the OS. Each interrupt type is mapped to an address to execute. They are just pointers to code in the OS.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
PC와 uPC의 차이점은 무엇인가요?,What is the difference between PC and uPC?,PC는 현재 프로세스의 프로그램 카운터입니다. uPC는 인터럽트 또는 기타 운영 체제 프로세스가 컨텍스트를 전환하면 반환되는 사용자 프로세스의 PC입니다.,PC is the program counter for the current process. uPC is the PC of the user process we will return to once an interrupt or other OS process switches context.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
기지와 경계는 어떻게 시행되나요?,How are base and bound enforced?,레지스터에 저장됩니다. 하드웨어에 의해 액세스가 제한됩니다.,They are stored in registers. Access is restricted by the hardware.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
x86은 세그먼트와 스택을 어떻게 하나요?,How does x86 do segments and stacks?,"각 프로세스의 개별 세그먼트(히프, 스택, 코드, 정적 데이터)는 고유한 베이스와 바운드를 얻습니다. 메모리에 인접할 필요도 없고 메모리 주소 지정을 통해 위치가 숨겨집니다.","Each process' individual segments (heap, stack, code, static data) get their own base and bound. They don't even need to be adjacent in memory and their location is hidden by memory addressing.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로세스가 중단되면 어떻게 되나요?,"When a process forks, what happens?","프로세스가 일시 중지되고 코드, 스택, 힙, 데이터, 프로그램 카운터 및 레지스터와 같은 완전한 복사본이 만들어집니다.
아이와 부모는 포크 시스콜에서 돌아오는 것으로 재개합니다.","The process is paused, and a complete copy is made: code, stack, heap, data, program counter and registers.
The child and parent resume with returning from fork syscall.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
포크()는 무엇을 반환하나요?,What does fork() return?,"자식 프로세스 ID를 부모에게 반환하고, 자식에게 0을 반환합니다. 오류가 발생하면 < 0입니다.","It returns the child process id to the parent, and 0 to the child. < 0 if error.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
What does wait() do?,What does wait() do?,자식이 종료될 때까지 부모 프로세스가 일시 중지됩니다.,Causes the parent process to pause until the child terminates.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
What does exec() do?,What does exec() do?,현재 실행 중인 프로그램을 다른 프로그램으로 변경하기 위한 시스템 호출입니다.,It's a system call to change the currently running program to something else.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
기다림()에서 돌아오는 것은 무엇인가요?,What comes back from wait()?,"성공하면 종료된 자식의 프로세스 ID를 반환하고, 오류가 발생하면 -1을 반환합니다.","on success, returns the process ID of the terminated child; on error, -1 is returned.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
신호란 무엇인가요?,What is a signal?,다른 프로세스에 알림을 보내기 위한 시스템 호출입니다.,A system call to send a notification to another process.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
아동 과정에서 포크로 무엇을 한 다음 실행할 수 있나요?,"In a child process, what can you do with fork and then exec?",완전히 새로운 프로세스를 만든 다음 종료하세요.,Create a completely new process and then exit.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
껍질이란 무엇인가요?,What is a shell?,작업 제어 프로그램. 프로그래머가 작업을 수행하기 위해 일련의 프로그램을 만들고 관리할 수 있게 해줍니다.,A job control program. It allows a programmer to create and manage a set of programs to do some task.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
마이크로초란 무엇인가요? μs라고도 합니다,What is a microsecond? Also known as μs,백만 분의 일 초.,1 millionth of a second.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
나노초란 무엇인가요?,What is a nanosecond?,10억 분의 1초. ns,1 billionth of a second. ns,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
피코초란 무엇인가요?,What is a picosecond?,1조 분의 1초.,A trillionth of a second.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
커널은 읽기와 쓰기를 어떻게 처리하나요?,How does the kernel handle reads and writes?,읽기를 버퍼링하여 프로그램의 스트림으로 처리할 수 있습니다. 쓰기는 버퍼링되며 커null이 버퍼를 플러시할 때까지 쓰기되지 않습니다.,It buffers reads so they can be handled as a stream in your program. Writes are buffered and are not written until the kernel flushes the buffer.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"읽기, 읽기, 쓰기, 쓰기 I/O 호출의 차이점은 무엇인가요?","What's the difference between the fread, read, fwrite, write I/O calls?",f가 있는 것은 고수준 I/O이며 커널에 의해 스트리밍되고 버퍼링됩니다. 비f는 저수준 I/O입니다.,The ones with f are high-level I/O and streamed and buffered by the kernel. The non-f are low-level I/O.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
시스템 호출이 이루어질 때 매개변수는 어디에 저장되나요?,"When a system call is made, where are parameters stored?",레지스터에.,In registers.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
socket이란 무엇인가요?,What is a socket?,네트워크 I/O 대기열을 추상화한 것입니다. 생산자는 한쪽에 글을 쓰고 소비자는 다른 쪽에서 글을 읽는 통신 방식입니다. 파일을 쓰고 읽는 것과 비슷하지만 파일은 포함되지 않습니다.,"It's an abstraction of a network I/O queue.  It's a method of communication where a producer writes to one side, and a consumer reads from the other side. It's similar to writing and reading a file, but no file is involved.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
현대에는 어떤 socket이 있나요?,What sockets are in modern use?,"로컬 socket을 로컬 머신에 연결하는 UNIX socket이라고 하며, TCP/IP와 UDP/IP입니다.","Local sockets to local machine, called UNIX sockets, and TCP/IP and UDP/IP.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
GIL이란 무엇인가요?,What is the GIL?,"글로벌 인터프리터 잠금 장치입니다. CPython의 일부입니다. 인터프리터에서 한 번에 하나의 스레드만 실행되도록 보장합니다. GIL을 사용하면 메모리 관리, C 확장 호출 등 많은 하위 수준의 세부 사항을 간소화할 수 있습니다","It's the Global Interpreter Lock. It's is a part of CPython. It ensures only one thread runs in the interpreter at once. Having the GIL simplifies many low-level details (memory management, callouts to C extensions, etc.)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
GIL은 언제 출시되나요?,When is the GIL released?,"I/O 중(디스크 IO, 네트워크 IO, 출력 표시)에는 스레드가 절전 모드를 사용할 때가 포함됩니다.","During I/O (disk IO, network IO, output to display) including when a thread uses sleep.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"CPython에서 ""틱""이란 무엇인가요?","What is a ""tick"" in CPython?",대략 1개의 기계 명령어.,Approximately 1 machine instruction.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"CPython 인터프리터에서 100개의 ""틱""마다 무슨 일이 일어나나요?","What happens every 100 ""ticks"" in the CPython interpreter?",스레드가 GIL을 해제한 후 다시 획득하려고 시도하는 동안 스레드 검사가 발생합니다. 다른 파이썬 스레드들도 GIL을 놓고 경쟁하게 됩니다. 3.4에서는 더 이상 그렇지 않습니다.,A thread check occurs during which the thread releases the GIL then attempts to reacquire it. Other Python threads will contend for the the GIL. This is no longer the case in 3.4.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CPython에서 자물쇠란 무엇인가요?,What is a lock in CPython?,이진 세마포어입니다. 뮤텍스 자물쇠가 아닙니다.,It's a binary semaphore. It's not a mutex lock.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
더미가 너무 커지면 어떻게 되나요?,What happens when the heap gets too large?,페이지 오류가 발생하면 커null이 더 많은 메모리를 할당합니다.,"It does a page fault, and the kernel will allocate more memory.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
힙과 스택이 메모리에서 만나면 어떻게 되나요?,What happens when the heap and stack meet in memory?,경비원 페이지가 열리고 프로세스가 종료됩니다.,A guard page is hit and the process is killed.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로세스에 대한 정보는 어디에 저장되나요?,Where is information about a process stored?,PCB(공정 제어 블록)에서.,In a PCB (process control block).,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스레드에 대한 정보는 어디에 저장되어 있나요?,Where is information about a thread stored?,TCB(스레드 제어 블록)에서.,In a TCB (thread control block).,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
같은 프로세스의 여러 스레드가 공유하는 것은 무엇인가요?,What do multiple threads in the same process share?,"힙, 파일 설명자, 코드, 정적 데이터.","Heap, file descriptors, code, static data.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로세스의 스레드는 무엇을 공유하지 않나요?,What do threads in a process NOT share?,등록하고 쌓습니다.,Registers and stack.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
깊은 재귀에 들어가면 스레드 스택에서 어떤 일이 발생할 수 있나요?,What can happen with thread stacks if one goes into a deep recursion?,한 스레드의 스택이 다른 스레드의 스택으로 성장하여 그 위에 쓸 수 있습니다. 가드 페이지는 이를 방지하는 데 도움이 될 수 있습니다.,One thread's stack can grow into another thread's stack and write over it. A guard page can help to protect from that.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스레드가 디스패처에 다시 제어권을 부여하는 원인은 무엇인가요?,What can cause a thread to give control back to the dispatcher?,"스레드는 자발적으로 제어를 반환하거나(수익률, I/O 요청, 차단, 다른 스레드의 신호 대기) 인터럽트에 의해 선점됩니다.","Thread returns control voluntarily (yield, requesting I/O (which blocks), wait for signal from another thread) or gets preempted by an interrupt.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로세스 컨텍스트 전환을 수행하는 데 얼마나 걸리나요?,How long does it take to do a process context switch?,3-4 마이크로초.,3-4 microseconds.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스레드 컨텍스트 전환을 수행하는 데 얼마나 걸리나요?,How long does it take to perform a thread context switch?,100ns,100ns,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
컨텍스트 전환은 얼마나 자주 일어나나요?,How often do context switches happen?,매 10-100ms마다.,Every 10-100 ms.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
컨텍스트 전환 시간은 무엇의 크기에 따라 급격히 증가하나요? (100배 이상 증가합니다.),Context switch time increases sharply with the size of what? (by 100x or more.),작업 세트 - 프로세스가 시간 창에서 사용하는 메모리의 하위 집합입니다. 캐시 등.,The working set - the subset of memory used by the process in a time window. Cache etc.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OS를 커널 모드로 전환하려면 시스템 호출에서 어떤 일이 발생하나요?,What happens in a system call to get the OS to switch to kernel mode?,함정.,A trap.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로세스당 몇 개의 스레드를 실행해야 하나요?,How many threads should you run per process?,코어당 하나.,One per core.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동시성은 어떻게 이루어지나요?,How is concurrency accomplished?,CPU 시간을 다중화함으로써.,By multiplexing CPU time.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
병렬성과 동시성의 차이점은 무엇인가요?,What's the difference between parallelism and concurrency?,동시성은 여러 블록의 명령어를 독립적으로 실행하는 것을 의미합니다. 병렬 처리는 여러 코어에서 동시에 명령어를 실행하는 것을 의미합니다.,"Concurrency means running multiple blocks of instructions independently. Parallelism means running instructions at the same time, as on multiple cores at once.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
초과 구독이란 무엇인가요?,What is oversubscription?,사용 가능한 코어보다 더 많은 스레드를 생성합니다.,Spawning more threads than available cores.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인종 조건이란 무엇인가요?,What is a race condition?,결정론적 절차의 결과가 하위 프로세스 타이밍의 차이에 따라 비결정론적이 되는 경우.,When the outcome of a deterministic procedure becomes non-deterministic based on differences in subprocess timing.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
다른 프로세스를 방해하지 않고 리소스를 독점적으로 사용하기 위해 무엇을 배치할 수 있나요?,What can you put in place to exclusively use a resource without another process interfering?,"뮤텍스, 더 좋은 것은 자물쇠 가드입니다.","A mutex, or even better, a lock guard.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 뮤텍스는 어떻게 사용하나요?,How do you use a mutex in Python?,"스레드 가져오기

잠금 = 스레드.잠금()

[첫 번째 과정]
전역 잠금
잠금 해제.() 해제
...
[다른 과정]
전역 잠금
lock.acquire() // 액세스를 시도하고, 접속할 수 없으면 기다립니다","import threading

lock = threading.Lock()

[first process]
global lock
lock.release()
...
[other process]
global lock
lock.acquire() // attempts to get access, waits if it can't",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
미래는 무엇을 하나요?,What does a future do?,Allows us to receive a return value from a function in a child thread.,Allows us to receive a return value from a function in a child thread.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
약속이란 무엇인가요?,What is a promise?,나중에 자식 스레드의 함수에 매개변수를 보내겠다는 약속.,A promise to send a parameter to a child thread's function later.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
라이브록이란 무엇인가요?,What is livelock?,"여러 프로세스가 현재 상태를 처리하려고 시도하지만 둘 다 진전을 이루지 못할 때 발생합니다. 이는 시스템이 deadlock를 해결하려고 시도하지만 다른 프로세스 또는 동일한 프로세스가 계속 트리거될 때 발생할 수 있습니다.
기아도 또 다른 예입니다.","It occurs when multiple processes are attempting to deal with the current state, but neither makes progress. This can happen when a system is attempting to resolve a deadlock situation but another or the same process continue to trigger it.
Starvation is another example.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
종료된 프로세스는 종료된 상태에서 얼마나 오래 머무르나요?,How long does a terminated process stay in the terminated state?,부모 프로세스가 종료 코드를 받기 위해 대기할 때까지.,Until the parent process does a wait to receive its exit code.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 프로세스를 포크하는 데 무엇을 사용할 수 있나요?,"In Python, what can you use to fork a process?",다중 처리 모듈. 작업자 프로세스 풀을 만들거나 임시 하위 프로세스를 포크하는 프로세스 풀 및 프로세스를 지원합니다.,The multiprocessing module. It supports process Pool and Process for making a pool of worker processes or forking temporary subprocesses.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동시 선물 모듈은 무엇을 제공하나요?,What does the concurrent.futures module offer?,"ThreadPoolExecutor
프로세스풀 실행기
실행자 객체
미래 객체","ThreadPoolExecutor
ProcessPoolExecutor
Executor objects
Future objects",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인터럽트란 무엇인가요?,What is an interrupt?,하드웨어로 호출된 컨텍스트 스위치. 인터럽트 핸들러는 항상 즉시 실행됩니다.,A hardware-invoked context switch. The interrupt handler always runs immediately.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인터럽트 중에 무슨 일이 일어나나요?,What happens during an interrupt?,"현재 실행 중인 프로세스' 상태가 저장됩니다. 커널 모드로 전환하고 인터럽트 핸들러가 실행되며, 완료되면 시스템이 다시 사용자 모드로 돌아가 프로세스가 계속됩니다.","The currently running process' state is saved. We switch to kernel mode, the interrupt handler runs, and once its complete, the system goes back to user mode and the process continues.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로세스를 포크하면 실제로 어떤 일이 일어날까요?,What really happens when you fork a process?,포크는 모든 것을 복사하는 것이 아니라 읽기 전용으로 설정된 페이지 테이블 포인터를 복제할 뿐입니다. 이를 카피 온 라이트라고 합니다. 메모리에 글을 쓰면 상태가 복사됩니다.,"A fork doesn't copy everything, it just duplicates the page table pointers, which are all set at read-only. Called copy-on-write. Once you write to memory, then it copies the state.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
다중 처리란 무엇인가요?,What is multiprocessing?,다중 코어에서 병렬 실행.,Parallel execution on multiple cores.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
PCB에는 무엇이 포함되어 있나요?,What does a PCB contain?,"프로세스의 모든 것:
- 상태
- 상태 등록(준비되지 않은 경우)
- PID, 사용자, 실행 파일, 우선순위
- 실행 시간
- 메모리 공간, 번역","Everything about a process:
- status
- register state (when not in ready state)
- PID, User, Executable, Priority
- Execution time
- Memory space, translation",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인터럽트 핸들러의 특별한 점은 무엇인가요?,What is special about an interrupt handler?,인터럽트를 비활성화하고 완료까지 실행합니다.,It disables interrupts and runs to completion.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로세스가 가질 수 있는 다섯 가지 상태는 무엇인가요?,What are the five states a process can be in?,"- 새로 생성될 때
- 준비 완료
- 달리기
- 대기(I/O 또는 이벤트 조정 대기)
- 종료됨(부모 프로세스가 종료 코드를 수신하는 waits)","- new (when being created)
- ready
- running
- waiting (for I/O or event coordination)
- terminated (waits for parent process to receive its exit code)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
필터()와 맵()의 차이점은 무엇인가요?,What is the difference between filter() and map()?,"필터는 true 또는 false(예언)을 반환하는 함수를 사용합니다.
지도는 값을 반환하는 함수를 사용합니다.","Filter uses a function that returns true or false (predicate).
Map uses a function that returns a value.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동기화란 무엇인가요?,What is synchronization?,원자 연산을 사용하여 스레드 간의 협력을 보장합니다.,Using atomic operations to ensure cooperation between threads.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
중요한 섹션이란 무엇인가요?,What is a critical section?,프로세스 내의 여러 스레드가 동시에 액세스하려고 시도할 수 있는 코드 블록입니다. 올바른 처리를 보장하려면 중요한 섹션을 입력하기 전에 잠근 다음 종료할 때 잠금을 해제해야 합니다. 이렇게 하면 공유 데이터에 대한 상호 제외가 발생합니다.,"A block of code that multiple threads within a process could try to access at the same time. To ensure correct processing, the critical section should be locked before entering, then unlocked when leaving. This creates a mutual exclusion on shared data.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
우선순위 역전 문제는 무엇인가요?,What is the priority inversion problem?,잠금이 해제되기를 기다리는 스레드는 CPU를 훔쳐서 잠금이 있는 스레드보다 더 높은 우선순위를 얻게 됩니다. 따라서 대기 중인 스레드가 우선순위가 높기 때문에 잠금을 유지하는 스레드가 잠금을 완료하고 해제할 수 없습니다.,"A thread that is busy-waiting for a lock to be released ends up stealing CPU and getting a higher priority than the thread with the lock. SO since the waiting thread gets higher priority, the thread holding the lock can't complete and release the lock.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
바쁘게 기다리는 것이 무엇인가요?,What is busy-waiting?,"하나 이상의 스레드는 값을 지속적으로 확인하거나, 잠금이 해제되기를 기다리는 동안 값을 확인하고 기록하여 잠금을 유지하는 스레드에서 CPU를 훔치는 방식으로 많은 CPU를 사용하고 있습니다.","One or more threads is using a lot of CPU by continuously checking a value, or test&set() checking and writing a value in wiating for a lock to release, thus stealing CPU from the thread holding the lock.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
세마포어란 무엇인가요?,What is a semaphore?,"A semaphore limits access to a maximum number of threads (maximum concurrency) to have access to a source at the same time. It is commonly used to limit database connections.

A semaphore (defined by Dijkstra) is kind of signaling solution for handling concurrency data integrity problems that arise in multi-threaded applications. It has a non-negative integer that supports 2 operations:
- P() [proberen, to test/probe] - atomic operation that waits for semaphore to become > 1, then decrements it by 1 (wait)
- V() [verhogen, to increment] - an atomic operation that increments the semaphore by 1, waking up any P (signal)

The initial semaphore value will determine how many threads can run in the critical section at once.","A semaphore limits access to a maximum number of threads (maximum concurrency) to have access to a source at the same time. It is commonly used to limit database connections.

A semaphore (defined by Dijkstra) is kind of signaling solution for handling concurrency data integrity problems that arise in multi-threaded applications. It has a non-negative integer that supports 2 operations:
- P() [proberen, to test/probe] - atomic operation that waits for semaphore to become > 1, then decrements it by 1 (wait)
- V() [verhogen, to increment] - an atomic operation that increments the semaphore by 1, waking up any P (signal)

The initial semaphore value will determine how many threads can run in the critical section at once.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
상호 배제의 다른 이름은 무엇인가요?,What's another name for a mutual exclusion?,이진 세마포어.,Binary semaphore.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
모니터란 무엇인가요?,What is a monitor?,공유 데이터에 대한 동시 접근을 관리하기 위한 잠금 및 0개 이상의 조건 변수.,A lock and zero or more condition variables for managing concurrent access to shared data.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
잠금 장치와 상태 변수는 각각 무엇에 사용해야 하나요?,What should locks and condition variables each be used for?,"잠금 - 상호 제외
조건 변수 - 스케줄링 제약 조건","locks - mutual exclusion
condition variables - scheduling constraints",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
조건 변수란 무엇인가요?,What is a condition variable?,중요한 섹션에서 무언가에 대한 접근을 기다리는 스레드의 줄.,A queue of threads waiting for access to something in a critical section.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
조건 변수의 특별한 특징은 무엇인가요?,What is a special feature of condition variables?,우리가 잠을 잘 때 원자적으로 잠금 장치를 해제하여 중요한 구역 안에서 잠을 잘 수 있게 해줍니다.,It allows sleeping inside a critical section by atomically releasing lock at the time we sleep.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
조건 변수에 대한 3가지 방법은 무엇인가요?,What are the 3 methods on a condition variable?,"대기(&잠금)
신호 () - 다음 대기 멤버에게 신호를 보냅니다
방송 () - 대기 중인 모든 멤버에게 신호를 보냅니다","wait(&lock)
signal() - signals the next waiting member
broadcast() - signals all waiting members",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
대부분의 최신 프로세서는 어떤 종류의 스케줄링을 사용하나요?,What type of scheduling do most modern processors use?,메사 스케줄링.,Mesa-scheduling.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스케줄러가 달성하려고 하는 것들은 무엇인가요?,What are some things the scheduler tries to accomplish?,"- 응답 시간 최소화
- 처리량 최대화
- 공정성","- minimize response time
- maximize throughput
- fairness",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
문맥 전환의 단점은 무엇인가요?,What is a drawback of context switching?,스레드가 스위칭에서 돌아와 CPU 캐시가 이전 값을 가지지 않는다는 것을 발견하면 CPU 캐시가 누락됩니다.,CPU cache misses as thread comes back from switching and finds the CPU cache doesn't have the values it had before.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
호송 효과는 무엇인가요?,What's the convoy effect?,짧은 프로세스는 FIFO 스타일의 준비 대기열에서 긴 프로세스 뒤에 갇혀 있습니다.,Short processes get stuck behind long processes in a FIFO style ready queue.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
라운드 로빈 스케줄링 방식이란 무엇인가요?,What is the round robin scheduling scheme?,각 프로세스는 실행되는 데 시간 양자 q 밀리초가 걸립니다. 10-100ms 동안 q는 조정할 수 있습니다. 각 프로세스는 해당 시간 슬라이스(또는 완료에 가까울 경우 완료될 때까지) 동안 실행된 다음 준비 대기열로 돌아갑니다.,"Each process gets a time quantum q milliseconds to run. 10-100ms, the q is tunable. Each process runs for that time slice (or until completion if close to done) and then goes back on the ready queue.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
라운드 로빈 스케줄링 방식의 장점은 무엇인가요?,What are pros of the round-robin scheduling scheme?,"- 짧은 작업에 더 적합합니다 (시간 단축에 맞습니다)
- 공정한","- better for short jobs (they fit in the time slice)
- fair",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
라운드 로빈 스케줄링 방식의 단점은 무엇인가요?,What is a con of the round-robin scheduling scheme?,긴 작업은 컨텍스트 전환 시간이 늘어나기 때문에 더 오래 걸립니다.,Long jobs take longer because context-switching time adds up.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
컨텍스트 전환은 얼마나 걸리나요?,How long does context switching take?,"0.1ms - 1ms
대략 1%의 오버헤드입니다.","0.1ms - 1ms
It's roughly 1% overhead.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
기아란 무엇인가요?,What is starvation?,우선순위가 낮은 작업이 항상 더 높은 우선순위의 작업이 실행되기 때문에 실행되지 않을 때.,When low-priority jobs never get run because there are always higher priority jobs running.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로세스의 우선순위는 어떻게 변경되나요?,How does a process' priority get changed?,"스케줄러는 상호작용성, 잠금, 버스트 동작 등에 대한 휴리스틱을 활용합니다.","The scheduler utilizes heuristics on interactivity, locking, burst behavior, etc.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
deadlock를 피하는 방법에는 어떤 것들이 있나요?,What are some methods of avoiding deadlock?,"- 리소스 대기를 허용하지 않습니다(means 많은 재시도)
- 모든 스레드가 처음에 필요한 모든 것을 요청하도록 합니다
- 자원의 순환적 사용을 방지하기 위해 모든 스레드가 특정 순서로 자원을 요청하도록 강제합니다(그래서 사이클이 존재하지 않음)
- 교착 상태가 감지되면 일시적으로 리소스를 확장합니다","- don't allow waiting for a resource (means a lot of retries)
- make all threads request everything they'll need at the beginning
- force all threads to request resources in a particular order preventing any cyclic uses of resources (so no cycle exists)
- temporarily expand resources when a deadlock is detected",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
deadlock를 방지하기 위한 은행가의 알고리즘은 무엇인가요?,What is the banker's algorithm for preventing deadlock?,"- 자원을 동적으로 할당하다
- 각 요청을 평가하고 스레드의 일부 순서가 이후에도 deadlock가 없는지 승인합니다
- 요청이 승인된 것처럼 행동한 다음 시뮬레이션을 실행하여 deadlock가 발생하는지 확인합니다","- allocate resources dynamically
- evaluate each request and grant if some ordering of threads is still deadlock-free afterward
- do so by pretending the request was granted, then running a simulation to see if a deadlock would occur",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
은행가의 알고리즘은 식당 변호사 문제를 어떻게 해결하나요?,How does the banker's algorithm solve the dining lawyers problem?,"젓가락을 잡으려고 할 때, 그것은 둘 중 하나입니다:
- 마지막 젓가락이 아닙니다
- 마지막 젓가락이지만 나중에 다른 사람이 두 개를 갖게 될 것입니다","When you try to grab a chopstick, it's either:
- not the last chopstick
- is last chopstick but someone else will have two afterwards",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"CPU는 가상 주소를 사용하나요, 아니면 물리적 주소를 사용하나요?",Does the CPU use virtual addresses or physical addresses?,가상 주소,Virtual addresses,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가상 주소를 물리적 주소로 변환하는 것은 무엇인가요?,What translates virtual to physical addresses?,MMU - 메모리 관리 장치,The MMU - the memory management unit,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
deadlock에 빠지기 위해 필요한 네 가지 조건은 무엇인가요?,What are the four conditions needed for a deadlock?,"- 상호 배제
- 잡고 기다리다
- 선점 없음
- 순환 대기","- mutual exclusion
- hold and wait
- no preemption
- circular wait",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
IPv4 주소는 몇 비트인가요?,How many bits represent an IPv4 address?,32,32,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
IPv6 주소는 몇 비트인가요?,How many bits represent an IPv6 address?,128,128,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
TCP/IP 애플리케이션 계층에서 사용되는 몇 가지 프로토콜의 이름을 말하세요.,Name some of the protocols used within the TCP/IP application layer.,"- http
- https
- FTP
- tftp
- ntp
- irc
- 텔넷
- SMTP
- SSH
- DNS
- SNMP
- 팝3","- http
- https
- ftp
- tftp
- ntp
- irc
- telnet
- smtp
- ssh
- dns
- snmp
- pop3",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
NTP란 무엇인가요?,What is NTP?,네트워크 시간 프로토콜,Network time protocol,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
TCP/IP 전송 계층에는 어떤 프로토콜이 있나요?,What are some protocols in the TCP/IP transport layer?,"- TCP
- UDP","- TCP
- UDP",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
TCP/IP 네트워크 계층 프로토콜이란 무엇인가요?,What are some TCP/IP network layer protocols?,"IP - 인터넷 프로토콜
ICMP - 인터넷 제어 메시지 프로토콜
ARP - 주소 확인 프로토콜","IP - internet protocol
ICMP - internet control message protocol
ARP - address resolution protocol",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
TCP/IP 네트워크 액세스 계층 프로토콜에는 어떤 것이 있나요?,What are some TCP/IP network access layer protocols?,"- RJ45
- ISDN
- 전자레인지
- 이더넷
- 와이파이
- 광섬유
- ATM
- RJ48
- 구리 케이블","- RJ45
- ISDN
- Microwave
- Ethernet
- Wifi
- Fiber optics
- ATM
- RJ48
- Copper cables",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
PDU란 무엇인가요?,What is a PDU?,"프로토콜 데이터 단위
- TCP/IP 스택의 특정 계층에서 정보를 설명하는 데 사용되는 일반 용어","Protocol data unit
- generic term used to describe the information at a given layer in the TCP/IP stack",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OSI 레이어 7의 PDU는 무엇인가요?,What is the PDU for OSI layer 7?,"교환되는 정보에 따라 결정되는 데이터: 텍스트, 암호화된 텍스트, 압축된 데이터","data, determined by what information is being exchanged: text, encrypted text, compressed data",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OSI 전송 계층의 PDU는 무엇인가요?,What are the PDUs for the the OSI transport layer?,"TCP의 경우 세그먼트라고 합니다
UDP의 경우 데이터그램이라고 합니다","for TCP, it's called a segment
for UDP, it's called a datagram",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
TCP/IP 인터넷 계층의 PDU는 무엇인가요?,What is the PDU for the TCP/IP internet layer?,패킷,packet,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OSI 네트워크 액세스 계층의 2개 PDU는 무엇인가요?,What are the 2 PDUs of the OSI Network Access layer?,"데이터 링크 계층: 프레임
물리 계층: 비트","data link layer: frames
physical layer: bits",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DNS 포트는 무엇인가요?,What is the port for DNS?,53,53,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
텔넷의 포트는 무엇인가요?,What is the port for telnet?,23,23,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SSH의 포트는 무엇인가요?,What is the port for ssh?,22,22,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
고객의 포트 범위는 어떻게 되나요?,What is the port range for clients?,8000-65535,8000-65535,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이더넷 프레임에는 몇 비트가 있나요?,How many bits are in an ethernet frame?,"48비트, 16진수로 표시됩니다.","48 bits, represented as a hexadecimal number.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
MAC은 무엇을 의미하나요?,What does MAC stand for?,"매체 접근 제어, 데이터 링크 계층의 하위 계층.","medium access control, a sublayer in the data link layer.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
데이터 링크 계층에서 PDU와 주소 지정은 무엇인가요?,What is the PDU and the addressing at the data link layer?,"PDU: 프레임
주소 지정: 물리적(MAC) 주소","PDU: frame
Addressing: physical (MAC) address",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
데이터 링크 계층에는 어떤 장치가 있나요?,What devices are at the data link layer?,"브리지, 스위치(멀티포트 브리지). 프레임을 검사하고 전방 여부를 확인합니다.","Bridges, switches (multi-port bridge). They inspect frames and forward or not.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인터넷/네트워크 계층에는 어떤 장치가 있나요?,What devices are at the Internet/Network layer?,"라우터
레이어 3 스위치: 스위치 또는 라우터일 수 있습니다","Routers
Layer 3 switches: can be a switch or a router",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인터넷/네트워크 계층에서 PDU와 주소 지정은 무엇인가요?,What is the PDU and the addressing at the Internet/Network layer?,"PDU: 패킷
주소 지정 IP 주소","PDU: packet
Addressing IP address",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
전송 계층에서 PDU와 주소 지정은 무엇인가요?,What is the PDU and the addressing at the Transport layer?,"PDU: 세그먼트
주소 지정: 포트","PDU: segment
addressing: ports",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
전송 계층에는 어떤 장치가 있나요?,What devices are at the Transport layer?,방화벽,Firewalls,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
HTTP에서 socket이란 무엇인가요?,What is a socket in HTTP?,IP 주소와 포트의 조합.,The combination of an IP address and a port.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
3자 악수(TCP)에는 무엇이 관여하나요?,What is involved in the 3 way handshake (TCP)?,"SYN=1 - 동기화하고 Seq 번호를 제공하며 응답에서 숫자 + 1을 기대합니다
ACK=1 - SYN=1 및 Seq도 전송하는 서버를 확인하여 전송합니다
SYN=0 ACK=1 및 Seq(증가된 숫자)가 서버로 돌아갑니다

이제 말하는군요!","SYN=1 - synchronize, gives a Seq number and expects that number + 1 in response
ACK=1 - sent by acknowledging server with incremented number, who also sends a SYN=1 and a Seq
SYN=0 ACK=1 and the Seq (incremented number) back to the server

Now you're talking!",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
케르베로스는 대칭 암호화 또는 비대칭 암호화를 사용하나요?,Does Kerberos use symmetric or asymmetric encryption?,대칭. KDC 테이블의 모든 주체와 키를 추적합니다.,Symmetric. It tracks all principals and their keys in its KDC table.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OSI 모델의 7가지 레이어는 무엇인가요?,What are the 7 layers of the OSI model?,"- 응용 프로그램
- 프레젠테이션
- 세션
- 운송
- 네트워크
- 데이터 링크
- 물리적","- application
- presentation
- session
- transport
- network
- data link
- physical",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
TCP/IP의 4가지 계층은 무엇인가요?,What are the 4 layers of TCP/IP?,"- 애플리케이션(OSI에서 애플리케이션, 프레젠테이션, 세션)
- 운송
- 인터넷(OSI의 네트워크)
- 네트워크 액세스(OSI의 데이터 링크 및 물리적)","- application (application, presentation, session in OSI)
- transport
- internet (network in OSI)
- network access (data link & physical in OSI)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SSL 인증서는 인증 기관(CA)에서 어떻게 생성되나요?,How is an SSL certificate generated by the certificate authority (CA)?,"인증 기관의 비밀 키로 서명된 특정 도메인 이름의 일반 이름과 공개 키입니다.
브라우저는 CA의 공개 키로 인증서를 확인할 수 있습니다.","The common name and public key for a given domain name, signed by the certificate authority's secret key.
The browser can verify the cert with CA's public key.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
쿠키의 보안 깃발은 무엇인가요?,What is the secure flag on a cookie?,"쿠키를 설정하면 https 요청에만 전송됩니다.
설정되지 않으면 쿠키는 http와 https 요청 모두에 전송됩니다.","When set on a cookie, it will only be sent on https requests.
When not set, cookie will be sent on both http and https requests.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬 멀티 스레드 프로그램은 언제 종료되나요?,When does a Python multi-threaded program terminate?,살아있는 비데몬 스레드가 남아 있지 않으면 전체 파이썬 프로그램이 종료됩니다.,The entire Python program exits when no alive non-daemon threads are left.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 스레드가 데몬으로 설정되어 있으면 스레드가 절전 모드로 전환되면 어떻게 되나요?,"In Python, if a thread is set to daemon, what happens when the thread sleeps?","파이썬 프로그램이 종료되면, 스레드가 잠들어 있어도 종료됩니다.","If the Python program reaches its end, the thread will be killed even if it's sleeping.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스레드가 데몬인 경우 조인()을 하면 어떻게 되나요?,"If a thread is a daemon, what happens when you do a join()?",메인 스레드가 그것을 기다릴 것입니다.,The main thread will wait for it.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
WebRTC는 무엇을 의미하나요?,What does WebRTC stand for?,웹 실시간 커뮤니케이션,Web Real-Time Communication,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
연결당 스레드 패턴의 예를 들어보세요.,Give an example of the thread-per-connection pattern.,"웹 서버는 연결당 스레드를 생성한 다음, 연결이 끝나면 해당 스레드를 재사용하거나 스레드를 종료할 수 있습니다.","A web server might spawn a thread per connection, then reuse that thread once the connection ends, or terminate the thread.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스레드 풀 모델의 예를 들어보세요.,Give an example of the thread pool model.,스레드 풀을 유지 관리하여 데이터베이스 연결을 위한 리소스로 빠르게 제공할 수 있습니다.,A pool of threads can be maintained in order to quickly provide one as a resource for a database connection.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
패킷에는 무엇이 포함되어 있나요?,What is contained in a packet?,"- 소스 IP
- 목적지 IP
- 데이터 - 최종 페이로드의 일부","- source IP
- destination IP
- data - some portion of the final payload",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
TLS란 무엇인가요?,What is TLS?,SSL의 후속 버전입니다. 보안 문제로 인해 모든 SSL 버전이 비활성화되었습니다.,The successor to SSL. All of SSL's versions have been deprecated due to security issues.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
수송층의 목적은 무엇인가요?,What is the purpose of the transport layer?,여러 애플리케이션이 하나의 네트워크 연결을 동시에 사용할 수 있도록 합니다.,To allow multiple applications to use one network connection simultaneously.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DNS 스푸핑이란 무엇인가요?,What is DNS spoofing?,DNS 서버가 손상되어 일부 도메인에 대해 잘못된 IP 주소를 반환합니다.,A DNS server is compromised and returns incorrect IP addresses for a some domains.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
TCP는 무엇을 의미하나요?,What does TCP stand for?,전송 제어 프로토콜,Transmission Control Protocol,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
TCP의 특별한 점은 무엇인가요?,What is special about TCP?,"패킷 데이터의 송수신을 관리합니다.
패킷 수신을 승인합니다.
패킷이 누락된 경우 소스가 누락된 패킷을 다시 전송합니다.","It manages the sending and receiving of packet data.
It acknowledges receipt of packets.
If packets are missing, the source will resend the missing packets.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
HTTP란 무엇인가요?,What is HTTP?,클라이언트-서버 통신 프로토콜.,The protocol for client-server communication.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
UDP는 무엇을 의미하나요?,What does UDP stand for?,사용자 데이터그램 프로토콜.,User Datagram Protocol.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
UDP 헤더의 크기는 어떻게 되나요?,What is the size of a UDP header?,8바이트,8 bytes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
TCP 헤더의 크기는 어떻게 되나요?,What is the size of a TCP header?,20바이트,20 bytes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
ICMP는 무엇을 의미하나요?,What does ICMP stand for?,인터넷 제어 메시징 프로토콜,Internet Control Messaging Protocol,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
ICMP는 무엇을 가능하게 하나요?,What does ICMP allow you to do?,장치가 통신하고 오류를 전송할 수 있습니다. 장치가 네트워크에 있는지 확인하기 위해 에코할 수 있습니다.,Allows devices to communicate and send errors. Can echo to see if a device is on the network.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SNMP는 무엇을 의미하나요?,What does SNMP stand for?,간단한 네트워크 관리 프로토콜.,Simple Network Management Protocol.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SNMP는 무엇을 하나요?,What does SNMP do?,"각 상자에 SNMP 에이전트가 설치되어 있을 때 네트워크의 컴퓨터에서 정보를 수집합니다. 컴퓨터, 소프트웨어 설치 및 컴퓨터 구성에 대한 대량의 정보를 전송할 수 있습니다.","Gathers info from machines on the network when each box has an SNMP agent installed. Can send a large amount of info about machines, software installed, and machine configuration.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
UDP를 통해 데이터를 보내기 전에 연결을 설정해야 하나요?,Do you need to establish a connection before sending data via UDP?,"아니요, 연결이 없습니다.","No, it's connectionless.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
UDP 패킷의 체크섬에 대해 알려주세요.,Tell me about the checksum in a UDP packet.,16비트 체크섬입니다. IPv6에서만 필수입니다,It's a 16-bit checksum. It's only mandatory on IPv6,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
UDP에서 패킷이 몇 번이나 전송되나요?,How many times are packets sent in UDP?,한번만.,Once.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
UDP의 특별한 점은 무엇인가요?,What is special about UDP?,연결이 없고 패킷은 한 번만 전송되며 떨어뜨려도 다시 전송되지 않습니다. 패킷이 올바른 순서로 도착하지 않을 수 있으며 수신 측에서 수정할 수 있는 순서 메커니즘이 없습니다. 혼잡 제어 기능이 없습니다.,"It's connectionless, packets are only sent once and not re-sent if dropped. Packets may not arrive in the right order, and there is no ordering mechanism to fix on the receiving end. No congestion control.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
TCP의 특별한 점은 무엇인가요?,What's special about TCP?,"데이터가 전송되기 전에 3방향 핸드셰이크를 수행합니다.
배송은 수신자가 확인합니다.
특정 시간 내에 누락된 패킷은 재요청됩니다.
수령 시 패킷이 순서대로 배치됩니다.
혼잡 제어: 네트워크가 혼잡하지 않을 때까지 배송을 지연시킬 수 있습니다.
IPv4 및 IPv6: 오류 감지, 체크섬 필수.","It does a 3-way handshake before data is sent.
Delivery is acknowledged by receiver.
Packets missing within a certain time window are re-requested.
Packets are put in order on receipt.
Congestion control: can delay delivery until network is uncongested.
IPv4 and IPv6: error detection, checksum mandatory.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OSI는 무엇을 의미하나요?,What does OSI stand for?,오픈 시스템 인터커넥트,Open Systems Interconnect,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OSI는 왜 만들어졌나요?,Why was OSI created?,여러 이기종 네트워크의 상호 운용성 문제를 해결하기 위해.,To solve the interoperability problem of having multiple heterogeneous networks.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OSI는 단지 모델인가요?,Is OSI just a model?,네.,Yes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
네트워킹 전쟁에서 승리한 네트워크 프로토콜은 무엇인가요?,What network protocol won the networking wars?,OSI 모델을 기반으로 한 TCP/IP.,"TCP/IP, based on the OSI model.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OSI 모델의 응용 수준에서는 어떤 일이 일어나나요?,What happens at the Application level of the OSI model?,이곳은 애플리케이션이 거주하며 다양한 형태로 데이터를 처리하는 곳입니다.,This is where applications live and they handle data in many forms.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OSI 모델의 세션 계층에서는 어떤 일이 일어나나요?,What happens in the Session layer of the OSI model?,"이 계층은 데이터의 구성을 처리합니다:
- 암호화
- 압축
- 다양한 문자 인코딩으로의 번역","This layer handles configuration of the data:
- encryption
- compression
- translation to and from different character encodings",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OSI 모델의 세션 계층에서는 어떤 일이 일어나나요?,What happens at the Session layer of the OSI model?,"이 계층은 다음을 통해 통신의 액세스를 제어합니다:
- 로그인 권한
- 권한
- 권리
- 역할","This layer controls the communication's access via:
- login rights
- permissions
- rights
- roles",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OSI 모델의 전송 계층에서는 어떤 일이 일어나나요?,What happens at the Transport layer of the OSI model?,"이 계층은 데이터의 종단 간 전달을 보장합니다:
- 패킷 순서 지정
- 오류 감지
- 감사의 표시","This layer guarantees end-to-end delivery of data:
- packet ordering
- error detection
- acknowledgements",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OSI 모델의 네트워크 계층에서는 어떤 일이 일어나나요?,What happens at the Network layer of the OSI model?,"이 계층의 기능은 네트워크를 통해 목적지 네트워크로 가는 최단 경로를 찾는 것입니다.
혼잡, 대역폭 등을 처리합니다.","This layer's function is to find the shortest path through the network to the destination network.
Deals with congestion, bandwidth, etc.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OSI 모델의 데이터 링크 계층에서는 어떤 일이 일어나나요?,What happens at the Data Link layer of the OSI model?,"그것은 버스 중재 방법을 사용하여 네트워크에서 누구의 차례인지 결정합니다.
네트워크에서 물리적 장치를 찾습니다.","It decides whose turn it is to talk on the network using bus arbitration methods.
It finds the physical device on the network.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OSI 모델의 물리 계층에서는 어떤 일이 일어나나요?,What happens at the Physical layer of the OSI model?,"전선을 통한 전기의 물리적 전송을 다루는 물리적 네트워크입니다:
- 케이블
- 전압
- 주파수
- 커넥터
- 비트
- 전송 속도
- 그리고 훨씬 더 많이","It's the physical network that deals with the physical transmission of electricity through wire:
- cables
- voltages
- frequencies
- connectors
- bits
- transfer rates
- and much more",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
HTTP/2는 대역폭을 어떻게 절약하나요?,How does HTTP/2 save bandwidth?,"헤더는 압축되어 있으며 변경되지 않은 경우 세션에서 동일한 헤더를 보낼 필요가 없습니다.
서버는 문서에 참조된 자산을 개별 요청을 기다리지 않고 전송할 수 있습니다.","Headers are compressed and do not need to send the same headers in a session if they haven't changed.
Servers can send assets referenced in a document without waiting for discrete requests for them.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
HTTP/2는 캐시 중단을 어떻게 개선하나요?,How does HTTP/2 improve cache breaking?,서버는 파일이 변경되었음을 인식할 때 서버 푸시를 사용하여 업데이트된 자산을 전송할 수 있습니다.,A server can send updated assets using server push when it recognizes a file has changed.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
HTTP/2의 스트림 병렬 처리란 무엇인가요?,What is the stream parallelism in HTTP/2?,완전히 다중화되어 있어 연결 시 100-1000개의 스트림을 사용할 수 있습니다.,"It's fully multiplexed, so it can use 100-1000 streams in a connection.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"HTTP/2는 이진인가요, 아니면 텍스트인가요?",Is HTTP/2 binary or textual?,HTTP/2는 이진 프로토콜입니다.,HTTP/2 is a binary protocol.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
HTTP/2에서는 헤더와 본문이 어떻게 다르게 취급되나요?,How are headers and body treated differently in HTTP/2?,헤더 프레임과 데이터 프레임으로 나뉩니다. 여러 요청을 연결에 인터리빙할 수 있으므로 요청이 차단되지 않습니다.,"They are split into a header frame and a data frame. Multiple requests can be interleaved in a connection, so a request doesn't block.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
HTTP/2에서 우선순위는 무엇인가요?,What is priority in HTTP/2?,자산마다 우선순위가 다를 수 있으므로 접힘 내용 아래에 나중에 도착할 수 있습니다.,Different assets can have different priority so that below the fold content can arrive later.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
클래스 A 네트워크에서 첫 번째 옥텟의 범위는 무엇인가요?,What is the range of the first octet on a Class A network?,1-126. 우리는 0이나 127을 사용하지 않습니다.,1-126. We don't use 0 or 127.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
클래스 A 네트워크에는 몇 개의 네트워크 ID가 있나요?,How many network IDs are there on a Class A network?,"2^7 = 128
첫 번째 비트는 0이고, 비트 1-7은 네트워크 ID입니다","2^7 = 128
First bit is 0, bits 1-7 are network IDs",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
클래스 A 네트워크에서 지원되는 호스트 ID는 몇 개인가요?,How many host IDs are supported on a Class A network?,"2^24 = 1,600만
네트워크 ID에는 8비트가 있고, 나머지 24비트는 호스트 ID용입니다.
그래서 네트워크당 1,600만 개가 있습니다.","2^24 = 16 million
There are 8 bits for the network ID, and the remaining 24 bits are for host IDs.
So there are 16 million per network.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
클래스 B 네트워크에서 첫 번째 옥텟의 범위는 무엇인가요?,What is the range of the first octet on a Class B network?,128 - 191,128 - 191,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
클래스 B 네트워크에서 지원되는 네트워크 ID는 몇 개인가요?,How many network IDs are supported on a Class B network?,"2^14 = 16,384
처음 2비트는 10, 비트 3-16은 네트워크 ID입니다","2^14 = 16,384
First 2 bits are 10, bits 3-16 are network IDs",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
클래스 B 네트워크에서 지원되는 호스트 ID는 몇 개인가요?,How many host IDs are supported on a Class B network?,"2^16 = 65,536
따라서 네트워크당 65,536개가 있습니다","2^16 = 65,536
So there are 65,536 per network",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
클래스 C 네트워크에서 첫 번째 옥텟의 범위는 무엇인가요?,What is the range of the first octet on a Class C network?,192-223,192-223,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
클래스 C 네트워크에서 지원되는 네트워크 ID는 몇 개인가요?,How many network IDs are supported on a Class C network?,"2^21 = 200만
처음 3비트는 110, 비트 4-24는 네트워크 ID입니다","2^21 = 2 million
First 3 bits are 110, bits 4-24 are network IDs",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
클래스 C 네트워크에서 지원되는 호스트 ID는 몇 개인가요?,How many host IDs are supported on a Class C network?,"2^8 = 256
네트워크당 256개의 호스트가 있습니다","2^8 = 256
There are 256 hosts per network",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
클래스 D 네트워크는 무엇을 위해 예약되어 있나요?,What is a class D network reserved for?,멀티캐스팅,Multicasting,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
유니캐스트란 무엇인가요?,What is unicasting?,한 호스트에서 다른 호스트로 패킷을 전송합니다.,Sending a packet from one host to another.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
네트워크 ID는 무엇으로 끝나나요?,What does a network ID end in?,0,0,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
방송 ID는 무엇으로 끝나나요?,What does a broadcast ID end in?,255,255,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
방송 주소 255.255.255는 누구에게 보내나요?,Who does a broadcast address of 255.255.255.255 send to?,네트워크 내의 모든 호스트.,All hosts within the network.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
연출 방송이란 무엇인가요?,What is a directed broadcast?,다른 네트워크 내의 모든 호스트에게 방송하는 것입니다.,It's a broadcast to all hosts within another network.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
제한된 방송 주소란 무엇인가요?,What is a limited broadcast address?,제한 방송 주소는 IP 주소의 32비트를 모두 1(255.255.255.255)로 설정하여 형성된 주소입니다. 제한 방송 주소는 IP 노드가 로컬 네트워크에서 일대일 전송을 수행해야 하지만 네트워크 ID를 알 수 없는 경우에 사용됩니다.,The limited broadcast address is the address formed by setting all 32 bits of the IP address to 1 (255.255.255.255). The limited broadcast address is used when an IP node must perform a one-to-everyone delivery on the local network but the network ID is unknown.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
네트워크를 가능한 한 작게 만들어야 하는 이유는 무엇인가요?,Why should you make networks as small as possible?,"다음을 위해:
- 보안
- 유지 보수
- 관리","For:
- security
- maintenance
- management",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
네트워크를 어떻게 나누나요?,How you divide a network?,서브넷으로.,By subnetting.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
/27 CIDR은 무엇을 의미하나요?,What does a /27 CIDR mean?,처음 27비트는 1로 마스킹됩니다. 나머지 5비트는 서브넷에서 도달할 수 있습니다.,The first 27 bits are masked with 1s. The remaining 5 bits are reachable in the subnet.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
/24 CIDR은 무엇을 의미하나요?,What does a /24 CIDR mean?,IP 주소의 처음 24비트는 마스킹됩니다. 마스킹되지 않은 부분에 주소가 있는 호스트만 도달할 수 있습니다.,The first 24 bits of the IP address are masked. Only hosts with addresses in the unmasked portion are reachable.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
블록 암호란 무엇인가요?,What is a block cipher?,"블록 암호는 암호화된 텍스트를 암호화하는 방법으로, 암호화된 키와 알고리즘을 한 번에 하나의 비트가 아닌 그룹으로 데이터 블록(예: 64개의 연속 비트)에 적용하여 암호화하는 것입니다.","A block cipher is a method of encrypting text (to produce ciphertext) in which a cryptographic key and algorithm are applied to a block of data (for example, 64 contiguous bits) at once as a group rather than to one bit at a time.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
QUIC이란 무엇인가요?,What is QUIC?,QUIC는 TCP에 비해 지연 시간을 줄여주는 새로운 전송 방식입니다. 표면적으로 QUIC는 UDP에 구현된 TCP+TLS+HTTP/2와 매우 유사합니다.,"QUIC is a new transport which reduces latency compared to that of TCP. On the surface, QUIC is very similar to TCP+TLS+HTTP/2 implemented on UDP.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
캡시쿰이란 무엇인가요?,What is Capsicum?,유닉스 계열 커널에 기능 기반 보안을 추가하고 글로벌 네임스페이스에 대한 액세스를 거부하는 샌드박스 프레임워크입니다.,A sandboxing framework that adds capability-based security to unix-like kernels and denies access to global namespaces.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
유닉스 용어로 글로벌 네임스페이스란 무엇인가요?,What is a global namespace in unixy terms?,"어디서든 접근할 수 있는 시스템의 측면:
- 파일 경로
- 네트워크
- PID","aspects of a system that can be accessed from anywhere:
- file paths
- networks
- PIDs",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Google 네이티브 클라이언트란 무엇인가요?,What is Google Native Client?,NaCl이라고도 하는 네이티브 클라이언트는 사용자의 운영 체제와 독립적으로 브라우저에서 컴파일된 C 및 C++ 코드를 효율적이고 안전하게 실행하기 위한 샌드박스입니다.,"Also called NaCl, Native Client is a sandbox for running compiled C and C++ code in the browser efficiently and securely, independent of the user’s operating system.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
웹 socket이란 무엇인가요?,What are web sockets?,클라이언트와 서버 간의 전이중 통신.,Full-duplex communication between client and server.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동일 기원 정책이란 무엇인가요?,What is the same-origin policy?,"목표: 두 웹사이트는 서로 조작할 수 없어야 합니다.
전략: 각 리소스에는 출처가 할당됩니다. JS는 자체 출처에서만 리소스에 액세스할 수 있습니다.
출처: 스키마 + 호스트 이름 + 포트","Goal: Two websites should not be able to tamper with each other.
Strategy: each resource is assigned an origin. JS can only access resources from its own origin.
Origin: scheme + hostname + port",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2개의 원점(예: 2프레임)은 어떻게 통신할 수 있나요?,How can 2 origins (let's say 2 frames) communicate?,window.postMessage (HTML5)는 도메인 간에 두 개의 창/프레임 간에 데이터 메시지를 전송할 수 있게 해줍니다.,window.postMessage (HTML5) allows for sending data messages between two windows/frames across domains.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
JIT 컴파일이란 무엇인가요?,What is JIT compilation?,"JIT 컴파일은 동적 번역이라고도 하며, 사전에 실행되는 것이 아니라 런타임에 수행되는 컴파일입니다(AOT).","JIT compilation, also known as dynamic translation, is compilation done at run-time rather than ahead of time (AOT).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
PyPy란 무엇인가요?,What is PyPy?,"PyPy는 CPython을 대체하는 언어입니다. Python과 함께 개발된 RPython 언어를 사용하여 구축되었습니다. RPython은 Python의 하위 집합이며 C로 번역할 수 있습니다. CPython 대신 사용하는 주된 이유는 속도입니다: JIT 컴파일로 인해 일반적으로 더 빠르게 실행되기 때문입니다.
PyPy는 Python 2.7.10을 구현합니다. PyPy는 모든 핵심 언어를 지원하며, Python 테스트 스위트를 통과합니다 (새로운 버전의 메인 Python에서 이미 받아들여진 약간의 수정 사항도 포함되어 있습니다). 이는 일반적으로 사용되는 대부분의 Python 표준 라이브러리 모듈을 지원합니다.","PyPy is a replacement for CPython. It is built using the RPython language that was co-developed with it. RPython is a subset of Python and can be translated to C. The main reason to use it instead of CPython is speed: it runs generally faster due to JIT compilation.
PyPy implements Python 2.7.10. It supports all of the core language, passing the Python test suite (with minor modifications that were already accepted in the main python in newer versions). It supports most of the commonly used Python standard library modules.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SMT는 무엇을 의미하나요?,What does SMT stand for?,만족도 모듈로 이론.,Satisfiability modulo theories.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SMT 솔버란 무엇인가요?,What is an SMT solver?,만족 모듈로 이론 솔버는 대규모 상호 연결 논리 공식을 해결하여 주어진 공식을 만족시킬 수 있는지 여부를 결정합니다. 이는 심볼릭 실행을 사용하여 프로그램의 결과나 입력을 결정하는 데 도움이 됩니다.,A satisfiability modulo theories solver solves for large interconnected logic formulas to determine if a given formula can be satisfied. These are helpful for determining the outcome or inputs for a program using symbolic execution.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로그램이 예측된 결과를 초래할 수 있는 조건이 존재한다는 것을 어떻게 알 수 있을까요?,How do we find that a condition exists that will cause a program to have a predicted outcome?,SAT 솔버(논리 테스트 사용)와 SMT 솔버(숫자를 연결하는)를 사용하여 SAT 솔버가 어디서 잘못되었는지 알려줍니다. SAT 솔버는 조건을 찾을 때까지 주기적으로 서로 피드백을 제공합니다.,"Using an SAT solver (using logic tests) and an SMT solver (that plugs in numbers), and tells the SAT solver where it got it wrong. They provide feedback in a cycle to each other until a condition can be found.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
트랜잭션 메모리란 무엇인가요?,What is  transactional memory?,트랜잭션 메모리는 로드 및 저장 명령어 그룹이 원자적 방식으로 실행될 수 있도록 하여 동시 프로그래밍을 단순화하려고 시도합니다. 이는 동시 컴퓨팅에서 공유 메모리에 대한 액세스를 제어하기 위한 데이터베이스 트랜잭션과 유사한 동시성 제어 메커니즘입니다.,Transactional memory attempts to simplify concurrent programming by allowing a group of load and store instructions to execute in an atomic way. It is a concurrency control mechanism analogous to database transactions for controlling access to shared memory in concurrent computing.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
소프트웨어 트랜잭션 메모리란 무엇인가요?,What is software transactional memory?,"소프트웨어 트랜잭셔널 메모리는 소프트웨어 런타임 라이브러리나 프로그래밍 언어에서 트랜잭셔널 메모리 의미를 제공하며, 최소한의 하드웨어 지원(일반적으로 원자 비교 및 스왑 작업 또는 이에 상응하는 작업)이 필요합니다. 단점으로, 소프트웨어 구현은 하드웨어 솔루션과 비교할 때 성능 저하가 발생하는 경우가 많습니다.","Software transactional memory provides transactional memory semantics in a software runtime library or the programming language, and requires minimal hardware support (typically an atomic compare and swap operation, or equivalent). As the downside, software implementations usually come with a performance penalty, when compared to hardware solutions.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
PyPY에 GIL이 있나요?,Does PyPY have a GIL?,예. GIL은 제거하기가 매우 어렵습니다. 대신 소프트웨어 트랜잭션 메모리를 사용하는 pypy-stm을 사용할 수 있지만 성능 저하가 발생합니다.,"Yes. The GIL is very difficult to remove. You can use pypy-stm instead, which uses software transactional memory, but will suffer a performance penalty.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
서버가 SYN 홍수 공격에 어떻게 대처할 수 있나요?,How can a server deal with a SYN flood attack?,"한 번에 많은 수의 SYN 패킷을 감지하거나 SN(시퀀스 번호) 데이터 구조의 크기가 특정 항목 임계값에 도달하면 상태 비저장 버전으로 전환하여 타임스탬프가 있는 서명된 값으로 SN 응답을 전송하고, 하나를 받으면 조회 테이블 없이 SN 응답을 통과시킬 수 있습니다.","When it detects a large number of SYN packets at once, or the size of its SN (sequence number) data structure reaches a certain threshold of entries, it can switch to a stateless version, where it send SN responses as signed values with a timestamp, and if it receives one back it lets them through without needing a lookup table.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스택 카나리아란 무엇인가요?,What is a stack canary?,저장된 EBP 후 무작위 값을 스택에 밀어넣고 스택 프레임을 분해하기 전에 값을 확인하는 버퍼 오버플로 방어입니다. 반환 명령 포인터를 대상으로 하는 버퍼 흐름은 이 값을 덮어쓰야 합니다.,"It's a buffer overflow defense where a random value is pushed onto the stack after the saved EBP, and before tearing down the stack frame, the value is checked. Any buffer flow targeting the return instruction pointer would have to have overwritten this value.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
gcc와 Visual Studio는 어떤 유형의 버퍼 오버플로 방지 기능을 사용하나요?,What type of buffer overflow protection does gcc and Visual Studio employ?,버퍼에 할당된 메모리 전후의 바이트 스택 검사 가드를 사용합니다. 값이 버퍼에 기록되면 바이트가 여전히 동일한지 확인합니다.,"They use a stack check guard of bytes before and after the buffer's allocated memory. Once values are written to the buffer, the bytes are checked to ensure they are still the same.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
확장성이란 무엇인가요?,What is scalability?,확장성은 시스템이 성능에 부정적인 영향을 미치지 않으면서 리소스 수요 변화에 적응할 수 있는 척도입니다.,"Scalability is the measure to which a system can adapt to a change in demand for resources, without negatively impacting performance.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
아카란 무엇인가요?,What is Akka?,"더 간단하고 단일한 프로그래밍 모델을 제공하는 오픈 소스 프로젝트 - 동시 및 분산 애플리케이션을 위한 코딩 방법 중 하나인 액터 프로그래밍 모델.
Akka의 주요 목표는 클라우드에 배포되거나 코어가 많은 디바이스에서 실행되는 애플리케이션을 더 쉽게 구축하고 사용 가능한 컴퓨팅 성능의 전체 용량을 효율적으로 활용하는 것입니다. 이 툴킷은 확장 가능한 애플리케이션을 구축하기 위한 액터 모델, 런타임 및 필수 지원 도구를 제공합니다.","An open source project that provides a simpler, single programming model - one way of coding for concurrent and distributed applications - the actor programming model.
Akka’s primary goal is to make it simpler to build applications that are deployed in the cloud or run on devices with many cores and that efficiently leverage the full capacity of the computing power available. It’s a toolkit that provides an actor model, runtime, and required supporting tools for building scalable applications.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
배우란 무엇인가요?,What is an actor?,"간단히 말해서, 배우들은 설정과 메시지 브로커 설치 오버헤드가 없는 메시지 큐와 매우 비슷합니다. 마치 프로그래밍 가능한 메시지 큐를 축소하여 마이크로사이즈로 만드는 것과 같습니다. 수천 개, 심지어 수백만 개를 쉽게 만들 수 있습니다. 그들은 ""하지"" 않습니다
메시지를 보내지 않는 한 무엇이든.
메시지는 생성된 후에는 변경할 수 없거나 한 마디로 변경할 수 없는 단순한 데이터 구조입니다.
배우는 메시지를 한 번에 하나씩 받고 메시지를 받을 때마다 일부 동작을 실행할 수 있습니다. 대기열과 달리 다른 배우에게 메시지를 보낼 수도 있습니다.
배우가 하는 모든 작업은 비동기식으로 실행됩니다. 간단히 말해, 응답을 기다리지 않고 배우에게 메시지를 보낼 수 있습니다. 배우는 스레드와 같지는 않지만, 배우에게 보낸 메시지는 특정 시점에 스레드를 통해 전달됩니다. 배우가 스레드에 연결되는 방식은 구성할 수 있으며, 이는 유선 연결된 관계가 아닙니다.
현재 배우의 가장 중요한 측면은 메시지를 주고받으며 애플리케이션을 구축하는 것입니다. 메시지는 사용 가능한 스레드에서 로컬로 처리되거나 다른 서버에서 원격으로 처리될 수 있습니다. 메시지가 정확히 처리되는 위치와 배우의 거주 위치는 나중에 결정할 수 있는 사항으로, 하드코딩 스레드나 RPC 스타일 네트워킹과 비교하면 매우 다릅니다. 배우는 네트워크 서비스와 유사한 작은 부분으로 애플리케이션을 쉽게 구축할 수 있으며, 발자국과 관리 오버헤드를 미세화하기 위해 축소할 수 있습니다.","Briefly, actors are a lot like message queues without the configuration and message broker installation overhead. They’re like programmable message queues shrunk to microsize—you can easily create thousands, even millions of them. They don’t “do”
anything unless they’re sent a message.
Messages are simple data structures that can’t be changed after they’ve been created, or in a single word, they’re immutable.
Actors can receive messages one at a time and execute some behavior whenever a message is received. Unlike queues, they can also send messages (to other actors).
Everything an actor does is executed asynchronously. Simply put, you can send a message to an actor without waiting for a response. Actors aren’t like threads, but messages sent to them are pushed through on a thread at some point in time. How actors are connected to threads is configurable - this is not a hardwired relationship.
For now the most important aspect of actors is that you build applications by sending and receiving messages. A message could be processed locally on some available thread, or remotely on another server. Exactly where the message is processed and where the actor lives are things you can decide later, which is very different compared to hardcoding threads and RPC style networking. Actors make it easy to build your application out of small parts that resemble networked services, only shrunk to microsize in footprint and administrative overhead.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
IDL 기반 인코딩이란 무엇인가요?,What is an IDL-based encoding?,"인터페이스 설명 언어 또는 인터페이스 정의 언어(IDL) 인코딩. 
스키마 정의가 필요합니다. 스키마의 진화에 유연성을 희생하면서 소비자에게 데이터 형식과 검증에 대한 안심을 제공합니다.","An interface description language or interface definition language (IDL) encoding. 
It requires a schema definitions. They offer peace of mind with respect to data format and validation for consumers while sacrificing flexibility in the schema’s evolution.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
타란툴이란 무엇인가요?,What is Tarantool?,충돌 저항성과 지속성을 위해 쓰기 전 로깅을 사용하는 in-memory noSQL 데이터베이스입니다.,An in-memory noSQL database that uses write-ahead logging for crash resistance and persistence.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
코루틴이란 무엇인가요?,What is a coroutine?,"결국 완료되는 활동을 나타내는 객체입니다. 또한 코루틴을 반환하는 함수라고도 합니다.
파이썬에서 코루틴은 생성기입니다.","An object representing activity that eventually completes. Also refers the the function we call that returns a coroutine.
In Python, coroutines are generators.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
미래란 무엇인가요?,What is a future?,아직 사용할 수 없는 결과를 나타내는 객체.,An object representing a result that may not be available yet.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
What is AQP?,What is AQP?,대략적인 쿼리 처리. 정확한 결과를 처리하는 데 시간이 걸리는 대신 데이터 샘플을 가져오는 것을 의미합니다. 데이터 저장소에 테라바이트 이상이 포함된 경우 자주 사용됩니다.,Approximate query processing. It means pulling a sample of data instead of taking time to process an exact result. It is often used when a data storage involves terabytes or more.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프에서 수십억 개의 항목을 어떻게 시각화하시겠습니까?,How would you visualize billions of items in a graph?,많은 경우 모든 점을 그래프로 그릴 필요는 없으며 시각화 인식 샘플링만 사용하면 됩니다. 1% 이하면 충분합니다.,"In many cases, you don't need to graph every point, just use visualization-aware sampling. Sometime 1% or less will do.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
F1/스패너란 무엇인가요?,What is F1/Spanner?,구글의 광고 비즈니스(F1)를 지원하는 내결함성 분산 RDBMS(스패너),Fault-Tolerant Distributed RDBMS (Spanner) Supporting Google's Ad Business (F1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
광자란 무엇인가요?,What is Photon?,연속 데이터 스트림의 내결함성과 확장 가능한 결합,Fault-tolerant and Scalable Joining of Continuous Data Streams,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메사란 무엇인가요?,What is Mesa?,"지리적으로 복제된 거의 실시간, 확장 가능한 데이터 웨어하우스","Geo-Replicated, Near Real-Time, Scalable Data Warehousing",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Google은 멀티홈 데이터 센터를 어떻게 사용하나요?,How does Google use multi-homed datacenters?,"멀티홈 시스템은 항상 여러 데이터 센터에서 실시간으로 실행됩니다. 각 데이터 센터 프로세스는 항상 작동하며, 작업은 데이터 센터 간에 동적으로 공유되어 부하 균형을 맞춥니다. 한 데이터 센터의 속도가 느리면 작업의 일부가 자동으로 더 빠른 데이터 센터로 이동합니다. 데이터 센터를 완전히 사용할 수 없는 경우 모든 작업이 자동으로 다른 데이터 센터로 분산됩니다.","A multi-homed system runs live in multiple datacenters all the time. Each datacenter processes work all the time, and work is dynamically shared between datacenters to balance load. When one datacenter is slow, some fraction of work automatically moves to faster datacenters. When a datacenter is completely unavailable, all its work is automatically distributed to other datacenters.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
ElasticSearch란 무엇인가요?,What is ElasticSearch?,"오픈 소스, 분산, RESTful 검색 엔진","Open Source, Distributed, RESTful Search Engine",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
회로 차단기의 예는 무엇인가요?,What is an example of a circuit breaker?,시스템을 악화시키는 여러 번의 동시 재시도를 피하기 위해 서비스가 중단된 경우 503을 전송하기 시작하세요.,Start sending 503s if your service is choked to avoid numerous simultaneous retries that just make the system worse.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
구글 검색 순위 알고리즘의 이름은 무엇인가요?,What is the name of Google's search ranking algorithm?,벌새. 페이지랭크는 알고리즘이 사용하는 한 가지 요소일 뿐입니다.,Hummingbird. PageRank is just one factor used by the algorithm.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Celery란 무엇인가요?,What is celery?,분산 작업 대기열,Distributed Task Queue,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
LRU는 어떤 종류의 정책에서 가장 인기가 있나요?,LRU is the most popular type of what kind of policy?,퇴거,Eviction,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
퇴거 정책은 무엇을 예측하려고 하나요?,What does an eviction policy try to predict?,퇴거 정책은 가까운 미래에 다시 사용될 가능성이 가장 높은 항목을 예측하여 적중률을 극대화하려고 합니다,"An eviction policy tries to predict which entries are most likely to be used again in the near future, thereby maximizing the hit ratio",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
카페이엔이란 무엇인가요?,What is Caffiene?,"카페인은 Java 8을 기반으로 한 고성능, 거의 최적의 캐싱 라이브러리입니다.","Caffeine is a high performance, near optimal caching library based on Java 8.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
요청 통합이란 무엇인가요?,What is request coalescing?,"캐시에 누락된 콘텐츠(캐시 미스)에 대한 요청이 많이 도착하면, 홍수를 피하기 위해 백엔드로 콘텐츠를 가져오기 위해 하나의 인스턴스 요청만 진행됩니다.","When many requests arrive for some content that’s missing in the cache (cache miss), only one instance request will proceed to the backend to fetch the content on behalf of all to avoid a flood.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
NoSQL 데이터베이스를 사용해야 하는 시기,When might you need to use a NoSQL database,"관계 데이터가 없습니다.
5TB 이상의 데이터를 저장해야 하거나 데이터 집약적인 작업량이 있는 경우.
귀하의 애플리케이션은 대기 시간이 매우 짧습니다.
정말 높은 처리량이 필요합니다.","You don’t have any relational data.
If you need to store > 5 TB of data or you have an incredibly data intensive workload.
Your application has super low-latency requirements.
You need really high throughput.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
AMP란 무엇인가요?,What is AMP?,"AMP는 모바일 기기에서 웹을 빠르게 만들기 위해 설계된 HTML의 제한된 하위 집합입니다.
스크립트를 매번 다운로드할 필요 없이 공유 라이브러리를 제공합니다.
광고가 페이지에 영향을 미치지 않도록 광고 아키텍처의 기준을 설정합니다.
분석을 위한 데이터 수집 메커니즘을 공유하여 페이지에 N개의 다른 패키지가 포함되지 않도록 합니다.","AMP is a restricted subset of HTML designed to make the web fast on mobile devices.
Provides a shared library of scripts so they don’t have to downloaded every time.
Sets standards for the architecture of advertising so advertising doesn't infect pages.
Shared mechanism for collecting data for analytics so you don’t have N different packages on a page gathering stats.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로세스를 비동기화하면 어떤 이점이 있나요?,What is a benefit of making processes asynchronous?,아키텍처의 유연성. 사용자가 동기화된 저지연 상호작용에 매료되는 것은 아키텍처의 유연성을 보장하지 않습니다.,Flexibility in the architecture. Getting users on hooked on synchronous low-latency interactions doesn't allow for architecture flexibility.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
BASE란 무엇인가요?,What is BASE?,"기본적으로 사용 가능
소프트 상태
결국 일관된

BASE 기반 시스템은 본질적으로 분할되고 느슨하게 결합된 아키텍처이며 궁극적인 일관성을 사용하기 때문에 지연 시간에 더 관대합니다.","basically available
soft state
eventually consistent

A BASE based system is more tolerant to latency because it is an inherently partitioned and loosely coupled architecture and it uses eventual consistency.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
산이란 무엇인가요?,What is ACID?,"원자성
일관성.
고립
내구성","atomicity
consistency
isolation
durability",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CAP 정리란 무엇인가요?,What is the CAP theorem?,"CAP 정리, 브루어 정리라고도 불리는 이 정리는 분산 컴퓨터 시스템이 다음 세 가지 보장을 동시에 제공하는 것이 불가능하다고 명시하고 있습니다:

- 일관성(모든 노드가 동일한 데이터를 동시에 봅니다)
- 가용성(모든 요청은 성공 여부에 대한 응답을 받습니다)
- 파티션 허용 오차(네트워크 장애로 인한 임의의 파티션에도 불구하고 시스템은 계속 작동합니다)","The CAP theorem, also named Brewer's theorem, states that it is impossible for a distributed computer system to simultaneously provide all three of the following guarantees:

- Consistency (all nodes see the same data at the same time)
- Availability (every request receives a response about whether it succeeded or failed)
- Partition tolerance (the system continues to operate despite arbitrary partitioning due to network failures)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
제로 카피란 무엇인가요?,What is zero copy?,제로 복사를 사용하는 애플리케이션은 커null이 애플리케이션을 거치지 않고 디스크 파일에서 socket으로 직접 데이터를 복사할 것을 요청합니다. 제로 복사는 애플리케이션 성능을 크게 향상시키고 커null과 사용자 모드 간의 컨텍스트 전환 횟수를 줄여줍니다.,"Applications that use zero copy request that the kernel copy the data directly from the disk file to the socket, without going through the application. Zero copy greatly improves application performance and reduces the number of context switches between kernel and user mode.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메타클래스란 무엇인가요?,What is a metaclass?,Any callable (function or class) that implements type()'s function signature.,Any callable (function or class) that implements type()'s function signature.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
특권 분리란 무엇인가요?,What is privilege separation?,애플리케이션을 다른 영역으로 분리하여 한 영역의 취약점이 전체 애플리케이션에 영향을 미치지 않도록 하는 것입니다.,Separating an application into different areas so a vulnerability in one area doesn't affect the entire application.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
보안 분야에서 주체란 무엇인가요?,"In security, what is a principal?",특권이나 권리를 가진 단체.,An entity with privileges or rights.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
유닉스에서 파일의 소유자는 누구인가요?,"In Unix, who is the owner of a file?",inode의 UID와 일치하는 사용자 ID를 가진 사용자.,The user with the user ID that matches the UID of the inode.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
경로에서 파일이나 디렉터리를 조회하려면 어떤 권한이 필요하나요?,What privilege do you need to lookup files or directories in a path?,실행 가능한 권한.,The executable permission.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파일에 대한 보안은 언제 시행되나요?,When is security enforced on a file?,파일 설명자가 생성되면 보안이 확인됩니다. 그런 다음 파일 설명자를 주의하고 보호하는 것은 사용자의 몫입니다.,Security is checked when the file descriptor is created. Then it's up to the user to be careful and secure the file descriptor.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
ptrace란 무엇인가요?,What is ptrace?,"ptrace는 여러 유닉스 및 유닉스 계열 운영 체제에서 사용되는 시스템 호출입니다. ptrace를 사용하면 한 프로세스가 다른 프로세스를 제어할 수 있으며, 이를 통해 컨트롤러가 대상의 내부 상태를 검사하고 조작할 수 있습니다.","ptrace is a system call found in several Unix and Unix-like operating systems. By using ptrace, one process can control another, enabling the controller to inspect and manipulate the internal state of its target.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로세스를 디버깅하는 데 무엇을 사용할 수 있나요?,What can you use to debug a process?,흔적,ptrace,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
포트 < 1024에 바인딩하려면 어떤 사용자 권한이 필요하나요?,What user privilege is required to bind to ports < 1024?,뿌리,root,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
시스템 부트스트래핑 중 루트가 아닌 사용자에게 프로세스의 소유권을 부여하기 위해 시스템이 수행하는 호출은 무엇인가요?,"During system bootstrapping, what call is performed by the system to give a non-root user the ownership of a process?",setuid(),setuid(),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
setuid 바이너리란 무엇인가요?,What are the setuid binaries?,"수
수도","su
sudo",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
chroot은 무엇을 하나요?,What does chroot do?,사용자가 탈출할 수 없는 파일 시스템의 디렉토리가 되도록 루트 디렉토리(/)를 변경합니다.,Changes the root directory (/) for a user to be a directory on the filesystem where they can't escape.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
혼란스러운 대리인이란 무엇인가요?,What is a confused deputy?,"혼란스러운 대리인은 다른 당사자가 순진하게 속아 권한을 남용하는 컴퓨터 프로그램입니다. 이는 특정 유형의 권한 확대입니다. 정보 보안에서 혼란스러운 대리인 문제는 종종 기능 기반 보안이 중요한 이유를 보여주는 예로 언급되는데, 이는 기능 시스템이 이를 보호하는 반면 접근 제어 목록 기반 시스템은 그렇지 않기 때문입니다.
고전적인 예는 각 사용에 대한 청구 기록을 생성하는 포트란 컴파일러입니다. 사용자는 컴파일러에게 청구 파일과 동일한 이름의 바이너리를 출력하도록 지시하고 이를 덮어쓸 수 있었습니다.","A confused deputy is a computer program that is innocently fooled by some other party into misusing its authority. It is a specific type of privilege escalation. In information security, the confused deputy problem is often cited as an example of why capability-based security is important, as capability systems protect against this whereas access control list-based systems do not.
The classic example is a Fortran compiler that creates a billing record for each use. A user was able to tell the compiler to output a binary with the same name as the billing file, overwriting it.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
웹 프론트엔드 세계에서 혼란스러운 대리인의 예는 무엇인가요?,What is an example of a confused deputy in the web frontend world?,CSRF 공격.,A CSRF attack.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
주변 권한 또는 주변 특권이란 무엇인가요?,"What is ambient authority, or ambient privilege?","프로세스나 에이전트가 행동을 수행할 수 있는지 여부에 대한 결정은 명시적으로 명시되지 않은 정보를 기반으로 하며, 대신 상속됩니다.","The decision about whether a process or agent can perform an action is based on information not explicitly stated, but inherited instead.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
기능이란 무엇인가요?,What is a capability?,소유권이 주어졌을 때 어떤 것에 대해 행동할 수 있는 권한과 중간 프로세스의 권한을 사용하여 어떤 것에 대해 행동할 수 없는 권한을 말합니다. 예를 들어 파일 설명자를 인수로 전달하고 해당 기능이 자신의 기능이 아닌 자신의 기능을 사용하는 함수를 들 수 있습니다.,"The privilege to act upon something given your ownership of it, and the inability to act on something using an intermediate process' privileges. An example would be a function where you pass a file descriptor as an argument and the function uses your capability, not its own.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
샌드박스를 활성화하기 위한 요건은 무엇인가요?,What is a requirement of enabling sandboxing?,"커널은 전역 네임스페이스를 참조하는 시스템 호출을 허용하지 않음으로써 커null을 지원할 수 있어야 합니다:
- 루트에서 시작하는 파일 경로 - 상대적이어야 합니다
- 네트워크
- PID - 대신 프로세스 설명자 사용","The kernel must be able to support it by disallowing system calls that reference global namespaces:
- file paths starting at root - must be relative
- network
- PIDs - use process descriptors instead",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
RSA 복호화는 속도에 어떻게 최적화되나요?,How is RSA decryption optimized for speed?,"- c^d mod p와 c^d mod q는 병렬로 처리되며, 마지막에 중국 잔여 정리를 사용하여 병합됩니다
- 몽고메리 형식으로 번역하다
- 윈도우를 슬라이딩하여 지수 비트로 지수화합니다
- 아마도 한 번의 추가 감소
- 몽고메리 형식에서 다시 변환
- CRT를 사용하여 병합","- c^d mod p and c^d mod q are processed in parallel and merged at the end using the Chinese remainder theorem
- put into Montgomery format
- sliding windows to exponentiate on bits of exponent
- perhaps a single extra reduction
- convert back from Montgomery format
- merge using CRT",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
양의 정수를 음수로 어떻게 변경하나요?,How do you change a positive integer to negative?,1을 빼고 모든 비트를 뒤집습니다,"Subtract 1, flip all bits",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
음수를 양수로 어떻게 변경하나요?,How do you change a negative integer to positive?,모든 비트를 뒤집은 다음 1을 추가합니다,"Flip all bits, then add 1",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인텔 아키텍처란 무엇인가요?,What is Intel architecture?,"CISC - 복잡한 명령어 집합 컴퓨터
많은 특수 목적 지침.","CISC - Complex Instruction Set Computer
Many special-purpose instructions.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인텔 지침은 어떤 크기인가요?,What size are Intel instructions?,그것들은 1바이트에서 이론적으로 16바이트까지의 가변 길이입니다.,"They are variable-length, from 1 to theoretically 16 bytes.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
RISC란 무엇인가요?,What is RISC?,"축소된 명령어 집합 아키텍처. 
- 더 많은 레지스터
- 더 적은 수의 고정 크기 지침
- PowerPC, ARM, SPARC, MIPS에 사용됨","Reduced Instruction Set Architecture. 
- more registers
- fewer, fixed-sized instructions
- used in PowerPC, ARM, SPARC, MIPS",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인텔의 엔디안니스란 무엇인가요?,What Endianness is Intel?,리틀 엔디안이지만 기억 속에서만 가능합니다. 레지스터에는 모두 빅 엔디안입니다.,"Little Endian, but only in memory. In registers, all are Big Endian.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
리틀 엔디안니스란 무엇인가요?,What is Little Endianness?,단어 이상의 최하위 바이트는 가장 낮은 주소에 저장됩니다. 모든 바이트는 동일합니다. 바이트 내에는 엔디안니스가 없습니다.,The least significant bytes of a word or larger are stored in the lowest address. All bytes are the same. There is no Endianness within a byte.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CISC에는 몇 개의 레지스터가 있나요?,How many registers are on CISC?,8개의 범용 레지스터와 명령 포인터. 8개 중 2개는 그렇게 일반적이지 않습니다.,8 general-purpose registers and an instruction pointer. 2 of 8 are not that general.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인텔의 단어 크기는 무엇인가요?,What is the word size on Intel?,16비트,16 bits,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인텔의 더블 워드 크기는 무엇인가요?,What is the double-word size on Intel?,32비트,32 bits,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
빅 엔디안니스란 무엇인가요?,What is Big Endianness?,단어 이상의 가장 중요한 바이트는 가장 낮은 주소에 저장됩니다.,The most significant bytes of a word or larger are stored in the lowest address.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
EAX 레지스터는 무엇에 사용되나요?,What is the EAX register used for?,함수의 반환 값을 저장합니다.,Stores the function's return value.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
EBX 레지스터는 무엇에 사용되나요?,What is the EBX register used for?,데이터 섹션으로 가는 기본 포인터.,Base pointer to the data section.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
ECX 레지스터는 무엇에 사용되나요?,What is the ECX register used for?,문자열 및 루프 연산을 위한 카운터.,Counter for string and loop operations.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
EDX 레지스터는 무엇에 사용되나요?,What is the EDX register used for?,입출력 포인터,I/O pointer,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
ESI 레지스터는 무엇에 사용되나요?,What is the ESI register used for?,문자열 또는 기타 복사 작업을 위한 소스 포인터.,Source pointer for string or other copy operations.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
EDI 레지스터는 무엇에 사용되나요?,What is the EDI register used for?,문자열 또는 기타 복사 작업을 위한 대상 포인터.,Destination pointer for string or other copy operations.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
ESP 레지스터는 무엇에 사용되나요?,What is the ESP register used for?,스택 포인터,Stack pointer,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
EBP 레지스터는 무엇에 사용되나요?,What is the EBP register used for?,스택 프레임 베이스 포인터,Stack frame base pointer,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
EIP 레지스터는 무엇에 사용되나요?,What is the EIP register used for?,명령 포인터 - 다음으로 실행할 명령 포인터.,Instruction pointer - next instruction pointer to execute.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
호출자 저장 레지스터는 무엇인가요?,What are the caller-save registers?,"이완
edx
ECX","eax
edx
ecx",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
호출기 저장 레지스터는 무엇인가요?,What are the callee-save registers?,"ebp
ebx
에시
에디","ebp
ebx
esi
edi",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
주요 레지스터 외에 어떤 다른 레지스터를 사용할 수 있나요?,"Other than the main registers, what other registers can be used?","레거시 8비트 및 16비트 레지스터: AX, AH, AL, SP, BP, SI","Legacy 8 and 16-bit registers: AX, AH, AL, SP, BP, SI",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
리눅스 시스템에서 발신자 등록 저장 규칙은 무엇인가요?,What is the caller register-saving convention on Linux systems?,cdecl - C 선언,cdecl - C declaration,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
눈사태란 무엇인가요?,What is avalancing?,입력의 작은 변화가 출력에 큰 영향을 미치는 해싱 방법의 효과.,The effect of a hashing method where a small change in the input has a large effect on the output.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
셰프란 무엇인가요?,What is Chef?,구성 도구. 서버가 원하는 상태를 선언하는 레시피를 작성하거나 재사용합니다. 이 도구는 델타를 계산하고 사용자를 위해 빌드를 제공합니다.,A configuration tool. You write or reuse recipes that declare the state you wish your server to be in. It calculates the delta and builds out for you.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비암호화 해시 함수의 예는 무엇인가요?,What is an example of a non-cryptographic hash function?,"MurmurHash is an efficient, non-cryptographic hash function suitable for general hash-based lookup. The name comes from two basic operations, multiply (MU) and rotate (R), used in its inner loop. It has an avalanche effect. The current version is MurmurHash3 which yields a 32-bit or 128-bit hash value.","MurmurHash is an efficient, non-cryptographic hash function suitable for general hash-based lookup. The name comes from two basic operations, multiply (MU) and rotate (R), used in its inner loop. It has an avalanche effect. The current version is MurmurHash3 which yields a 32-bit or 128-bit hash value.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
배열의 요소에 대한 계산을 병렬로 처리하려면 어떻게 해야 하나요?,How could you process calculations on elements of an array in parallel?,재귀를 사용하여 분할하고 정복한 다음 배열을 더 작은 세그먼트로 분해한 다음 재귀가 풀릴 때 값을 병합합니다. 배열의 돌연변이가 없다는 것은 잠금이 필요하지 않다는 것을 의미합니다.,"Using recursion, divide and conquer, breaking down the array into smaller segments, then merging the values as the recursion unwinds. Non-mutation of the array means locking is not required.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
대규모 데이터 구조의 여러 부분에서 병렬 계산을 할 때 염두에 두어야 할 요소는 무엇인가요?,What factor should you keep in mind when doing parallel computation on different parts of a large data structure?,RAM의 메모리 대역폭. 병목 현상이 발생할 수 있습니다.,The memory bandwidth of your RAM. It can become a bottleneck.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
여러 작업을 처리할 때 계산 시간은 어떻게 되나요?,What will be the computation time when processing multiple tasks?,가장 긴 서브 계산 시간.,The length of time the longest subcomputation takes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
같은 선상이나 근접 지점에서 작업이나 스레드를 시작하거나 참여하는 것을 피해야 하는 이유는 무엇인가요?,Why should you avoid starting and joining a task or thread on the same line or proximity?,현재 스레드에서 실행이 완료될 때까지 차단되어 동시 호출을 피할 수 있습니다.,"Execution on the current thread will block until it completes, thereby obviating the concurrent call.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
성과에 영향을 미치는 요인은 무엇인가요?,What factors affect performance?,"- 프로세서 속도 
- 프로세서 수
- 메모리 액세스 지연 시간 및 처리량
- 캐시 동작
- 런타임 동작(쓰레기 수집, JIT 컴파일, 스레드 스케줄링)","- processor speed 
- number of processors
- memory access latency and throughput
- cache behavior
- runtime behavior (garbage collection, JIT compilation, thread scheduling)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
암달의 법칙이란 무엇인가요?,What is Amdahl's Law?,자원이 개선된 시스템에서 기대할 수 있는 고정 작업 부하에서 작업 실행 지연 시간을 이론적으로 단축합니다.,It gives the theoretical speedup in latency of the execution of a task at fixed workload that can be expected of a system whose resources are improved.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
성능을 측정하고 벤치마킹하는 데 있어 병렬적이든 다른 방식이든 중요한 측면은 무엇인가요?,"What aspects are important in measuring and benchmarking performance, parallel or otherwise?","- 여러 번 반복
- 통계적 처리 - 평균 및 분산
- 통계적 이상치 제거
- 정상 상태 보장(워밍업)
- 이상 현상 방지(쓰레기 수집, JIT 컴파일, 벤치마크 코드에서 실제 세계를 잘못 표현하는 컴파일러 최적화)","- multiple repetitions
- statistical treatment - mean and variance
- eliminate statistical outliers
- ensuring steady-state (warm-up)
- preventing anomalies (garbage collection, JIT compilation, compiler optimizations in benchmark code that misrepresents real-world)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"연상 연산이 사용될 때, 그것은 무엇을 의미하나요?","When associative operations are used, what does it mean?",그룹화는 중요하지 않습니다. 동일한 결과로 평가될 것입니다.,Grouping doesn't matter. It will evaluate to the same result.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
reduce()의 동의어는 무엇인가요?,What is a synonym of reduce()?,fold(),fold(),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
교환 속성이란 무엇인가요?,What is the commutative property?,연산자로 연결된 양의 그룹이 관련된 양의 순서에 관계없이 동일한 결과를 제공한다는 조건입니다. 따라서 피연산자의 순서는 중요하지 않지만 그룹화는 중요할 수 있습니다.,"The condition that a group of quantities connected by operators gives the same result whatever the order of the quantities involved. So order of operands doesn't matter, but grouping may matter.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가방이란 무엇인가요?,What is a bag?,멀티셋.,A multiset.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
멀티셋이란 무엇인가요?,What is a multiset?,요소들이 반드시 고유할 필요는 없는 집합.,A set in which elements do not have to be unique.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
연상 연산과 가환 연산의 예로는 어떤 것들이 있나요?,What are some examples of operations that are both associative and commutative?,"- 정수의 덧셈 및 곱셈
- 집합의 합집합, 교집합, 대칭 차이
- 벡터의 덧셈
- 고정 차원 행렬의 추가
- 다항식의 덧셈 및 곱셈","- Addition and multiplication of integers
- Union, intersection, and  symmetric difference of sets
- Addition of vectors
- Addition of matrices of fixed dimension
- Addition and multiplication of polynomials",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
연상적이지만 가환적이지 않은 연산의 예는 무엇인가요?,What are some examples of operations that are associative but not commutative?,"- 목록 연결
- 문자열 연결
- 행렬 곱셈","- concatenation of lists
- concatenation of strings
- matrix multiplication",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
부동 소수점 덧셈과 곱셈에 대해 무엇을 걱정해야 할까요?,What should we worry about floating point addition and multiplication?,그것은 교환적이지만 연상적이지 않습니다.,It is commutative but not associative.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최적화하거나 병렬화하기 전의 경험 법칙은 무엇인가요?,What is the rule of thumb before optimizing or parallelizing?,먼저 코드가 올바르게 작동하는지 확인하세요. 그런 다음 더 빠른 속도를 위해 코드를 최적화할 수 있습니다.,"Ensure the code works correctly first. Then, if you want to get fancy, you can begin to optimize your code for greater speed.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에 옵코드 캐시가 있나요?,Does Python have an opcode cache?,어떤 면에서는 바이트코드가 포함된 .pyc 파일을 출력합니다. 모듈을 처음 가져오거나 소스가 현재 컴파일된 파일보다 최근에 가져온 경우 일반적으로 컴파일된 코드가 포함된 .pyc 파일이 .py 파일과 동일한 디렉토리에 생성됩니다. 다음에 프로그램을 실행할 때 Python은 이 파일을 사용하여 컴파일 단계를 건너뛸 수 있습니다.,"In a way. It outputs a .pyc file, containing the bytecode. When a module is imported for the first time, or when the source is more recent than the current compiled file, a .pyc file containing the compiled code will usually be created in the same directory as the .py file. When you run the program next time, Python uses this file to skip the compilation step.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
URL 단축 서비스를 설계하세요.,Design a URL shortening service.,물어보세요:,ask:,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
LinkedIn에서 사용자와 다른 사람 사이에 몇 개의 홉이 있는지 계산하는 기능을 어떻게 설계하시겠습니까?,How would you design the feature in LinkedIn where it computes how many hops there are between you and another person?,물어보세요:,ask:,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
온라인 체스 게임을 위한 웹 플랫폼을 디자인한다면 어떻게 하시겠습니까?,"If you were to design a web platform for online chess games, how would you do that?","물어보세요:
-","ask:
-",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
대규모 시스템을 확장할 때 기억해야 할 주요 사항은 무엇인가요?,What are some key things to remember when scaling a large system?,"1) 비동기식은 좋습니다 (큐, 토픽/펍 서브 사용)
2) 병렬 처리가 좋습니다(멀티스레딩, 로드 밸런싱 등)
3) 동기화와 같은 논쟁의 여지를 피하세요
4) 디스크에 쓰기 전까지는 쓰기를 피하세요 - 미친 듯이 캐시하세요
5) 스케일아웃, 업이 아닌 스케일아웃
6) 웹 규모에서는 빛의 속도가 문제입니다
7) 웹 규모에서는 네트워크, 로드 밸런서 등 모든 것이 실패합니다.","1) Asynchronous is good  (use queues, topics/pub-sub)
2) Parallel is good  (multi-threading, load balancing etc.)
3) Avoid points of contention e.g. synchronization
4) Avoid writing to disk until you must - cache like crazy
5) Scale out not up
6) At web scale the speed of light is a problem
7) At web scale everything fails - networks, load balancers etc.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
중고품이란 무엇인가요?,What is Thrift?,"Apache Srift는 확장 가능한 언어 간 서비스 개발을 위한 프레임워크입니다. 소프트웨어 스택과 코드 생성 엔진을 결합하여 서로 다른 언어 간에 효율적이고 원활하게 작동하는 서비스를 구축합니다. 직렬화를 처리하고 자체 통신 프로토콜을 갖추고 있습니다.
IDL 기반.","Apache Thrift is a framework for scalable cross-language services development. It combines a software stack with a code generation engine to build services that work efficiently and seamlessly between different languages. It handles serialization and has its own communication protocol.
IDL-based.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
멤카체란 무엇인가요?,What is Memcache?,in-memory 분산 해시 테이블. 몇 가지 명령어만 지원하지만 매우 효율적입니다.,An in-memory distributed hash table. It supports only a few commands but it is extremely efficient.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2009년에 Facebook은 memcache와 mySQL을 어떻게 사용했나요?,How does/did Facebook use memcache and mySQL in 2009?,"프로덕션에 참여하지 않습니다. 사람, 이벤트, 장소 정보 등 모든 유형의 논리적 데이터베이스가 많이 있습니다. 웹 계층을 CPU, 멤캐시를 시스템 메모리, 데이터베이스를 디스크로 취급합니다. 모든 것에는 ID가 있으며, 이 ID를 사용하여 멀티젯을 사용하여 멤캐시를 쿼리합니다. 누락된 항목은 데이터베이스에서 가져와 멤캐시에 캐시됩니다.","No joins in production. They have many logical databases for all of their types: people, events, place info, etc. They treat the web tier as a CPU, memcache as system memory, and the database as disk. Everything has an ID and you use the ID to query memcache using a multiget. Any misses are fetched from the database and cached in memcache.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
대역 외 캐시란 무엇인가요?,What is an out-of-band cache?,영구 저장소와 동기화되지 않는 캐시 계층입니다. 데이터베이스에 변경 사항이 적용되면 캐시와 동기화하라는 알림이 표시되지 않습니다. 캐시 항목은 다른 방법으로 업데이트하거나 삭제해야 합니다.,"A cache layer that does not synch with persistent storage. When changes are made to the database, there are no notifications to synchronize with the cache. The cache entry would need to be updated or evicted by other means.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
모나드란 무엇인가요?,What is a monad?,"함수형 프로그래밍에서 모나드는 예측 가능하고 견고한 방식으로 간단한 구성 요소를 결합하여 컴퓨터 프로그램을 구축하는 방법입니다. 모나드는 일련의 단계로 정의된 계산을 나타내는 구조입니다. 모나드 구조를 가진 유형은 연산을 함께 연쇄하는 것이 무엇을 의미하는지 또는 해당 유형의 함수를 중첩하는 것을 정의합니다. 이를 통해 프로그래머는 데이터를 일련의 단계(즉, 데이터에 적용되는 일련의 작업)로 처리하는 파이프라인을 구축할 수 있으며, 각 작업은 모나드에서 제공하는 추가 처리 규칙으로 장식됩니다. 모나드는 값을 생성하는 반환 연산자와 파이프라인의 작업을 연결하는 데 사용되는 바인딩 연산자로 정의됩니다.","In functional programming, monads are a way to build computer programs by joining simple components in predictable and robust ways. A monad is a structure that represents computations defined as sequences of steps: a type with a monad structure defines what it means to chain operations together, or nest functions of that type. This allows the programmer to build pipelines that process data in a series of steps (i.e. a series of actions applied to the data), in which each action is decorated with additional processing rules provided by the monad. A monad is defined by a return operator that creates values, and a bind operator used to link the actions in the pipeline.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
피라미드피피란 무엇인가요?,What is pyramidpypi?,자체 호스팅된 파이피 거울.,A self-hosted mirror of pypi.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Big O메가는 무엇을 의미하나요?,Big Omega represents what?,함수의 성장에 대한 하한선. f는 적어도 g만큼 빠르게 성장합니다.,A lower bound on the growth of a function. f grows at least as fast as g.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
세타는 무엇을 의미하나요?,Theta represents what?,"함수에 대한 엄격한 asymptotic 경계, 즉 f와 g가 거의 동일한 성장률을 가질 경우.","A tight asymptotic bound on a function, in other words if both f and g have approximately the same rate of growth.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프 문제의 경우 복잡도 세타(N + M)는 무엇으로 알려져 있나요?,"For graph problems, the complexity  Theta(N + M) is known as what?",그래프 크기에 선형적인,linear in the graph size,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"""적어도 O(n^2)""를 더 잘 표현하는 방법은 무엇인가요?","What is a better way of saying ""at least O(n^2)""?",큰 오메가(n^2),big Omega(n^2),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
데이터 정규화란 무엇인가요?,What is data normalization?,"정규화는 데이터 중복성과 삽입, 업데이트 및 삭제 이상 현상과 같은 바람직하지 않은 특성을 제거하기 위해 테이블을 분해하는 체계적인 접근 방식입니다.

정규화는 주로 두 가지 목적으로 사용됩니다,
- 중복(useless) 데이터 제거
- 데이터 종속성이 합리적인지 확인하기","Normalization is a systematic approach of decomposing tables to eliminate data redundancy and undesirable characteristics like insertion, update and deletion anomalies.

Normalization is used for mainly two purpose,
- eliminating redundant (useless) data
- ensuring data dependencies make sense",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
퍼스트 노멀 양식의 요구 사항은 무엇인가요?,What are the requirements for first normal form?,"- 각 셀에는 단일 값이 있습니다
- 열의 모든 항목은 동일한 유형이어야 합니다
- 행은 고유 ID 또는 복합 키로 고유하게 식별됩니다","- each cell has a single value
- all items in a column must be of the same type
- rows are uniquely identified by a unique ID or a composite key",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
두 번째 정상 양식의 요구 사항은 무엇인가요?,What are the requirements for second normal form?,모든 속성(키가 아닌 열)은 키에 따라 달라집니다,All attributes (non-key columns) are dependent on the key,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
세 번째 정상 양식의 요구 사항은 무엇인가요?,What are the requirements for third normal form?,모든 필드는 테이블의 키로만 확인할 수 있으며 다른 열은 확인할 수 없습니다.,All fields can only be determined by the key in the table and no other column.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
네 번째 정규 형식의 요구 사항은 무엇인가요?,What are the requirements for fourth normal form?,다중 값 종속성이 없으므로 두 개 이상의 항목이 연관되어 있다고 해서 테이블에서 레코드를 중복해서는 안 됩니다. 이렇게 하면 한 필드를 제외하고 중복되는 레코드가 생성됩니다.,"No multi-valued dependencies, meaning records should not be duplicated in a table just because more than one item is associated. This creates records that are duplicates except for one field.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Hadoop의 사용 사례에는 어떤 것들이 있나요?,What are some use cases of Hadoop?,"- 여러 이벤트에 대한 사용자 행동 보고
- 1000억 개의 행에 대한 로그 처리","- reporting on user behavior over many events
- log processing of 100s of billions of rows",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
확장을 위해 염두에 두어야 할 몇 가지 확실한 원칙은 무엇인가요?,What are some solid principles to keep in mind for scaling?,"- 아주 간단하게 유지하세요
- 바퀴를 다시 발명하지 마세요
- 지루하고 검증되었으며 잘 지원되는 기술을 사용할 수 있습니다
- 향후 12~18개월 동안 필요한 것을 위해 구축하세요
- 다양한 것들을 똑같이 보이게 하세요
- 데이터베이스 보호를 위한 캐시
- 충분해, 충분해","- Keep it very simple
- Don’t re-invent the wheel
- Go with boring, proven and well-supported technologies when you can
- Build for what you will need over the next 12-18 months
- Make different things look the same
- Cache to protect the database
- Good enough is good enough",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
구니콘이란 무엇인가요?,What is gunicorn?,파이썬 WSGI HTTP 서버,A Python WSGI HTTP Server,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
WSGI란 무엇인가요?,What is WSGI?,"WSGI는 웹 서버 게이트웨이 인터페이스입니다. 이 인터페이스는 웹 서버가 웹 애플리케이션과 통신하는 방법과 웹 애플리케이션을 연결하여 하나의 요청을 처리하는 방법을 설명하는 사양입니다. 이 사양은 PEP 3333에 설명되어 있습니다.

WSGI 서버(WSGI 준수를 의미)는 클라이언트로부터 요청을 받은 후 애플리케이션에 전달한 후 애플리케이션이 반환한 응답을 클라이언트에 전송합니다.","WSGI is the Web Server Gateway Interface. It is a specification that describes how a web server communicates with web applications, and how web applications can be chained together to process one request. It was outlined in PEP 3333.

A WSGI server (meaning WSGI compliant) only receives the request from the client, pass it to the application and then send the response returned by the application to the client.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
패브릭이란 무엇인가요?,What is Fabric?,Fabric은 애플리케이션 배포 또는 시스템 관리 작업에서 SSH 사용을 간소화하기 위한 Python(2.5-2.7) 라이브러리이자 명령줄 도구입니다.,Fabric is a Python (2.5-2.7) library and command-line tool for streamlining the use of SSH for application deployment or systems administration tasks.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Apache 솔러란 무엇인가요?,What is Apache Solr?,"Solr는 Apache Lucene을 기반으로 구축된 오픈 소스 엔터프라이즈 검색 플랫폼입니다.
Solr는 매우 안정적이고 확장 가능하며 내결함성이 뛰어나 분산 인덱싱, 복제 및 로드 밸런싱 쿼리, 자동화된 페일오버 및 복구, 중앙 집중식 구성 등을 제공합니다.","Solr is an open source enterprise search platform built on Apache Lucene.
Solr is highly reliable, scalable and fault tolerant, providing distributed indexing, replication and load-balanced querying, automated failover and recovery, centralized configuration and more.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
무닌이란 무엇인가요?,What is munin?,그래프 메트릭 및 알림.,Graph metrics and alerting.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
데이터 센터에 서비스를 추가하고 요청을 처리하기 위해 더 많은 캐시와 서비스를 핑해야 할 때 어떤 문제가 발생하는 경향이 있나요?,What tends to become an issue as you add services in a datacenter and have to ping more caches and services to fulfill a request?,내부 네트워크 트래픽 증가로 인해 라우터를 과부하할 수 있는 팬인.,"Fan-in, where you can overload routers due to increased internal network traffic.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Redis는 무엇에 사용할 수 있나요?,What can Redis be used for?,"- noSQL 키-값 저장소
- 캐시
- 대기열","- a noSQL key-value store
- caches
- queues",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"데이터베이스가 성장함에 따라 공유하는 것의 이점은 무엇이며, 크기를 결정하는 것은 무엇인가요?","What is a benefit of sharding a database as it grows, and what determines the size?","Keeping the index in cache ensures a user lookup doesn't have to hit the disk, lookups can be served from RAM. How much RAM you have will determine the index size which will hint at the underlying data size.","Keeping the index in cache ensures a user lookup doesn't have to hit the disk, lookups can be served from RAM. How much RAM you have will determine the index size which will hint at the underlying data size.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
대부분의 비즈니스가 확장됨에 따라 결국 산산조각이 나는 이유는 무엇인가요?,Why do most businesses end up sharding as they scale?,대규모 동시 쓰기를 지원합니다.,To support massive concurrent writes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메시지 브로커란 무엇인가요?,What is a message broker?,메시지 브로커는 메시지를 발신자의 공식 메시징 프로토콜에서 수신자의 공식 메시징 프로토콜로 변환하는 중개 프로그램 모듈입니다. 메시지 브로커는 소프트웨어 애플리케이션이 공식적으로 정의된 메시지를 교환하여 통신하는 통신 네트워크의 요소입니다. 메시지 브로커는 메시지 지향 미들웨어의 구성 요소입니다.,Message broker is an intermediary program module that translates a message from the formal messaging protocol of the sender to the formal messaging protocol of the receiver. Message brokers are elements in telecommunication networks where software applications communicate by exchanging formally-defined messages. Message brokers are a building block of Message oriented middleware.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메시지 브로커의 몇 가지 예는 무엇인가요?,What are some examples of message brokers?,"Apache ActiveMQ
Apache Kafka
Apache Qpid
Celery
Gearman
HornetQ (Red Hat)
IBM 통합 버스
JBoss 메시징(JBoss)
JORAM
Microsoft BizTalk 서버(Microsoft)
Microsoft Azure 서비스 버스(Microsoft)
NATS(MIT 오픈 소스 라이선스, Go로 작성)
메시지 대기열 열기
오라클 메시지 브로커(오라클 코퍼레이션)
QDB(Apache License 2.0, 타임스탬프를 통한 메시지 재생 지원)
RabbitMQ(모질라 공중 사용 허가서, 얼랑어로 작성됨)
SAP PI(SAP AG)
스프레드 툴킷
Tarantool, NoSQL 데이터베이스, 메시지 대기열을 위한 일련의 저장 절차 포함
WSO2 메시지 브로커
Enduro/X 트랜잭션 메시지 대기열(TMQ)","Apache ActiveMQ
Apache Kafka
Apache Qpid
Celery
Gearman
HornetQ (Red Hat)
IBM Integration Bus
JBoss Messaging (JBoss)
JORAM
Microsoft BizTalk Server (Microsoft)
Microsoft Azure Service Bus (Microsoft)
NATS (MIT Open Source License, written in Go)
Open Message Queue
Oracle Message Broker (Oracle Corporation)
QDB (Apache License 2.0, supports message replay by timestamp)
RabbitMQ (Mozilla Public License, written in Erlang)
SAP PI (SAP AG)
Spread Toolkit
Tarantool, a NoSQL database, with a set of stored procedures for message queues
WSO2 Message Broker
Enduro/X Transactional Message Queue (TMQ)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
에카체란 무엇인가요?,What is Ehcache?,Ehcache는 성능을 향상시키고 데이터베이스를 오프로드하며 확장성을 단순화하는 표준 기반 오픈 소스 캐시입니다. 가장 널리 사용되는 Java 기반 캐시입니다.,"Ehcache is an open source, standards-based cache that boosts performance, offloads your database, and simplifies scalability. It's the most widely-used Java-based cache.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
L1 캐시 참조의 타이밍?,Timing of a L1 cache reference?,0.5 nanoseconds (ns),0.5 nanoseconds (ns),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
지점의 예측 오류 시기는 언제인가요?,Timing of a branch misprediction?,5나노초(ns),5 nanoseconds (ns),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
L2 캐시 참조의 타이밍?,Timing of a L2 cache reference?,7나노초(ns),7 nanoseconds (ns),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
뮤텍스 잠금/잠금 해제 타이밍?,Timing of a mutex lock/unlock?,25나노초(ns),25 nanoseconds (ns),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
주 기억 참조의 타이밍?,Timing of a main memory reference?,100나노초(ns),100 nanoseconds (ns),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
1KB를 압축하는 타이밍?,Timing to compress 1KB?,"3,000나노초(3마이크로초)","3,000 nanoseconds (3 microseconds)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
1Gbps 네트워크를 통해 2K 바이트를 전송할 시간인가요?,Time to send 2K bytes over 1 Gbps network?,"10,000 나노초(0.01 밀리초)","10,000 nanoseconds (0.01 ms)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SSD에서 4KB를 무작위로 읽을 시간인가요?,Time to read 4KB randomly from an SSD?,"150,000 나노초(0.15 밀리초)","150,000 nanoseconds (0.15 ms)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메모리에서 1MB를 순차적으로 읽는 타이밍?,Timing to read 1MB sequentially from memory?,"250,000 나노초(0.25 밀리초)","250,000 nanoseconds (0.25 ms)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
디스크 탐색의 타이밍?,Timing of a disk seek?,"10,000,000 나노초(10ms)","10,000,000 nanoseconds (10 ms)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SSD에서 1MB를 순차적으로 읽을 시간인가요?,Time to read 1MB sequentially from an SSD?,"1,000,000 나노초(1ms)
4배 메모리","1,000,000 nanoseconds (1 ms)
4x memory",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
디스크에서 1MB를 순차적으로 읽는 타이밍?,Timing to read 1MB sequentially from disk?,"20,000,000 나노초(20ms)
80배 메모리
20배 SSD","20,000,000 nanoseconds (20 ms)
80x memory
20x SSD",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Timing to send a packet CA -> Netherlands -> CA?,Timing to send a packet CA -> Netherlands -> CA?,"150,000,000 나노초(150밀리초)","150,000,000 nanoseconds (150 ms)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로세스 간의 컨텍스트 전환 타이밍?,Timing of a context switch between processes?,3000나노초,3000 nanoseconds,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Timing of fork()?,Timing of fork()?,"약 70,000에서 160,000 나노초 사이입니다.","Between 70,000 and 160,000 nanoseconds.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
시스템 호출의 타이밍 오버헤드는 얼마인가요?,What is the timing overhead for a system call?,400나노초,400 nanoseconds,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Kafka란 무엇인가요?,What is Kafka?,"Apache Kafka는 분산 커밋 로그로 재구성된 펍-서브 메시징입니다.
Kafka는 분산, 분할, 복제된 커밋 로그 서비스입니다. 메시징 시스템의 기능을 제공하지만 독특한 디자인을 가지고 있습니다.
하나의 Kafka 브로커는 수천 명의 클라이언트로부터 초당 수백 메가바이트의 읽기와 쓰기를 처리할 수 있습니다.","Apache Kafka is pub-sub messaging rethought as a distributed commit log.
Kafka is a distributed, partitioned, replicated commit log service. It provides the functionality of a messaging system, but with a unique design.
A single Kafka broker can handle hundreds of megabytes of reads and writes per second from thousands of clients.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
GAE란 무엇인가요?,What is GAE?,"Google 앱 엔진은 확장 가능한 웹 애플리케이션과 모바일 백엔드를 구축하기 위한 플랫폼입니다. 앱 엔진은 대부분의 애플리케이션에 공통적으로 사용되는 NoSQL 데이터스토어, 멤캐시, 사용자 인증 API와 같은 내장 서비스와 API를 제공합니다.","Google App Engine is a platform for building scalable web applications and mobile backends. App Engine provides you with built-in services and APIs such as NoSQL datastores, memcache, and a user authentication API, common to most applications.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
GDS란 무엇인가요?,What is GDS?,"Google 클라우드 데이터스토어는 자동 확장, 고성능, 애플리케이션 개발의 용이성을 위해 구축된 NoSQL 문서 데이터베이스입니다. 클라우드 데이터스토어 기능에는 다음이 포함됩니다:

원자 거래.
고성능의 대규모 확장성.
유연한 데이터 저장 및 조회.
강력한 일관성과 궁극적인 일관성의 균형. 
암호화가 중단되었습니다.
계획된 다운타임 없이 완벽하게 관리됩니다.","Google Cloud Datastore is a NoSQL document database built for automatic scaling, high performance, and ease of application development. Cloud Datastore features include:

Atomic transactions.
Massive scalability with high performance.
Flexible storage and querying of data.
Balance of strong and eventual consistency. 
Encryption at rest.
Fully managed with no planned downtime.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
연재가 도입하는 문제는 무엇인가요?,What is the problem that serialization introduces?,"직렬화와 역직렬화의 오버헤드. 이 모든 것이 비싸고, 파이썬의 경우 매우 느릴 수 있습니다.","The overhead of serializing and deserializing. It's all expensive, and for Python, it can be terribly slow.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬 이등분 모듈은 무엇을 하나요?,What does the Python bisect module do?,"표준 라이브러리의 일부인 이등분 모듈은 각 삽입 후 목록을 정렬할 필요 없이 정렬된 순서대로 목록을 유지할 수 있도록 지원합니다. 비교 작업이 많은 항목의 긴 목록의 경우, 이는 더 일반적인 접근 방식보다 개선된 것일 수 있습니다.","The bisect module, part of the standard library, provides support for maintaining a list in sorted order without having to sort the list after each insertion. For long lists of items with expensive comparison operations, this can be an improvement over the more common approach.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
What is PycURL?,What is PycURL?,"PycURL은 libcurl에 대한 파이썬 인터페이스입니다. PycURL은 urllib 파이썬 모듈과 유사하게 파이썬 프로그램에서 URL로 식별된 객체를 가져오는 데 사용할 수 있습니다. PycURL은 성숙하고 매우 빠르며 많은 기능을 지원합니다.
PycURL은 고급 개발자를 대상으로 하며, 수십 개의 동시에 빠르고 안정적인 연결이 필요하거나 위에 나열된 정교한 기능이 필요한 경우 PycURL이 적합합니다.
PycURL의 주요 단점은 Libcurl에 비해 상대적으로 얇은 레이어로, 이러한 좋은 Python 클래스 계층 구조가 없다는 것입니다. 이는 Libcurl의 C API에 이미 익숙하지 않은 한 학습 곡선이 다소 가파르다는 것을 의미합니다.","PycURL is a Python interface to libcurl. PycURL can be used to fetch objects identified by a URL from a Python program, similar to the urllib Python module. PycURL is mature, very fast, and supports a lot of features.
PycURL is targeted at an advanced developer - if you need dozens of concurrent, fast and reliable connections or any of the sophisticated features listed above then PycURL is for you.
The main drawback of PycURL is that it is a relatively thin layer over libcurl without any of those nice Pythonic class hierarchies. This means it has a somewhat steep learning curve unless you are already familiar with libcurl's C API.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
PycURL은 요청과 어떻게 비교되나요?,How does PycURL compare to requests?,"PycURL은 여러 개의 동시 요청을 처리할 수 있습니다. 연결을 재사용할 때 초당 2,000개 이상의 요청을 수행할 수 있습니다.

파이컬은 연결을 재사용할 때 요청을 발행하는 데 약 73 CPU 마이크로초가 걸립니다
연결을 재사용할 때 요청을 발행하는 데 약 526 CPU 마이크로초가 걸립니다
pycurl은 새 연결을 열고 요청을 발행하는 데 약 165 CPU-마이크로초, 즉 연결 재사용이 없는 경우 약 92 마이크로초가 걸립니다
새 연결을 열고 요청을 발행하는 데 약 1078개의 CPU-마이크로초가 소요되며(연결 재사용이 없음), 또는 약 552개의 마이크로초가 소요됩니다","PycURL can handle a large number of multiple concurrent requests. When reusing connections, it can perform more than 2,000 requests per second.

pycurl takes about 73 CPU-microseconds to issue a request when reusing a connection
requests takes about 526 CPU-microseconds to issue a request when reusing a connection
pycurl takes about 165 CPU-microseconds to open a new connection and issue a request (no connection reuse), or ~92 microseconds to open
requests takes about 1078 CPU-microseconds to open a new connection and issue a request (no connection reuse), or ~552 microseconds to open",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
ZooKeeper란 무엇인가요?,What is ZooKeeper?,"Apache ZooKeeper는 구성 정보를 유지 관리하고, 이름을 지정하고, 분산 동기화를 제공하며, 그룹 서비스를 제공하기 위한 중앙 집중식 서비스입니다. 이러한 모든 종류의 서비스는 분산 애플리케이션에 의해 어떤 형태로든 사용됩니다. 각 서비스가 구현될 때마다 버그와 인종 조건을 수정하는 데 많은 노력이 필요합니다. 이러한 종류의 서비스를 구현하는 것이 어렵기 때문에 애플리케이션은 처음에 이러한 서비스를 생략하는 경우가 많으며, 이는 변경이 있을 때 취약하고 관리하기 어렵습니다. 올바르게 수행되더라도 이러한 서비스의 다양한 구현은 애플리케이션이 배포될 때 관리 복잡성을 초래합니다.
Java 및 C 인터페이스가 있습니다.","Apache ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them, which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management complexity when the applications are deployed.
Has Java and C interfaces.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
직교성이란 무엇인가요?,What is orthogonality?,"수학적 용어로, 그것은 수직이라는 것을 의미합니다.

프로그래밍 언어 설계에서 직교성은 다양한 언어 특징을 임의의 조합으로 일관된 결과로 사용할 수 있는 능력입니다.

직교성은 시스템의 구성 요소가 생성하는 기술적 효과를 수정하는 것이 시스템의 다른 구성 요소에 부작용을 일으키거나 전파하지 않도록 보장하는 시스템 설계 속성입니다. 일반적으로 이는 관심사와 캡슐화의 분리를 통해 이루어지며, 복잡한 시스템의 실현 가능하고 컴팩트한 설계에 필수적입니다. 구성 요소로 구성된 시스템의 출현 동작은 모듈과 인터페이스의 비직교 설계, 즉 통합 불량으로 인한 부작용이 아닌 논리의 형식적 정의에 의해 엄격하게 제어되어야 합니다. 직교성은 부작용을 유발하지도 않고 의존하지도 않는 설계를 검증하는 것이 더 쉽기 때문에 테스트 및 개발 시간을 단축시킵니다.","In mathematical terms, it means being perpendicular.

Orthogonality in programming language design is the ability to use various language features in arbitrary combinations with consistent results.

Orthogonality is a system design property which guarantees that modifying the technical effect produced by a component of a system neither creates nor propagates side effects to other components of the system. Typically this is achieved through the separation of concerns and encapsulation, and it is essential for feasible and compact designs of complex systems. The emergent behavior of a system consisting of components should be controlled strictly by formal definitions of its logic and not by side effects resulting from poor integration, i.e., non-orthogonal design of modules and interfaces. Orthogonality reduces testing and development time because it is easier to verify designs that neither cause side effects nor depend on them.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"스케일링을 다룰 때, 유튜브 동영상 조회수와 같이 급격히 증가하는 카운터를 어떻게 처리할 수 있을까요?","When dealing with scaling, how can you deal with rapidly increasing counters, like YouTube video views?",단조 카운터에 무작위성을 추가할 수 있습니다. 사람들이 다소 단조롭게 증가하는 것을 볼 수 있는 한 100% 정확할 필요는 없습니다. 또한 트랜잭션에 고정할 필요도 없습니다.,"You can add randomness to a monotonic counter, because as long as people can see it is increasing somewhat monotonically, it doesn't need to be 100% accurate. And avoids need to lock it in a transaction.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
지수 백오프란 무엇이며 언제 사용되나요?,What is exponential backoff and when is it used?,이진 지수 백오프 또는 절단 이진 지수 백오프는 혼잡 회피의 일환으로 네트워크 또는 기타 서비스 요청의 반복적인 재전송을 간격을 두는 데 사용되는 알고리즘을 말합니다.,"Binary exponential backoff or truncated binary exponential backoff refers to an algorithm used to space out repeated retransmissions of network or other service requests, often as part of congestion avoidance.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
리더보드를 효율적으로 관리하기 위해 어떤 데이터 구조를 사용할 수 있나요?,What data structure could be used to efficiently manage a leaderboard?,각 노드가 최악의 점수부터 최고 점수까지의 범위 중 일부를 관리하는 b-트리입니다.,A b-tree where each node manages a subset of the range of the worst to best scores.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
시스템 설계에 지터를 추가하는 것이 무엇을 피하는 데 도움이 되나요?,What does adding jitter in system design help you avoid?,시스템이 지터지지 않으면 천둥치는 무리가 생깁니다. 분산 애플리케이션은 실제로 기상 시스템입니다. 이를 디버깅하는 것은 날씨를 예측하는 것만큼이나 결정론적입니다. 지터는 놀랍게도 일이 쌓이는 경향이 있기 때문에 더 많은 무작위성을 유발합니다.,"If your system doesn’t jitter then you get thundering herds. Distributed applications are really weather systems. Debugging them is as deterministic as predicting the weather. Jitter introduces more randomness because surprisingly, things tend to stack up.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
캐싱 시스템에 지터를 추가하는 예는 무엇인가요?,What is an example of adding jitter to a caching system?,"캐시 만료. 인기 있는 비디오의 경우 가능한 한 최선을 다해 캐시합니다. 24시간 동안 캐시할 수 있는 가장 인기 있는 비디오입니다. 모든 것이 한 번에 만료되면 모든 기계가 동시에 만료를 계산합니다. 이렇게 하면 천둥치는 무리가 생깁니다.
18시간에서 30시간 사이에 무작위로 만료된다고 말하는 것입니다. 그러면 물건이 쌓이는 것을 방지할 수 있습니다. 이를 여기저기 사용합니다. 시스템은 작업이 줄을 서서 스스로를 파괴하려고 할 때 스스로 동기화되는 경향이 있습니다. 보기에 흥미롭습니다. 한 컴퓨터에 느린 디스크 시스템이 있고 모두가 요청을 기다리고 있기 때문에 갑자기 다른 모든 컴퓨터의 다른 요청이 완전히 동기화됩니다. 이는 많은 컴퓨터가 있고 이벤트가 많을 때 발생합니다. 각 시스템은 실제로 시스템에서 엔트로피를 제거하므로 다시 추가해야 합니다.","Cache expirations. For a popular video they cache things as best they can. The most popular video they might cache for 24 hours. If everything expires at one time then every machine will calculate the expiration at the same time. This creates a thundering herd.
By jittering you are saying randomly expire between 18-30 hours. That prevents things from stacking up. They use this all over the place. Systems have a tendency to self synchronize as operations line up and try to destroy themselves. Fascinating to watch. You get slow disk system on one machine and everybody is waiting on a request so all of a sudden all these other requests on all these other machines are completely synchronized. This happens when you have many machines and you have many events. Each one actually removes entropy from the system so you have to add some back in.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
cron 또는 기타 시스템 간격이 일치하지 않도록 어떤 값을 만들 수 있나요?,What value can you make cron or other system intervals so they don't coincide?,주기성을 위해 고유한 소수를 사용하세요.,Use distinct prime numbers for periodicities.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
함수 및 기타 호출 가능한 객체를 완전히 다시 작성하지 않고도 적응하거나 확장할 수 있는 도구를 제공하는 Python 패키지는 무엇인가요?,"What Python package provides tools for adapting or extending functions and other callable objects, without completely rewriting them?","기능 도구
제안:
장식가들
비교
풍부한 비교
대조 순서
캐싱
데이터 세트 줄이기
일반 함수","functools
offers:
Decorators
Comparison
Rich Comparison
Collation Order
Caching
Reducing a Data Set
Generic Functions",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프록시 서버란 무엇인가요?,What is a proxy server?,"프록시 서버는 클라이언트로부터 요청을 받아 백엔드 오리진 서버로 릴레이하는 중간 하드웨어/소프트웨어입니다. 일반적으로 프록시는 헤더 추가/제거, 암호화/복호화 또는 압축을 통해 요청을 필터링하거나 로그 요청을 변환하는 데 사용됩니다.","A proxy server is an intermediate piece of hardware/software that receives requests from clients and relays them to the backend origin servers. Typically, proxies are used to filter requests, log requests, or sometimes transform requests (by adding/removing headers, encrypting/decrypting, or compression).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
붕괴된 전달이란 무엇인가요?,What is collapsed forwarding?,"프록시 서버는 동일한(또는 유사한) 요청을 하나의 요청으로 통합한 다음, 요청하는 클라이언트에게 단일 결과를 반환할 수 있습니다.

프록시를 사용하는 또 다른 좋은 방법은 동일한 데이터에 대한 요청을 축소하는 것뿐만 아니라 원본 저장소에서 공간적으로 가까운 데이터에 대한 요청도 디스크에서 연속적으로 축소하는 것입니다.","A proxy server can collapse the same (or similar) requests together into one request, and then return the single result to the requesting clients.

Another great way to use the proxy is to not just collapse requests for the same data, but also to collapse requests for data that is spatially close together in the origin store (consecutively on disk).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
요청을 먼저 처리하려면 프록시 서버와 캐시 중 무엇을 해야 하나요?,"What should be handling requests first, a proxy server or a cache?",일반적으로 캐시는 프록시 앞에 두는 것이 가장 좋습니다. 캐시는 메모리에서 데이터를 처리하고 있으며 매우 빠르며 동일한 결과에 대한 여러 요청도 상관없기 때문입니다. 하지만 캐시가 프록시 서버의 반대편에 위치했다면 캐시 이전의 모든 요청에 추가 지연이 발생하여 성능이 저하될 수 있습니다.,"Generally it is best to put the cache in front of the proxy. This is because the cache is serving data from memory, it is very fast, and it doesn't mind multiple requests for the same result. But if the cache was located on the other side of the proxy server, then there would be additional latency with every request before the cache, and this could hinder performance.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인기 있는 프록시에는 어떤 것이 있나요?,What are some popular proxies?,"HAProxy
Squid
Varnish","HAProxy
Squid
Varnish",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인덱스가 쓰기 속도를 늦추는 경향이 있는 이유는 무엇인가요?,Why do indexes tend to slow down writes?,데이터를 작성하고 인덱스를 업데이트해야 하기 때문입니다.,Since you must both write the data and update the index.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
로드 밸런서의 역할은 무엇인가요?,What is the role of a load balancer?,역할은 요청을 처리하는 노드 집합에 부하를 분산시키는 것입니다. 이를 통해 여러 노드가 시스템에서 동일한 기능을 투명하게 처리할 수 있습니다. 이들의 주요 목적은 많은 동시 연결을 처리하고 해당 연결을 요청 노드 중 하나로 라우팅하여 노드를 추가하기만 하면 시스템이 더 많은 요청을 처리할 수 있도록 확장할 수 있도록 하는 것입니다.,"The role is to distribute load across a set of nodes responsible for servicing requests. This allows multiple nodes to transparently service the same function in a system. Their main purpose is to handle a lot of simultaneous connections and route those connections to one of the request nodes, allowing the system to scale to service more requests by just adding nodes.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
로드 밸런서의 고급 기능의 단점은 무엇인가요?,What is a drawback of advanced features in a load balancer?,"고급 기능은 문제 진단을 번거롭게 만들 수 있습니다. 예를 들어, 부하가 높은 상황에서는 로드 밸런서가 너무 많은 요청으로 인해 속도가 느리거나 타이밍이 맞지 않는 노드를 제거하지만, 이는 다른 노드의 상황을 악화시킬 뿐입니다.","Advanced features can make problem diagnosis cumbersome. For example, when it comes to high load situations, load balancers will remove nodes that may be slow or timing out (because of too many requests), but that only exacerbates the situation for the other nodes.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
시스템에 비동기성을 추가하면 어떤 이점이 있나요?,What is a benefit of adding asynchrony to a system?,"클라이언트가 단순히 지연될 수 있는 작업에 대한 응답을 기다릴 때 서버에 대한 연결을 유지하지 못하도록 합니다. 이렇게 하면 예를 들어 쓰기를 수행하는 서버의 부하를 줄이고, 필요할 때가 아닌 준비된 상태에서 작업을 수행할 수 있습니다.","It keeps clients from holding connections to servers when waiting for a response for a task that could simply be deferred. This reduces load on servers that are performing writes, for example, and lets them perform a task when ready, not on-demand.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동기식 시스템과 비동기식 시스템의 차이점은 무엇인가요?,What is the difference between a synchronous system and an asynchronous system?,"동기화 시스템에서는 요청과 응답을 구분할 수 없으므로 별도로 관리할 수 없습니다. 비동기화 시스템에서는 클라이언트가 작업을 요청하면 서비스가 작업이 수신되었음을 알리는 메시지로 응답하고, 클라이언트는 작업이 완료된 후에만 주기적으로 작업 상태를 확인할 수 있습니다.

클라이언트가 비동기 요청이 완료되기를 기다리는 동안, 다른 작업을 수행하는 것은 자유이며, 심지어 다른 서비스의 비동기 요청도 수행할 수 있습니다.","In a synchronous system, there is no differentiation between request and reply, and they therefore cannot be managed separately. In an asynchronous system the client requests a task, the service responds with a message acknowledging the task was received, and then the client can periodically check the status of the task, only requesting the result once it has completed.

While the client is waiting for an asynchronous request to be completed it is free to perform other work, even making asynchronous requests of other services.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
잘 알려진 대기열(또는 대기열 역할을 할 수 있는) 소프트웨어의 예는 무엇인가요?,What are some examples of well-known queue (or can act as a queue) software?,"BeanstalkD
RabbitMQ
ActiveMQ
BeanstalkD
Redis","BeanstalkD
RabbitMQ
ActiveMQ
BeanstalkD
Redis",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"비동기 코드는 CPU에 바인딩되는 경향이 있나요, 아니면 I/O에 바인딩되는 경향이 있나요?",Does asynchronous code tend to be CPU-bound or I/O bound?,"비동기 코드는 CPU 바인딩인 경향이 있습니다. 왜냐하면 차단 작업이 완료될 때까지 차단할 모든 것이 나중으로 연기되기 때문입니다. 즉, 비동기/비차단 애플리케이션의 스레드는 커널 스케줄러가 이를 선점하기 전에 풀타임 퀀텀을 사용할 가능성이 훨씬 더 높습니다.","Asynchronous code tends to be CPU bound, because anything that would block is simply deferred to later, until the blocking operation completes. This means that threads in asynchronous / non-blocking applications are much more likely to use their full time quantum before the kernel scheduler preempts them.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최적의 스레드 수는 얼마인가요?,What is the optimal number of threads?,"그리고 실행 가능한 스레드의 수가 하드웨어 스레드와 동일하다면, 커널은 동일한 코어에서 스레드를 다시 스케줄링할 가능성이 매우 높아 성능에 큰 도움이 됩니다.","And if there's the same number of runnable threads as there are hardware threads, the kernel is very likely to reschedule threads on the same core, which significantly helps performance.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
리눅스 박스에서 프로세스의 일반적인 타임슬라이스는 무엇인가요?,What is the typical time slice for a process on a Linux box?,"리눅스 커널은 종종 HZ=100으로 컴파일되며, 이는 프로세스에 10ms의 타임 슬라이스가 부여된다는 것을 의미합니다.","Linux kernels are often compiled with HZ=100, which entails that processes are given time slices of 10ms.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Linux는 CPU 친화성을 어떻게 처리하나요?,How does Linux handle CPU affinity?,기본 Linux 커널은 유휴 머신에서도 CPU 친화성을 잘 유지하지 못합니다. 대체 스케줄러를 탐색하거나 태스크셋 또는 CPU셋을 사용하여 직접 친화성을 제어해야 합니다.,"Default Linux kernels don't do a good job at keeping CPU affinity, even on idle machines. You must explore alternative schedulers or use taskset or cpuset to control affinity yourself.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
퓨텍스란 무엇인가요?,What is futex?,"futex(""빠른 사용자 공간 뮤텍스""의 줄임말)는 프로그래머가 기본 잠금을 구현하거나 세마포어 및 POSIX 뮤텍스와 같은 상위 수준의 잠금 추상화 또는 조건 변수를 위한 빌딩 블록으로 사용할 수 있는 리눅스 커널 시스템 호출입니다.","A futex (short for ""fast userspace mutex"") is a Linux kernel system call that programmers can use to implement basic locking, or as a building block for higher-level locking abstractions such as semaphores and POSIX mutexes or condition variables.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가상화 하에서 컨텍스트 스위치는 어떻게 작동하나요?,How do context switches perform under virtualization?,"평균적으로 가상화를 사용할 때 컨텍스트 전환을 수행하는 데 2.5배에서 3배 더 비쌉니다. 이는 게스트 OS가 페이지 테이블 자체를 업데이트할 수 없기 때문에 변경을 시도할 때 하이퍼바이저가 개입하여 추가로 두 개의 컨텍스트 전환(하나는 하이퍼바이저 내부로 들어가고, 다른 하나는 게스트 OS로 돌아갑니다)이 발생하기 때문입니다.","On average, it's 2.5x to 3x more expensive to do a context switch when using virtualization. My guess is that this is due to the fact that the guest OS can't update the page table itself, so when it attempts to change it, the hypervisor intervenes, which causes an extra 2 context switches (one to get inside the hypervisor, one to get out, back to the guest OS).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프레임 검사 시퀀스란 무엇인가요?,What is a Frame Check Sequence?,프레임 확인 시퀀스(FCS) 필드는 프레임의 송수신에서 오류가 발생했는지 여부를 확인하는 데 사용됩니다. 오류 감지는 미디어를 통해 데이터가 전송되기 때문에 데이터 링크 계층에서 추가됩니다.,The Frame Check Sequence (FCS) field is used to determine if errors occurred in the transmission and reception of the frame. Error detection is added at the Data Link layer because this is where data is transferred across the media.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Google은 검색 요청을 어떻게 처리하나요?,How does Google handle a search request?,"흩어짐/모여짐
이 모델에서 디스패처는 풀의 모든 작업자에게 요청을 멀티캐스트합니다. 각 작업자는 로컬 결과를 계산하여 디스패처로 전송하고, 디스패처는 이를 단일 응답으로 통합한 다음 클라이언트로 다시 전송합니다.","Scatter/gather
In this model, the dispatcher multicast the request to all workers of the pool. Each worker will compute a local result and send it back to the dispatcher, who will consolidate them into a single response and then send back to the client.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
대량 동기화 처리의 예는 무엇인가요?,What is an example of bulk synchronous processing?,"병렬 그래프 변환

그래프 변환의 주요 목표는 그래프를 수정하는 것입니다. 여기에는 기존 노드와 아크의 속성을 수정하고, 새로운 아크/노드를 생성하며, 기존 아크/노드를 제거하는 작업이 포함됩니다. 수정 로직은 모든 활성 노드에 적용될 사용자 정의 함수에 의해 제공됩니다.","Parallel Graph Transformation

The main goal of Graph transformation is to modify the graph. This include modifying the properties of existing nodes and arcs, creating new arcs / nodes and removing existing arcs / nodes. The modification logic is provided by a user-defined function, which will be applied to all active nodes.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
실행 오케스트레이터,Execution Orchestrator,"이 모델은 지능형 스케줄러/오케스트레이터를 기반으로 하여, 종속성 그래프를 기반으로 한 실행 준비 작업을 여러 덤 워커 클러스터에서 스케줄링합니다.

예제: Microsoft Dryad","This model is based on an intelligent scheduler / orchestrator to schedule ready-to-run tasks (based on a dependency graph) across a clusters of dumb workers.

example: Microsoft Dryad",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
로드 밸런서를 사용하는 두 가지 이유는 무엇인가요?,What are 2 reasons for using a load balancer?,수평적 확장성 및 중복성,horizontal scalability and redundancy,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
로드 밸런서에서 사용하는 밸런싱 방법은 무엇인가요?,What are balancing methods used by load balancers?,"요청 할당: 랜덤, 원형 robin, 기계 용량 가중치가 있는 랜덤 등
현재 상태와 일치합니다(요청, 응답 없음, 오류율 상승 등).","assignment of a request: random, round-robin, random with weighting for machine capacity, etc
matched with current status (available for requests, not responding, elevated error rate, etc).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
로드 밸런서의 세 가지 선택지는 무엇인가요? 균형 메커니즘이 아닌 세 가지 종류입니다.,"What are the 3 choices in load balancers? The 3 kinds, not balancing mechanisms.","- 스마트 클라이언트는 서버의 가용성을 결정하는 소프트웨어 기반 메커니즘입니다.
- Citrix NetScaler와 같은 하드웨어 로드 밸런서는 놀라울 정도로 비싸고 구성하기에도 ""사소한"" 요소가 없습니다.
- 소프트웨어 로드 밸런서: HAProxy","- Smart client, a software based mechanism for determining the availability of a server.
- Hardware load balancer, such as Citrix NetScaler, are remarkably expensive, and they are also ""non-trivial"" to configure.
- Software load balancer: HAProxy",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
in-memory 캐시의 두 가지 예는 무엇인가요?,What are 2 examples of in-memory caches?,메모리 캐시와 Redis는 모두 in-memory 캐시의 예입니다,Memcached and Redis are both examples of in-memory caches,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
쓰기 캐시란 무엇인가요?,What is write-through cache?,"쓰기 캐시는 호스트에게 I/O 완료를 확인하기 전에 쓰기 I/O를 캐시로, 그리고 기본 영구 저장소로 전달합니다. 이렇게 하면 데이터 업데이트가 공유 스토리지 배열에 안전하게 저장되지만, I/O가 해당 저장소에 쓰기를 할 때 여전히 지연이 발생한다는 단점이 있습니다. 쓰기 캐시는 캐시에 데이터가 저장되어 읽기 지연 시간이 짧기 때문에 데이터를 자주 쓰고 다시 읽는 애플리케이션에 적합합니다.","Write-through cache directs write I/O onto cache and through to underlying permanent storage before confirming I/O completion to the host. This ensures data updates are safely stored on, for example, a shared storage array, but has the disadvantage that I/O still experiences latency based on writing to that storage. Write-through cache is good for applications that write and then re-read data frequently as data is stored in cache and results in low read latency.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
라이트백 캐시란 무엇인가요?,What is write-back cache?,"쓰기-백 캐시는 쓰기 I/O가 캐시로 향하고 완료가 호스트에게 즉시 확인되는 곳입니다. 이로 인해 쓰기 집약적인 애플리케이션에서는 지연 시간이 짧고 처리량이 높지만, 작성된 데이터의 유일한 복사본이 캐시에 있기 때문에 데이터 가용성 노출 위험이 있습니다. 나중에 논의하겠지만, 공급업체는 쓰기를 복제하는 제품으로 복원력을 높였습니다. 사용자는 쓰기-백 캐시 솔루션이 외부 스토리지로 단계적으로 데이터가 노출될 때 충분한 보호 기능을 제공하는지 고려해야 합니다. 쓰기-백 캐시는 읽기 및 쓰기 I/O 모두 응답 시간 수준이 유사하기 때문에 혼합 워크로드에 가장 적합한 성능 솔루션입니다.","Write-back cache is where write I/O is directed to cache and completion is immediately confirmed to the host. This results in low latency and high throughput for write-intensive applications, but there is data availability exposure risk because the only copy of the written data is in cache. As we will discuss later, suppliers have added resiliency with products that duplicate writes. Users need to consider whether write-back cache solutions offer enough protection as data is exposed until it is staged to external storage. Write-back cache is the best performing solution for mixed workloads as both read and write I/O have similar response time levels.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
읽기 캐시란 무엇인가요?,What is read-through cache?,캐시에서 항목에 액세스하면 캐시 미스가 발생하면 영구 저장소(아마도 콜백을 사용하여)에서 데이터를 읽은 다음 캐시에 저장합니다. 그런 다음 응답이 호스트로 다시 전송됩니다.,"An item is accessed from cache, and if it's a cache miss, the data will be read from persistent storage (perhaps with a callback) and then placed into cache. The response is then sent back to the host.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
HDFS란 무엇인가요?,What is HDFS?,"하둡 파일 시스템(HDFS)은 확장 가능하고 신뢰할 수 있는 데이터 저장을 제공하는 자바 기반 파일 시스템으로, 대규모 상용 서버 클러스터에 걸쳐 설계되었습니다.","Hadoop File System (HDFS) is a Java-based file system that provides scalable and reliable data storage, and it was designed to span large clusters of commodity servers.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
호튼웍스란 무엇인가요?,What is Hortonworks?,Hortonworks는 대규모 데이터 세트를 여러 컴퓨터 클러스터에서 분산 처리할 수 있는 프레임워크인 Apache Hadoop의 개발 및 지원에 중점을 둔 소프트웨어 회사입니다.,"Hortonworks is a software company focused on the development and support of Apache Hadoop, a framework that allows for the distributed processing of large data sets across clusters of computers.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
플랫폼 레이어란 무엇인가요?,What is a platform layer?,"플랫폼 계층과 통신하는 웹 애플리케이션은 다시 데이터베이스와 통신합니다. 

먼저 플랫폼과 웹 애플리케이션을 분리하면 조각을 독립적으로 확장할 수 있습니다. 새 API를 추가하면 웹 애플리케이션 계층에 불필요한 용량을 추가하지 않고도 플랫폼 서버를 추가할 수 있습니다. 

둘째, 플랫폼 계층을 추가하는 것은 캐시, 데이터베이스 등을 처리하기 위해 너무 많은 중복 보일러플레이트 코드를 작성하지 않고도 여러 제품이나 인터페이스(웹 애플리케이션, API, iPhone 앱 등)에 대한 인프라를 재사용할 수 있는 방법이 될 수 있습니다.

셋째, 플랫폼 계층의 때때로 과소평가되는 측면은 조직을 확장하기 쉽게 만든다는 점입니다. 플랫폼은 최상의 경우 구현 세부 사항을 가리는 제품에 구애받지 않는 선명한 인터페이스를 제공합니다. 이를 통해 여러 독립 팀이 플랫폼의 기능을 활용하여 개발할 수 있으며, 다른 팀도 플랫폼 자체를 구현/최적화할 수 있습니다.","Web applications to communicate with a platform layer which in turn communicates with your databases. 

First, separating the platform and web application allow you to scale the pieces independently. If you add a new API, you can add platform servers without adding unnecessary capacity for your web application tier. 

Second, adding a platform layer can be a way to reuse your infrastructure for multiple products or interfaces (a web application, an API, an iPhone app, etc) without writing too much redundant boilerplate code for dealing with caches, databases, etc.

Third, a sometimes underappreciated aspect of platform layers is that they make it easier to scale an organization. At their best, a platform exposes a crisp product-agnostic interface which masks implementation details. If done well, this allows multiple independent teams to develop utilizing the platform's capabilities, as well as another team implementing/optimizing the platform itself.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
멀티 호밍이란 무엇인가요?,What is multi-homing?,여러 데이터 센터에서 서비스를 실행합니다.,Running a service across multiple datacenters.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
약한 일관성은 어디에서 괜찮나요?,Where is weak consistency OK?,"- 캐싱
- VOIP
- 실시간 멀티플레이어 게임","- caching
- VOIP
- real-time mutiplayer games",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
팍소스 알고리즘이란 무엇인가요?,What is the Paxos algorithm?,팍소스는 신뢰할 수 없는 프로세서 네트워크에서 합의를 해결하기 위한 프로토콜 제품군입니다. 합의는 참가자 그룹 간에 하나의 결과에 동의하는 과정입니다. 참가자나 그들의 커뮤니케이션 매체가 실패를 경험할 경우 이 문제는 어려워집니다.,Paxos is a family of protocols for solving consensus in a network of unreliable processors. Consensus is the process of agreeing on one result among a group of participants. This problem becomes difficult when the participants or their communication medium may experience failures.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
일관된 해싱은 어떤 문제를 해결하는 데 도움이 되나요?,What problem does consistent hashing help solve?,"서버 = hash(i) mod m과 같은 캐싱 방식을 사용하고 있는데 클러스터 내 하나의 서버가 중단되는 경우, 모든 캐시가 엔티티를 재해시해야 할 때 서버를 스윕하지 않으려면 일관된 해싱이 필요합니다.","If you're using a caching scheme like server = hash(i) mod m, and one server in the cluster drops out, consistent hashing is needed to avoid swamping your servers when all the caches need to rehash their entities.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
일관된 해싱과 멤캐시의 관계는 무엇인가요?,What is the relationship between consistent hashing and memcache?,"일관된 해싱은 멤캐시에 대해 알지도 못하는 상태에서 사용할 수 있습니다. 일관된 해싱 알고리즘을 구현해야 하는 것은 클라이언트뿐이며, 멤캐시된 서버는 변하지 않는다는 점이 흥미롭습니다.",Consistent hashing can be used with memcache not even knowing about it.  It is interesting to note that it is only the client that needs to implement the consistent hashing algorithm - the memcached server is unchanged.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
NoSQL 솔루션의 몇 가지 예는 무엇인가요?,What are some examples of NoSQL solutions?,"Google BigTable
HBase(Hadoop 기반)
Hypertable
Amazon DynamoDB
Voldemort
Cassandra
Riak
Redis
CouchDB
MongoDB","Google BigTable
HBase (based on Hadoop)
Hypertable
Amazon DynamoDB
Voldemort
Cassandra
Riak
Redis
CouchDB
MongoDB",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
팍소스는 어떤 예인가요?,What is Paxos an example of?,쿼럼 기반 2PC(2단계 커밋) 프로토콜,quorum-based 2PC (2 phase commit) protocol,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
MVCC란 무엇인가요?,What is MVCC?,"다중 버전 동시성 제어(MCC 또는 MVCC)는 데이터베이스 관리 시스템에서 데이터베이스에 대한 동시 접근을 제공하고, 프로그래밍 언어에서 트랜잭션 메모리를 구현하는 데 일반적으로 사용되는 동시성 제어 방법입니다.","Multiversion concurrency control (MCC or MVCC), is a concurrency control method commonly used by database management systems to provide concurrent access to the database and in programming languages to implement transactional memory.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SOLID의 S는 무엇인가요?,What is the S in SOLID?,"단일 책임 원칙. 수업이 변화하는 이유는 한 가지 이상이어서는 안 됩니다. 우리는 ""변화의 이유""를 ""수업의 책임""과 연관시킬 수 있습니다. 따라서 각 책임은 변화의 축이 될 것입니다.",The single responsibility principle. There should never be more than one reason for a class to change. We can relate the “reason to change” to “the responsibility of the class”. So each responsibility would be an axis for change.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
continuous.futures는 무엇을 하나요?,What does concurrent.futures do?,컨커런트 퓨처스 모듈은 스레드 또는 프로세스 워커 풀을 사용하여 작업을 실행할 수 있는 인터페이스를 제공합니다. API는 동일하므로 애플리케이션은 최소한의 변경으로 스레드와 프로세스 간에 전환할 수 있습니다.,"The concurrent.futures modules provides interfaces for running tasks using pools of thread or process workers. The APIs are the same, so applications can switch between threads and processes with minimal changes.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
솔리드의 O는 무엇인가요?,What is the O in SOLID?,"개방/폐쇄 원칙(OCP)에 따르면 코드의 설계 및 작성은 기존 코드의 최소한의 변경으로 새로운 기능을 추가하는 방식으로 이루어져야 합니다. 기존 코드를 최대한 변경하지 않고 새로운 기능을 새로운 클래스로 추가할 수 있는 방식으로 설계해야 합니다.
""확장을 위해 열려 있음/수정을 위해 닫힘""

--

1990년대 동안, 개방/폐쇄 원칙은 추상화된 인터페이스를 사용하는 것을 의미하도록 대중적으로 재정의되었습니다. 여기서 구현은 변경될 수 있으며, 여러 구현이 생성되고 서로 다형성적으로 대체될 수 있습니다.

마이어의 사용과 달리, 이 정의는 추상적인 기본 클래스로부터의 상속을 옹호합니다. 인터페이스 사양은 상속을 통해 재사용할 수 있지만 구현할 필요는 없습니다.","The Open/Closed Principle (OCP) states that the design and writing of the code should be done in a way that new functionality should be added with minimum changes in the existing code. The design should be done in a way to allow the adding of new functionality as new classes, keeping as much as possible existing code unchanged.
""open for extension / closed for modifications""

--

During the 1990s, the open/closed principle became popularly redefined to refer to the use of abstracted interfaces, where the implementations can be changed and multiple implementations could be created and polymorphically substituted for each other.

In contrast to Meyer's usage, this definition advocates inheritance from abstract base classes. Interface specifications can be reused through inheritance but implementation need not be.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
What is RTTI?,What is RTTI?,실행 시간 유형 식별,run time type identification,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"""모든 구성원 변수를 비공개로 설정""하는 것이 어떤 솔리드 원칙을 시행하는 데 도움이 되나요?","Which SOLID principle is ""Make all Member Variables Private."" helping to enforce?",개방/폐쇄 원칙 (OCP),The open/closed principle (OCP),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
솔리드의 L은 무엇인가요?,What is the L in SOLID?,"리스코프 치환 원리 (LSP)
새로운 파생 클래스가 기존 클래스의 기능을 대체하지 않고 확장되도록 해야 합니다. 그렇지 않으면 새로운 클래스가 기존 프로그램 모듈에서 사용될 때 원치 않는 효과를 낼 수 있습니다.

리스코프의 대체 원리에 따르면, 프로그램 모듈이 기본 클래스를 사용하는 경우, 기본 클래스에 대한 참조는 프로그램 모듈의 기능에 영향을 주지 않으면서 파생 클래스로 대체될 수 있습니다.

이 원칙은 오픈 클로즈 원칙의 확장일 뿐이며, 새로운 파생 클래스가 기본 클래스의 동작을 변경하지 않고 확장되도록 해야 한다는 것을 의미합니다.","The Liskov substitution principle (LSP)
We must make sure that the new derived classes just extend without replacing the functionality of old classes. Otherwise the new classes can produce undesired effects when they are used in existing program modules.

Liskov's Substitution Principle states that if a program module is using a Base class, then the reference to the Base class can be replaced with a Derived class without affecting the functionality of the program module.

This principle is just an extension of the Open Close Principle and it means that we must make sure that new derived classes are extending the base classes without changing their behavior.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
솔리드의 I는 무엇인가요?,What is the I in SOLID?,"인터페이스 분리 원칙(ISP)은 클라이언트가 사용하지 않는 인터페이스를 강제로 구현해서는 안 된다고 명시하고 있습니다. 하나의 두꺼운 인터페이스 대신, 각 인터페이스는 하나의 하위 모듈에 서비스를 제공하는 메서드 그룹을 기반으로 많은 작은 인터페이스가 선호됩니다.","The Interface Segregation Principle (ISP) states that clients should not be forced to implement interfaces they don't use. Instead of one fat interface many small interfaces are preferred based on groups of methods, each one serving one submodule.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
솔리드의 D는 무엇인가요?,What is the D in SOLID?,"종속성 반전 원리 (DIP)
고수준 모듈은 저수준 모듈에 의존해서는 안 됩니다. 둘 다 추상화에 의존해야 합니다.
추상화는 세부 사항에 의존해서는 안 됩니다. 세부 사항은 추상화에 의존해야 합니다.","Dependency inversion principle (DIP)
High-level modules should not depend on low-level modules. Both should depend on abstractions.
Abstractions should not depend on details. Details should depend on abstractions.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CDN이 가용성을 보장하기 위해 사용하는 3가지 요소는 무엇인가요?,What are 3 things CDNs use to ensure availability?,"로컬 클러스터링은 내결함성과 확장성을 향상시킬 수 있습니다. 미러링(몇 군데에 클러스터를 배포)과 멀티호밍(여러 ISP를 사용하여 인터넷에 연결). 
클러스터링, 미러링, 멀티호밍은 엄격한 신뢰성과 확장성 요구가 있는 사이트에서 흔히 사용되는 접근 방식입니다.","Local clustering can improve fault-tolerance and scalability. Mirroring (deploying clusters in a few locations) and multihoming (using multiple ISPs to connect to the Internet). 
Clustering, mirroring, and multihoming are common approaches for sites with stringent reliability and scalability needs.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
하이퍼스레딩이란 무엇인가요?,What is hyper-threading?,"하이퍼스레딩은 하나의 프로세서 코어를 두 개 이상의 동시 실행에 사용할 수 있게 해주며, 약간의 추가 하드웨어만 있으면 가능합니다.",Hyper-threading enables a single processor core to be used for two or more concurrent executions with just a little extra hardware.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DMA란 무엇인가요?,What is DMA?,DMA(직접 메모리 액세스)는 노스브리지의 도움을 받아 장치가 CPU의 개입 없이 RAM에 직접 데이터를 저장하고 수신할 수 있도록 합니다.,"DMA (Direct Memory Access) allows devices, with the help of the Northbridge, to store and receive data in RAM directly without the intervention of the CPU.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
NUMA는 무엇을 의미하나요?,What does NUMA stand for?,비균일 메모리 아키텍처,Non-Uniform Memory Architecture,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SRAM과 DRAM은 어디에 사용되나요?,Where are SRAM and DRAM used?,SRAM은 더 빠른 속도 때문에 캐시에서 사용되고 DRAM은 더 높은 밀도 때문에 PC의 메인 메모리로 사용됩니다.,SRAMs are used in Caches because of higher speed and DRAMs are used for main memory in a PC because of higher densities.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SRAM과 DRAM의 차이점은 무엇인가요?,What is the difference between SRAM and DRAM?,DRAM은 동적 랜덤 액세스 메모리를 의미합니다. DRAM은 메모리가 전하 형태로 저장되는 반도체 메모리의 일종입니다. DRAM의 각 메모리 셀은 트랜지스터와 커패시터로 구성됩니다. 데이터는 커패시터에 저장됩니다. 커패시터는 누설로 인해 전하를 잃기 때문에 DRAM은 휘발성 장치입니다. 데이터를 메모리에 보관하려면 SRAM은 정적인 반면 장치는 정기적으로 새로 고쳐야 하므로 전원이 공급되는 한 값을 유지합니다. SRAM은 일반적으로 새로 고침 주기가 없기 때문에 DRAM보다 빠릅니다. 각 SRAM 메모리 셀은 트랜지스터 1개와 커패시터 1개로 구성된 DRAM 메모리 셀과 달리 6개의 트랜지스터로 구성되어 있기 때문에 메모리 셀당 비용이 DRAM에 비해 SRAM에서 훨씬 더 높습니다.,"DRAM stands for Dynamic Random Access Memory. It is a type of semiconductor memory in which the memory is stored in the form of a charge. Each memory cell in a DRAM is made of a transistor and a capacitor. The data is stored in the capacitor. Capacitors loose charge due to leakage and hence DRAM's are volatile devices. To keep the data in the memory, the device must be regularly refreshed whereas SRAM is static, so it will retain a value as long as power is supplied. SRAM is typically faster than DRAM since it doesn't have refresh cycles. Since each SRAM memory cell is comprised of 6 Transistors unlike a DRAM memory cell, which is comprised of 1 Transistor and 1 Capacitor, the cost per memory cell is far greater in an SRAM compared to a DRAM.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CPU 코어와 CPU 스레드의 차이점은 무엇인가요?,What is the difference between a CPU core and a CPU thread?,"코어와 스레드의 차이점은 별도의 코어가 거의 모든 하드웨어 리소스의 복사본을 가지고 있다는 점입니다. 코어는 동일한 리소스(예: 외부와의 연결)를 동시에 사용하지 않는 한 완전히 독립적으로 실행될 수 있습니다. 반면 스레드는 프로세서의 거의 모든 리소스를 공유합니다.
인텔의 스레드 구현에는 스레드에 대한 별도의 레지스터만 있으며, 그마저도 일부 레지스터는 제한적입니다
공유합니다.","The difference between a core and a thread is that separate cores have separate copies of (almost) all the hardware resources. The cores can run completely independently unless they are using the same resources–e.g., the connections to the outside - at the same time. Threads, on the other hand, share almost all of the processor’s resources.
Intel’s implementation of threads has only separate registers for the threads and even that is limited, some registers
are shared.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SMP란 무엇인가요?,What is SMP?,"대칭 다중 processor

대칭형 다중 프로세서(SMP) 시스템에서는 CPU의 캐시가 서로 독립적으로 작동할 수 없습니다. 모든 프로세서는 항상 동일한 메모리 콘텐츠를 볼 수 있어야 합니다. 이러한 일관된 메모리 뷰를 유지하는 것을 ""캐시 일관성""이라고 합니다.","symmetric multi-processor

In symmetric multi-processor (SMP) systems the caches of the CPUs cannot work independently from each other. All processors are supposed to see the same memory content at all times. The maintenance of this uniform view of memory is called “cache coherency”.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
멀티프로세서 CPU는 캐시 일관성을 어떻게 유지하나요?,How does a multi-processor CPU maintain cache coherency?,"- 다른 프로세서의 캐시에는 더러운 캐시 라인이 없습니다.
- 동일한 캐시 라인의 깨끗한 복사본은 임의의 많은 캐시에 저장될 수 있습니다.","- A dirty cache line is not present in any other processor’s cache.
- Clean copies of the same cache line can reside in arbitrarily many caches.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
거상이란 무엇인가요?,What is Colossus?,구글 파일 시스템의 후속작,the successor to the Google File System,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스패너란 무엇인가요?,What is Spanner?,"Spanner는 Google에서 설계, 구축 및 배포되는 확장 가능한 글로벌 분산 데이터베이스입니다. 추상화 수준이 가장 높은 데이터베이스로, 전 세계 데이터 센터의 여러 Paxos 상태 머신 세트에서 데이터를 공유합니다. 복제는 글로벌 가용성과 지리적 지역성을 위해 사용되며, 클라이언트는 복제본 간에 자동으로 페일오버됩니다. Spanner는 데이터 양이나 서버 수가 변경됨에 따라 자동으로 데이터를 여러 머신에서 재공유하고, 데이터 센터 간에도 자동으로 데이터를 마이그레이션하여 부하와 장애에 대한 대응을 균형 있게 조정합니다. Spanner는 수백 개의 데이터 센터와 수조 개의 데이터베이스 행에 걸쳐 최대 수백만 대의 머신을 확장할 수 있도록 설계되었습니다.","Spanner is a scalable, globally-distributed database designed, built, and deployed at Google. At the highest level of abstraction, it is a database that shards data across many sets of Paxos state machines in datacenters spread all over the world. Replication is used for global availability and geographic locality; clients automatically failover between replicas. Spanner automatically reshards data across machines as the amount of data or the number of servers changes, and it automatically migrates data across machines (even across datacenters) to balance load and in response to failures. Spanner is designed to scale up to millions of machines across hundreds of datacenters and trillions of database rows.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
마르줄로의 알고리즘은 무엇인가요?,What is Marzullo's algorithm?,"Marzulo의 알고리즘은 여러 노이즈가 있는 시간 소스에서 정확한 시간을 추정하기 위한 소스를 선택하는 데 사용되는 합의 알고리즘입니다. ""교차 알고리즘""으로 이름이 바뀐 이 알고리즘의 정제된 버전은 현대 네트워크 시간 프로토콜의 일부를 형성합니다.","Marzullo's algorithm, is an agreement algorithm used to select sources for estimating accurate time from a number of noisy time sources. A refined version of it, renamed the ""intersection algorithm"", forms part of the modern Network Time Protocol.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Google 파일 시스템이란 무엇인가요?,What is Google File System?,"대규모 분산 데이터 집약적인 애플리케이션을 위한 확장 가능한 분산 파일 시스템입니다. 저렴한 상용 하드웨어에서 실행되는 동안 내결함성을 제공하며, 많은 클라이언트에게 높은 종합 성능을 제공합니다.
파일에 추가하여 다중 GB 및 TB 파일을 처리하는데, 이는 대용량 데이터 파일의 주요 사용 패턴이기 때문입니다.","A scalable distributed file system for large distributed data-intensive applications. It provides fault tolerance while running on inexpensive commodity hardware, and it delivers high aggregate performance to a large number of clients.
It deals with multi-GB and TB files by appending to files, as that is the predominant usage pattern of large data files.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
BNF란 무엇인가요?,What is BNF?,"BNF(Backus Normal Form 또는 Backus–Naur Form)는 문맥 자유 문법을 위한 두 가지 주요 표기 기법 중 하나로, 컴퓨터 프로그래밍 언어, 문서 형식, 명령어 집합 및 통신 프로토콜과 같은 컴퓨팅에서 사용되는 언어의 구문을 설명하는 데 자주 사용됩니다. 문맥 자유 문법을 작성하는 또 다른 주요 기법은 반 빈가르덴 형식입니다.","BNF (Backus Normal Form or Backus–Naur Form) is one of the two main notation techniques for context-free grammars, often used to describe the syntax of languages used in computing, such as computer programming languages, document formats, instruction sets and communication protocols; the other main technique for writing context-free grammars is the van Wijngaarden form.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
맵리듀스란 무엇인가요?,What is MapReduce?,2004년 Google에서 개발한 MapReduce는 대규모 데이터 세트를 처리하고 생성하기 위한 프로그래밍 모델이자 관련 구현입니다. 사용자는 키/값 쌍을 처리하여 중간 키/값 쌍을 생성하는 맵 함수와 동일한 중간 키와 관련된 모든 중간 값을 병합하는 축소 함수를 지정합니다.,"MapReduce, developed by Google in 2004, is a programming model and an associated implementation for processing and generating large data sets. Users specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Zipf 분포란 무엇인가요?,What is a Zipf distribution?,"Zipf 분포는 때때로 제타 분포라고도 불리며, 언어학, 보험, 희귀 사건 모델링에서 흔히 사용되는 이산 분포입니다.","The Zipf distribution, sometimes referred to as the zeta distribution, is a discrete distribution commonly used in linguistics, insurance, and the modeling of rare events.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
malloc 함수에 의해 반환되는 메모리 주소는 일반적으로 최소 ___ 바이트로 정렬됩니다.,The memory addresses returned by the malloc function are typically aligned to at least ___ bytes.,8,8,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
AddressSanitizer란 무엇인가요?,What is AddressSanitizer?,"AddressSanitizer는 빠른 메모리 오류 감지기입니다. AddressSanitizer는 힙, 스택, 글로벌의 경우 평균 73%의 속도 저하와 3.4배의 메모리 크기로 아웃오브바운드(out-of-bound) 접근 및 사용 후 버그를 찾아냅니다. 이 도구에는 오탐이 없습니다.
AddressSanitizer는 정확하고 즉각적인 버그 탐지를 제공하기 위해 그림자 메모리를 사용합니다. 일반적인 통념은 그림자 메모리가 다단계 매핑 방식을 통해 높은 오버헤드를 발생시키거나, 인접한 큰 영역을 차지함으로써 엄청난 주소 공간 요구 사항을 부과한다는 것입니다. 우리의 새로운 그림자 상태 인코딩은 간단한 매핑을 사용할 수 있을 만큼 우리의 그림자 공간 발자국을 줄여주며, 이는 낮은 오버헤드로 구현될 수 있습니다.
3.1부터 LLVM의 컴파일 옵션으로 포함되어 있습니다.","AddressSanitizer is a fast memory error detector. AddressSanitizer finds out-of-bounds (for heap, stack, and globals) accesses and use-after-free bugs at the cost of 73% slowdown on average and a 3.4x memory size; the tool has no false positives.
AddressSanitizer uses shadow memory to provide accurate and immediate bug detection. The conventional wisdom is that shadow memory either incurs high overhead through multi-level mapping schemes or imposes prohibitive address space requirements by occupying a large contiguous region. Our novel shadow state encoding reduces our shadow space footprint enough that we can use a simple mapping, which can be implemented with low overhead.
It has been included as a compilation option in LLVM since 3.1.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
전이적 폐쇄란 무엇인가요?,What is transitive closure?,"전이적 폐쇄는 도달 가능성 질문에 답할 수 있는 데이터 구조를 구성하는 것으로 생각할 수 있습니다. 즉, 노드 A에서 노드 D로 하나 이상의 홉으로 이동할 수 있을까요?","transitive closure can be thought of as constructing a data structure that makes it possible to answer reachability questions. That is, can one get from node a to node d in one or more hops?",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CUDA란 무엇인가요?,What is CUDA?,"CUDA(Comput Unified Device Architecture)는 NVIDIA에서 개발한 병렬 컴퓨팅 플랫폼이자 애플리케이션 프로그래밍 인터페이스(API) 모델입니다. [1] 소프트웨어 개발자와 소프트웨어 엔지니어는 범용 처리를 위해 CUDA 지원 그래픽 처리 장치(GPU)를 사용할 수 있으며, 이를 GPGPU라고 합니다. CUDA 플랫폼은 GPU의 가상 명령어 세트와 병렬 계산 요소에 직접 접근하여 컴퓨팅 커널을 실행할 수 있는 소프트웨어 계층입니다. [2]","CUDA (Compute Unified Device Architecture) is a parallel computing platform and application programming interface (API) model created by NVIDIA.[1] It allows software developers and software engineers to use a CUDA-enabled graphics processing unit (GPU) for general purpose processing – an approach known as GPGPU. The CUDA platform is a software layer that gives direct access to the GPU's virtual instruction set and parallel computational elements, for the execution of compute kernels.[2]",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
보그란 무엇인가요?,What is Borg?,최초의 통합 컨테이너 관리 시스템은 Google에서 개발되었습니다. 이 시스템은 장기 서비스와 배치 작업을 모두 관리하도록 설계되었습니다.,The first unified container-management system developed at Google. It was built to manage both long-running services and batch jobs.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
MPM이란 무엇인가요?,What is MPM?,Google 내에서 MPM(Midas Package Manager)은 컨테이너 이미지를 구축하고 배포하는 데 사용됩니다. 이는 Docker 컨테이너의 Docker 이미지 레지스트리에 해당합니다.,"Within Google, MPM (Midas Package Manager) is used to build and deploy container images. It corresponds to the Docker image registry for Docker containers.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
용기의 3가지 이점은 무엇인가요?,What are 3 benefits of containers?,"1. 컨테이너는 애플리케이션 환경을 캡슐화하여 애플리케이션 개발자와 배포 인프라에서 기계와 운영 체제의 많은 세부 사항을 추상화합니다.
2. 잘 설계된 컨테이너와 컨테이너 이미지는 단일 애플리케이션으로 범위가 지정되기 때문에 컨테이너를 관리한다는 것은 기계가 아닌 애플리케이션을 관리하는 것을 의미합니다. 이러한 관리 API의 기계 중심에서 애플리케이션 중심으로 전환하면 애플리케이션 배포와 성찰이 크게 향상됩니다.
3. 이미지와 운영 체제를 분리하면 개발과 생산 모두에서 동일한 배포 환경을 제공할 수 있으며, 이는 결과적으로 배포 신뢰성을 향상시키고 불일치와 마찰을 줄여 개발 속도를 높입니다.","1. Containers encapsulate the application environment, abstracting away many details of machines and operating systems from the application developer and the deployment infrastructure.
2. Because well-designed containers and container images are scoped to a single application, managing containers means managing applications rather than machines. This shift of management APIs from machine-oriented to application oriented dramatically improves application deployment and introspection.
3. Decoupling of image and OS makes it possible to provide the same deployment environment in both development and production, which, in turn, improves deployment reliability and speeds up development by reducing inconsistencies and friction.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
통통이란 무엇인가요?,What is Chubby?,Borg를 기반으로 구축된 분산 잠금 서비스(마스터 선거).,A distributed lock service (master election) built on Borg.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CSP는 무엇을 의미하나요?,What does CSP stand for?,순차적 프로세스 소통,Communicating Sequential Processes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로토콜 버퍼란 무엇인가요?,What is Protocol buffers?,"프로토콜 버퍼(일명 프로토부프)는 구조화된 데이터를 직렬화하기 위한 Google의 언어 중립적이고 플랫폼 중립적이며 확장 가능한 메커니즘입니다. IDL 기반입니다.

데이터를 구조화하는 방법을 한 번 정의한 다음, 특수 생성된 소스 코드를 사용하여 다양한 데이터 스트림과 다양한 언어를 사용하여 구조화된 데이터를 쉽게 쓰고 읽을 수 있습니다.","Protocol buffers (aka protobuf) are Google's language-neutral, platform-neutral, extensible mechanism for serializing structured data. IDL-based.

You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로토콜 버퍼를 사용하는 것이 피클링보다 나은 이유는 무엇인가요?,Why is using Protocol buffers better than pickling?,"파이썬 피클링은 스키마 진화를 잘 다루지 않으며, C++ 또는 Java로 작성된 애플리케이션과 데이터를 공유해야 하는 경우에도 잘 작동하지 않습니다.","Python pickling doesn't deal well with schema evolution, and also doesn't work very well if you need to share data with applications written in C++ or Java.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
What is gRPC?,What is gRPC?,이 프레임워크는 Google의 RPC를 위한 오픈 소스입니다. gRPC는 HTTP/2와 Google의 자체 Protobuf를 사용하여 확장 가능하고 낮은 지연 시간의 통신을 제공합니다. gRPC에는 새로운 기능을 포함하고 이전 버전보다 사용하기 쉬운 고성능 바이너리 직렬화를 위한 새로운 버전의 Protobuf(proto3)가 포함되어 있습니다.,It’s an open source framework for RPC by Google. gRPC uses HTTP/2 and Google’s own Protobuf to provide a scalable and low latency communication. With gRPC comes a new version of Protobuf (proto3) for high performance binary serialization which includes new features and is easier to use than its predecessors.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Redis란 무엇인가요?,What is Redis?,"Redis는 데이터베이스, 캐시 및 메시지 브로커로 사용되는 in-memory 데이터 구조 저장소입니다. 문자열, 해시, 리스트, 세트, 정렬된 세트, 범위 쿼리, 비트맵, 하이퍼로그 및 반경 쿼리를 포함한 지리 공간 인덱스를 지원합니다. Redis는 복제, Lua 스크립팅, LRU 제거, 트랜잭션 및 다양한 수준의 디스크 내 지속성을 내장하고 있으며, Redis Sentinel을 통해 고가용성을 제공하고 Redis Cluster를 사용한 자동 파티셔닝을 제공합니다.","Redis is an in-memory data structure store, used as database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs and geospatial indexes with radius queries. Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Redis 대기열을 어느 정도 안정적으로 만들기 위해 어떤 명령어를 사용할 수 있나요?,What commands can be used to make a Redis queue somewhat reliable?,"LPUSH
RPOPLPUSH - 오른쪽으로 튀어오르며, 원자적으로 처리하기 위해 다른 목록으로 이동합니다,
BRPOPLPUSH - 위와 동일하지만 차단
RPOP

Redis는 갑작스러운 종료나 정전이 발생할 경우 데이터 손실에 더 취약합니다.","LPUSH
RPOPLPUSH - pop right, pushing onto another list for processing, atomically,
BRPOPLPUSH - same as above, but blocking
RPOP

Redis is more susceptible to data loss in the event of abrupt termination or power failures.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
RabbitMQ란 무엇인가요?,What is RabbitMQ?,"RabbitMQ는 메시징 중개업체입니다.

메시지는 대기열에 도착하기 전에 교환을 통해 라우팅됩니다. RabbitMQ는 일반적인 라우팅 로직을 위해 여러 가지 내장된 교환 유형을 제공합니다. 더 복잡한 라우팅을 위해 교환을 함께 바인딩하거나 자신만의 교환 유형을 플러그인으로 작성할 수도 있습니다.

내구성이 뛰어난 대기열, 작업 대기열, 펍/서브, 토픽 핸들러, 심지어 rpc용으로도 사용할 수 있습니다.","RabbitMQ is a messaging broker - an intermediary for messaging.

Messages are routed through exchanges before arriving at queues. RabbitMQ features several built-in exchange types for typical routing logic. For more complex routing you can bind exchanges together or even write your own exchange type as a plugin.

It can be used as a durable queue, work queues, pub/sub, topic handler, and even for rpc.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
피카란 무엇인가요?,What is pika?,"Pika는 AMQP 0-9-1 프로토콜의 순수 파이썬 구현체로, 기본 네트워크 지원 라이브러리로부터 상당히 독립적으로 유지하려고 합니다. RabbitMQ와 함께 사용할 수 있습니다.",Pika is a pure-Python implementation of the AMQP 0-9-1 protocol that tries to stay fairly independent of the underlying network support library. Can use with RabbitMQ.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Celery란 무엇인가요?,What is Celery?,"셀러리는 분산 메시지 전달을 기반으로 하는 비동기식 작업 대기열/작업 대기열입니다. 실시간 운영에 중점을 두지만 스케줄링도 지원합니다. 메시지 브로커와 함께 사용하면 작업 실행이 관리됩니다.

작업이라고 하는 실행 단위는 다중 처리, 이벤트렛 또는 게벤트를 사용하여 단일 이상의 작업자 서버에서 동시에 실행됩니다. 작업은 비동기식(배경)으로 실행되거나 동기식으로 실행될 수 있습니다(준비될 때까지 기다립니다).

추천 메시지 브로커는 RabbitMQ이지만, Redis, Beanstalk, MongoDB, CouchDB 및 데이터베이스(SQLchemy 또는 Django ORM 사용)에 대한 지원도 제공됩니다.","Celery is an asynchronous task queue/job queue based on distributed message passing. It is focused on real-time operation, but supports scheduling as well. You use it with a message broker, and it manages the task execution.

The execution units, called tasks, are executed concurrently on a single or more worker servers using multiprocessing, Eventlet, or gevent. Tasks can execute asynchronously (in the background) or synchronously (wait until ready).

The recommended message broker is RabbitMQ, but support for Redis, Beanstalk, MongoDB, CouchDB, and databases (using SQLAlchemy or the Django ORM) is also available.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
amqp는 무엇을 의미하나요?,What does amqp stand for?,고급 메시지 큐 프로토콜,Advanced Message Queuing Protocol,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
ZeroMQ란 무엇인가요?,What is ZeroMQ?,"socket 기반 시스템은 대기열, 펍/서브 등으로 사용할 수 있습니다.

inproc, IPC, TCP, TIPC, 멀티캐스트에 메시지를 전달합니다.
펍 서브, 푸시 풀(파이프라인), 라우터 딜러와 같은 스마트 패턴.","A socket-based system, can be used as a queue, pub/sub, etc.

Carries messages across inproc, IPC, TCP, TIPC, multicast.
Smart patterns like pub-sub, push-pull (pipeline), and router-dealer.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
ActiveMQ란 무엇인가요?,What is ActiveMQ?,Apache ActiveMQ는 Java로 작성된 오픈 소스 메시지 브로커입니다.,Apache ActiveMQ is an open source message broker written in Java.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
IPC란 무엇인가요?,What is IPC?,"프로세스 간 통신 또는 프로세스 간 통신(IPC)은 운영 체제가 관리하는 프로세스가 데이터를 공유할 수 있도록 제공하는 메커니즘을 말합니다. 일반적으로 애플리케이션은 클라이언트와 서버로 분류된 IPC를 사용할 수 있으며, 클라이언트는 데이터를 요청하고 서버는 클라이언트 요청에 응답합니다.","Inter-process communication or interprocess communication (IPC) refers specifically to the mechanisms an operating system provides to allow processes it manages to share data. Typically, applications can use IPC categorized as clients and servers, where the client requests data and the server responds to client requests.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Kafka란 무엇인가요?,What is Kafka?,"Apache Kafka는 분산, 분할, 복제된 커밋 로그 서비스입니다. 메시징 시스템의 기능을 제공하지만 독특한 디자인을 가지고 있습니다.","Apache Kafka is a distributed, partitioned, replicated commit log service. It provides the functionality of a messaging system, but with a unique design.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메시지팩이란 무엇인가요?,What is MessagePack?,"MessagePack은 효율적인 이진 직렬화 형식입니다. JSON과 같은 여러 언어 간에 데이터를 교환할 수 있습니다. 하지만 더 빠르고 작습니다. 작은 정수는 하나의 바이트로 인코딩되며, 일반적인 짧은 문자열은 문자열 자체 외에 하나의 바이트만 추가하면 됩니다.

IDL 없음.","MessagePack is an efficient binary serialization format. It lets you exchange data among multiple languages like JSON. But it's faster and smaller. Small integers are encoded into a single byte, and typical short strings require only one extra byte in addition to the strings themselves.

No IDL.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
아브로란 무엇인가요?,What is Avro?,"Apache Avro는 데이터 직렬화 시스템입니다. IDL 기반입니다.
풍부한 데이터 구조. 
간결하고 빠른 이진 데이터 형식. 
지속적인 데이터를 저장하는 컨테이너 파일입니다. 
원격 절차 호출(RPC).
코드 생성은 데이터 파일을 읽거나 쓰거나 RPC 프로토콜을 사용하거나 구현하는 데 필요하지 않습니다. 코드 생성은 선택적 최적화로, 정적으로 입력된 언어에만 구현할 가치가 있습니다.","Apache Avro is a data serialization system. IDL-based.
Rich data structures. 
A compact, fast, binary data format. 
A container file, to store persistent data. 
Remote procedure call (RPC).
Code generation is not required to read or write data files nor to use or implement RPC protocols. Code generation as an optional optimization, only worth implementing for statically typed languages.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
블룸 필터란 무엇인가요?,What is a Bloom filter?,"블룸 필터는 가능한 요소의 수와 크기가 매우 큰 집합에서 멤버십을 빠르게 테스트하는 데 사용되는 데이터 구조입니다. 메모리에 저장하기에는 너무 큽니다.
블룸 필터는 1970년 버튼 하워드 블룸이 고안한 공간 효율적인 확률 데이터 구조로, 요소가 집합의 구성원인지 여부를 테스트하는 데 사용됩니다. 거짓 양성 일치는 가능하지만 거짓 음성 일치는 불가능하므로 블룸 필터는 100% 재현율을 가집니다. 즉, 쿼리는 ""집합 내에 있을 가능성"" 또는 ""집합 내에 없을 가능성""을 반환합니다. 요소는 집합에 추가할 수 있지만 제거할 수는 없습니다(이는 ""계산"" 필터로 해결할 수 있지만). 집합에 더 많은 요소가 추가될수록 거짓 양성일 확률이 커집니다.","A Bloom filter is a data structure used to quickly test membership in a set where the number and size of possible elements would be very large. Too large to keep in memory.
A Bloom filter is a space-efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not, thus a Bloom filter has a 100% recall rate. In other words, a query returns either ""possibly in set"" or ""definitely not in set"". Elements can be added to the set, but not removed (though this can be addressed with a ""counting"" filter). The more elements that are added to the set, the larger the probability of false positives.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
같은 요소에 대해 여러 해시를 쉽게 생성하려면 어떻게 해야 하나요?,How can you easily generate multiple hashes for the same element?,"이중 해싱. 이 방법은 필요한 만큼의 해싱을 제공합니다:
hash(x,m) = (hasha(x) + i * hashb(x)) mod m

파이썬에서:
mmh3 가져오기
mmh3.hash64 ('foo') # 투플로 64비트 서명된 두 개의 인트
이제 64비트 해시 2개가 있습니다. i를 대입하면 블룸 필터에 여러 개의 해시가 생성됩니다.","Double hashing. This method gives you as many hashes as you need:
hash(x,m) = (hasha(x) + i * hashb(x)) mod m

In Python:
import mmh3
mmh3.hash64('foo') # two 64 bit signed ints, in a tuple
now you have 2 64-bit hashes. Substituting for i gives you multiple hashes for a Bloom filter.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DFT란 무엇인가요?,What is DFT?,이산 푸리에 변환 - 함수의 유한한 등간격 샘플 시퀀스를 복소수 값의 주파수 함수인 이산 시간 푸리에 변환(DTFT)의 등간격 샘플 시퀀스로 변환합니다.,"Discrete Fourier Transform - converts a finite sequence of equally-spaced samples of a function into an equivalent-length sequence of equally-spaced samples of the discrete-time Fourier transform (DTFT), which is a complex-valued function of frequency.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
FFTW란 무엇인가요?,What is FFTW?,MIT에서 개발된 이 변환은 서양에서 가장 빠른 푸리에 변환입니다.,"Developed at MIT, it's the Fastest Fourier Transform in the West.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
일정한 시간 내에 삽입하고 삭제할 수 있는 데이터 구조는 무엇인가요?,What data structure allows for insert and delete in constant time?,저장된 값으로 인덱싱된 배열. 기술적으로는 비트 벡터입니다.,"An array, indexed by the value stored. Technically a bit vector.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
캐시에 의존하지 않는 알고리즘이란 무엇인가요?,What is a cache-oblivious algorithm?,"캐시가 불분명한 알고리즘은 알고리즘이 캐시를 활용하지 않는다는 것을 의미하지 않으며, 반대로 매우 효과적으로 캐시를 활용합니다. 즉, 알고리즘은 캐시 라인 크기를 알 필요가 없으며, 모든 캐시 라인 크기에 대해 동시에 효과적으로 작동하여 주어진 머신에 맞게 튜닝하거나 최적화할 필요가 없습니다.

최적의 캐시 명확성 알고리즘은 쿨리-투키 FFT 알고리즘, 행렬 곱셈, 정렬, 행렬 전치 및 기타 여러 문제에 대해 잘 알려져 있습니다.","A cache-oblivious algorithm does not mean that the algorithm does not take advantage of the cache; to the contrary, it does so quite effectively. What it means is that the algorithm does not need to know the cache line size; it works effectively for all cache line sizes simultaneously, removing the need to tune or optimize for a given machine.

Optimal cache-oblivious algorithms are known for the Cooley–Tukey FFT algorithm, matrix multiplication, sorting, matrix transposition, and several other problems.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
X와 Y 사이의 항목 수를 찾을 수 있도록 플레이 트리를 보강하려면 어떻게 해야 하나요?,How can you augment a splay tree so you can find how many items are between x and y?,"각 노드에 하위 트리의 크기를 저장합니다. 
x를 찾아서 루트에 재생합니다. 각 재생, 삽입, 삭제는 노드의 크기를 유지해야 합니다.
y를 구하고, 가는 길에 왼쪽 부분 트리의 크기를 더하면, 방문한 왼쪽 노드 각각에 대해 1이 됩니다.
균형을 맞추기 위해 y를 루트로 재생하세요.","Store size of subtrees at each node. 
Find x, splay to root. Each splay, insert, and delete must maintain size in node.
Find y, and along the way add up the sizes in the left subtrees, and 1 for each visited left-hand node.
Splay y to root to ensure balance.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최대 유량 문제에서 최소 컷은 얼마인가요?,"In a maximum flow problem, what is the minimum cut?",최소 컷은 그래프를 통과하는 최대 흐름입니다.,The min cut is the maximum flow through the graph.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
포드-풀커슨 알고리즘이란 무엇인가요?,What is the Ford-Fulkerson algorithm?,"포드-풀커슨 방법 또는 포드-풀커슨 알고리즘(FFA)은 흐름 네트워크에서 최대 흐름을 계산하는 탐욕 알고리즘입니다. 잔차 그래프에서 증강 경로를 찾는 접근 방식이 완전히 지정되지 않았거나 실행 시간이 다른 여러 구현에서 지정되었기 때문에 ""알고리즘"" 대신 ""방법""이라고 불립니다. ""포드-풀커슨""이라는 이름은 포드-풀커슨의 전문인 에드먼즈-카프 알고리즘에도 자주 사용됩니다.","The Ford–Fulkerson method or Ford–Fulkerson algorithm (FFA) is a greedy algorithm that computes the maximum flow in a flow network. It is called a ""method"" instead of an ""algorithm"" as the approach to finding augmenting paths in a residual graph is not fully specified or it is specified in several implementations with different running times. The name ""Ford–Fulkerson"" is often also used for the Edmonds–Karp algorithm, which is a specialization of Ford–Fulkerson.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
분리된 집합 데이터 구조의 실행 시간은 어떻게 되나요?,What is the running time for the disjoint set data structure?,"작은 분리된 집합을 더 큰 집합으로 병합하고(결합 중에는 순위별로 결합이라고 함) 경로 압축을 수행하기 때문에(찾기 중에는), 연산당 상각 시간은 O(alpha(n))뿐이며, 여기서 alpha(n)는 함수의 역수이고 A는 매우 빠르게 성장하는 Ackermann 함수입니다. alpha(n)는 이 함수의 역수이므로, alpha(n)는 모든 원격 실용적인 n 값에 대해 5보다 작습니다. 따라서 연산당 상각된 실행 시간은 사실상 작은 상수입니다.

find()의 최악의 경우는 세타(log u)로, 여기서 u는 조합의 수입니다. 아직 경로 압축을 허용하는 발견은 이루어지지 않았습니다.","Due to merging smaller disjoint sets into larger ones (called union by rank) (during union) and performing path compression (during find), the amortized time per operation is only O(alpha(n)), where alpha(n) is the inverse of the function and A is the extremely fast-growing Ackermann function. Since alpha(n) is the inverse of this function, alpha(n) is less than 5 for all remotely practical values of n. Thus, the amortized running time per operation is effectively a small constant.

The worst-case for find() is Theta(log u) where u is the number of unions, and no finds have been done to allow for path compression yet.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
테스트에서 오라클이란 무엇인가요?,"In testing, what is an oracle?",소프트웨어 테스터와 소프트웨어 엔지니어는 오라클을 테스트가 통과되었는지 또는 실패했는지를 판단하는 메커니즘으로 사용할 수 있습니다. 오라클의 사용은 주어진 테스트 케이스 입력에 대해 테스트 대상 시스템의 출력을 오라클이 해당 제품이 가져야 한다고 판단하는 출력과 비교하는 것을 포함합니다.,"Software testers and software engineers can use an oracle as a mechanism for determining whether a test has passed or failed. The use of oracles involves comparing the output(s) of the system under test, for a given test-case input, to the output(s) that the oracle determines that product should have.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
신뢰 경계가 있는 인터페이스를 테스트하는 방법은 무엇인가요?,What do you test interfaces with a trust boundary?,시스템이 충돌하지 않고 처리하거나 적절하게 오류를 범할 수 있도록 하는 무작위 입력을 포함하여 다양한 입력을 제공합니다.,"With lots of different inputs, including random inputs to ensure that the system can handle or appropriately error out, not crash.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최적화를 켜고 코드에서 어설션을 제거하는 파이썬 플래그는 무엇인가요?,What Python flag turns on optimizations and removes assertions from code?,파이썬 -O,python -O,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
건설업자가 일을 하는 것이 나쁜 이유는 무엇인가요?,Why is doing work in a constructor a bad thing?,코드 테스트가 더 어려워질 수 있습니다.,It can make your code harder to test.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
테스트가 더 쉬우거나 가능하도록 하기 위해 피해야 할 것은 무엇인가요?,What should be avoided to ensure testing is easier/possible?,"- 정적 방법 및 속성
- 최종 키워드
- 새로운 방법의 사용(의존성 주입 사용)","- static methods and properties
- final keyword
- use of new in methods (use dependency injection)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
세터의 다른 이름은 무엇인가요?,What is another name for a setter?,돌연변이,A mutator,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
게터의 다른 이름은 무엇인가요?,What is another name for a getter?,액세서리.,An accessor.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
종속성 역전 원칙을 위반하지 않기 위해 염두에 두어야 할 몇 가지 지침은 무엇인가요?,What are some guidelines to keep in mind to not violate the dependency inversion principle?,"- 어떤 변수에도 구체적인 클래스 유형이 없어야 합니다. 추상적인 유형이 더 좋습니다.
- 어떤 클래스도 구체적인 클래스에서 파생되어서는 안 됩니다.
- 어떤 메서드도 기본 클래스의 구현된 메서드를 무시해서는 안 됩니다.

이것들은 지침이며 항상 실행 가능하지 않을 수도 있습니다.","- No variable should have a concrete class type. An abstract type is better.
- No class should derive from a concrete class.
- No method should override an implemented method of any of its base classes.

These are guidelines and may not be feasible all the time.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
O(2^n)의 다른 이름은 무엇인가요?,What is another name for O(2^n)?,기하급수적 성장,Exponential growth,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
O(n^4)의 다른 이름은 무엇인가요?,What is another name for O(n^4)?,사분위수 성장,Quartic growth,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
big-O는 무슨 뜻인가요? (간단히),What does big-O mean? (briefly),"이렇게 커질 일은 없어요.
성장은 결코 이렇게 느리지 않을 것입니다.","It never gets as big as this.
Growth will never be slower as this.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
빅오메가는 무슨 뜻인가요? (간단히),What does big-Omega mean? (briefly),"적어도 이것만큼 커요.
성장은 결코 이렇게 느리지 않을 것입니다.","It's at least as big as this.
Growth will never be slower as this.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
함정/예외란 무엇인가요?,What is a trap/exception?,프로그램이 프로세스를 중단하고 커null을 제어하기 위해 수행하는 특별한 명령입니다.,A special instruction that a program performs to interrupt the process and give control to the kernel.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스케줄러는 무엇을 하나요?,What does the scheduler do?,스케줄러는 프로세스 스케줄링을 다양한 방식으로 처리하는 특수 시스템 소프트웨어입니다. 이들의 주요 업무는 시스템에 제출할 작업을 선택하고 실행할 프로세스를 결정하는 것입니다.,Schedulers are special system software which handles process scheduling in various ways. Their main task is to select the jobs to be submitted into the system and to decide which process to run.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
두 가지 하드웨어 모드는 무엇인가요?,What are the 2 hardware modes?,커널 모드 및 사용자 모드,kernel mode and user mode,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
PCB란 무엇이며 무엇을 포함하나요?,What is a PCB and what does it have?,프로세스 제어 블록 - 프로세스 상태의 전체 snapshot을 저장합니다.,Process control block - It holds a complete snapshot of the state of the process.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
TCB에는 무엇이 저장되나요?,What is stored in a TCB?,"레지스터
프로그램 카운터
스택 카운터","registers
program counter
stack counter",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
별도의 연쇄란 무엇인가요?,What is separate chaining?,"해시 테이블 충돌 해결에서 각 버킷은 독립적이며 동일한 인덱스를 가진 항목들의 연결된 목록을 가지고 있습니다. 해시 테이블 연산의 시간은 버킷을 찾는 시간(일정한)과 목록 연산의 시간을 더한 값입니다.

좋은 해시 테이블에서는 각 버킷에 0개 또는 1개의 항목이 있고 때로는 2~3개이지만 그 이상인 경우는 드뭅니다. 따라서 이러한 경우에 대해 시간과 공간적으로 효율적인 구조가 선호됩니다. 버킷당 상당히 많은 항목에 대해 효율적인 구조는 필요하지도 않고 바람직하지도 않습니다. 이러한 경우가 자주 발생하는 경우 해싱 함수를 수정해야 합니다.","In hash table conflict resolution, each bucket is independent and has some sort of linked list of entries with the same index. The time for hash table operations is the time to find the bucket (which is constant) plus the time for the list operation.

In a good hash table, each bucket has zero or one entries, and sometimes two or three, but rarely more than that. Therefore, structures that are efficient in time and space for these cases are preferred. Structures that are efficient for a fairly large number of entries per bucket are not needed or desirable. If these cases happen often, the hashing function needs to be fixed.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
오픈 어드레싱이란 무엇인가요?,What is open addressing?,"해시 테이블 충돌 해결에서는 모든 항목 기록이 버킷 배열 자체에 저장됩니다. 새 항목을 삽입해야 할 때, 버킷은 해시된 슬롯부터 시작하여 비어 있는 슬롯이 발견될 때까지 일부 프로브 시퀀스로 진행됩니다. 항목을 검색할 때 버킷은 동일한 시퀀스로 스캔되며, 대상 레코드가 발견되거나 사용되지 않은 배열 슬롯이 발견될 때까지 스캔됩니다. 이는 테이블에 해당 키가 없음을 나타냅니다. ""열린 주소 지정""이라는 이름은 항목의 위치(주소)가 해시 값에 의해 결정되지 않는다는 사실을 의미합니다. (이 방법은 폐쇄 해싱이라고도 하며, 일반적으로 별도의 체인을 의미하는 ""열린 주소 지정""과 혼동해서는 안 됩니다.)","In hash table conflict resolution, all entry records are stored in the bucket array itself. When a new entry has to be inserted, the buckets are examined, starting with the hashed-to slot and proceeding in some probe sequence, until an unoccupied slot is found. When searching for an entry, the buckets are scanned in the same sequence, until either the target record is found, or an unused array slot is found, which indicates that there is no such key in the table. The name ""open addressing"" refers to the fact that the location (""address"") of the item is not determined by its hash value. (This method is also called closed hashing; it should not be confused with ""open hashing"" or ""closed addressing"" that usually mean separate chaining.)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
해시 테이블에서 별도의 체인을 사용하는 가장 긴 체인의 길이는 얼마인가요?,What is the length of the longest chain in a hash table using separate chaining?,"O(1 + 알파) 여기서 알파는 하중 계수, n/m입니다.","O(1 + alpha) where alpha is the load factor, n/m.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"통일된 해싱은 실제로 달성하기 어렵기 때문에, 어떤 훌륭한 대안이 있을까요?","Since uniform hashing is difficult to achieve in practice, what is a great alternative?",이중 해싱,double hashing,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트 단위 연산에서 숫자가 홀수인지 어떻게 테스트할 수 있나요?,How can you test if a number is odd in bitwise operations?,return (x & 1),return (x & 1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
숫자가 비트 단위 연산에서도 짝수인지 어떻게 테스트할 수 있나요?,How can you test if a number is even in bitwise operations?,return (x & 1) == 0,return (x & 1) == 0,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
노드와 그 하위 노드는 어떤 순서로 사전 주문 순회에 참여하나요?,What order of node and its children are involved in a preorder traversal?,"노드
왼쪽 자식
오른쪽 아이","node
leftChild
rightChild",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
노드와 그 하위 노드는 어떤 순서로 정렬된 후행에 관여하나요?,What order of node and its children are involved in a postorder traversal?,"왼쪽 자식
오른쪽 아이
노드","leftChild
rightChild
node",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
노드와 그 하위 노드는 어떤 순서로 순서가 뒤바뀐 탐색에 관여하나요?,What order of node and its children are involved in an inorder traversal?,"왼쪽 자식
노드
오른쪽 아이","leftChild
node
rightChild",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
너비 우선 탐색 트래블의 다른 이름은 무엇인가요?,What is another name for a breadth-first search traversal?,수평 이동.,Level-order traversal.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
코드: 정수 집합 S의 거듭제곱 집합을 계산합니다.,Code: Compute the power set of a set of integers S.,어떻게?,How?,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
엔디안니스의 정식 명칭은 무엇인가요?,What is the proper name for Endianness?,옥텟 순서,octet order,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
옥텟 오더(엔디안니스) 문제는 파일에서 어디에서 발생할 수 있나요?,Where can octet order (Endianness) problems crop up in files?,이진 파일에서는 순서를 선택하는 것이 일관되지 않으면 문제가 없습니다. utf8 또는 ASCII로 인코딩된 파일에는 이 문제가 없습니다.,"In binary files, if you aren't consistent with choosing an order. Files encoded in utf8 or ASCII don't have this issue.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
완전 이진 트리를 정의하고 예를 들어 설명하자면 무엇인가요?,"What defines a complete binary tree, and give an example?",트리의 모든 레벨에서 동일한 수의 노드가 왼쪽에서 오른쪽으로 채워지는 리프 레벨을 제외하고. 배열로 저장된 힙이 하나의 예입니다.,"The same number of nodes at all levels of the tree, except at leaf level where it fills in left to right. A heap stored as an array is an example.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
0 기반 배열이 있는 힙에서 i의 부모는 무엇인가요?,"In a heap, with a 0-based array, what is parent of i?",바닥((i-1)/2),floor((i-1)/2),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
0 기반 배열이 있는 힙에서 i의 왼쪽 자식은 무엇인가요?,"In a heap, with a 0-based array, what is left child of i?",2i + 1,2i + 1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
0 기반 배열이 있는 힙에서 i의 오른쪽 자식은 무엇인가요?,"In a heap, with a 0-based array, what is right child of i?",2i + 2,2i + 2,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
1 기반 배열이 있는 더미에서 i의 오른쪽 자식은 무엇인가요?,"In a heap, with a 1-based array, what is right child of i?",2i + 1,2i + 1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
1 기반 배열이 있는 더미에서 i의 왼쪽 자식은 무엇인가요?,"In a heap, with a 1-based array, what is left child of i?",2i,2i,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
0 기반 배열이 있는 힙에서 i의 부모는 무엇인가요?,"In a heap, with a 0-based array, what is parent of i?",바닥(i/2),floor(i/2),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
마우리 더미의 높이는 얼마인가요?,What is the height of a m-ary heap?,로그 기저 m(n),log base m of n,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2-3-4 트리란 무엇인가요?,What is a 2-3-4 tree?,"2-3-4 트리(2-4 트리라고도 함)는 사전을 구현하는 데 일반적으로 사용되는 자가 균형 데이터 구조입니다. 이 숫자는 자식이 있는 모든 노드(내부 노드)에 2개, 3개 또는 4개의 자식 노드가 있는 트리를 의미합니다:

- 2노드는 하나의 데이터 요소를 가지고 있으며, 내부에 두 개의 자식 노드가 있는 경우;
- 3노드에는 두 개의 데이터 요소가 있으며, 내부에 세 개의 자식 노드가 있는 경우;
- 4노드에는 세 개의 데이터 요소가 있으며, 내부에는 네 개의 자식 노드가 있습니다.","2–3–4 tree (also called a 2–4 tree) is a self-balancing data structure that is commonly used to implement dictionaries. The numbers mean a tree where every node with children (internal node) has either two, three, or four child nodes:

- 2-node has one data element, and if internal has two child nodes;
- 3-node has two data elements, and if internal has three child nodes;
- 4-node has three data elements, and if internal has four child nodes.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
플레이 트리의 모든 연산의 복잡성은 무엇인가요?,What is the complexity of all operations on a splay tree?,"평균적으로 O(로그 n).
최악의 경우 단일 작업 세타(n).","O(log n) on average.
A single operation Theta(n) in the worst case.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
빨강-검정 나무의 최대 높이는 얼마인가요?,What is the maximum height of a red-black tree?,2 로그 n,2 log n,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
b-트리에서는 노드당 몇 명의 아이들이 있나요?,"In a b-tree, how many children are there per node?","루트: 1에서 2t-1 키
non-root: t-1 to 2t-1 keys
t는 최대 100개 또는 그 이상일 수 있습니다.
n개의 키와 n+1명의 아이들이 있습니다.
나뭇잎은 모두 같은 높이입니다.","root: 1 to 2t-1 keys
non-root: t-1 to 2t-1 keys
t could be up to 100, or more.
There are n keys and n+1 children.
Leaves are all the same level.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
b-트리의 최대 차수는 무엇에 따라 달라지나요?,What does the max degree of a b-tree depend on?,저장되는 항목의 수와 디스크 특성에 따른 페이지 크기.,"The number of items being stored, and page size based on disk characteristics.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
b-트리의 데이터는 무엇과 일치하도록 구성되어 있나요?,A b-tree's data is organized to correspond with what?,디스크의 페이지.,Pages on disk.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
b-트리가 어떻게 구성될 수 있는지 예를 들어보세요.,Give an example of how a b-tree might be organized.,"노드당 1024명의 어린이.
루트를 메모리에 저장하세요.
3개의 노드에 액세스하면 1024^3개의 디스크 페이지가 표시됩니다.
4개의 노드에 액세스하면 1024^4개의 디스크 페이지가 표시됩니다.","1024 children per node.
Store root in memory.
3 nodes accessed gets us 1024^3 disk pages.
4 nodes accessed gets us 1024^4 disk pages.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
b-트리를 내려갈 때 규칙은 무엇인가요?,"On descending a b-tree, what's the rule?",절대 최소 노드에 들어가지 마세요.,Never step into a minimal node.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
b-트리에 삽입할 때 규칙은 무엇인가요?,"On insertion in a b-tree, what's the rule?",절대로 전체 노드에 들어가지 마세요.,Never step into a full node.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
압축 트리(big-O)에는 몇 개의 k개의 잎 노드가 있나요?,How many nodes of k leaves are in a compressed trie (big-O)?,압축으로 인해 k개의 잎이 있는 O(k) 노드.,O(k) nodes with k leaves due to compression.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
접미사 트리란 무엇인가요?,What is a suffix tree?,"접미사 트리는 주어진 텍스트의 모든 접미사를 키로, 텍스트 내 위치를 값으로 포함하는 압축 트리입니다. 접미사 트리는 많은 중요한 문자열 작업을 특히 빠르게 구현할 수 있게 해줍니다.

문자열 S의 이러한 트리를 구성하는 데는 S의 길이에 따라 선형적으로 시간과 공간이 소요됩니다. 일단 구성된 후, 여러 작업을 빠르게 수행할 수 있습니다. 예를 들어, S에서 부분 문자열을 찾기, 특정 개수의 실수가 허용되면 부분 문자열을 찾기, 정규 표현식 패턴과 일치하는 부분 문자열을 찾기 등이 있습니다. 접미사 트리는 또한 가장 긴 일반적인 부분 문자열 문제에 대한 최초의 선형 시간 솔루션 중 하나를 제공합니다. 이러한 속도 향상에는 대가가 따릅니다: 문자열의 접미사 트리를 저장하는 것은 일반적으로 문자열 자체를 저장하는 것보다 훨씬 더 많은 공간을 필요로 합니다.","A suffix tree is a compressed trie containing all the suffixes of the given text as their keys and positions in the text as their values. Suffix trees allow particularly fast implementations of many important string operations.

The construction of such a tree for the string S takes time and space linear in the length of S. Once constructed, several operations can be performed quickly, for instance locating a substring in S, locating a substring if a certain number of mistakes are allowed, locating matches for a regular expression pattern etc. Suffix trees also provide one of the first linear-time solutions for the longest common substring problem. These speedups come at a cost: storing a string's suffix tree typically requires significantly more space than storing the string itself.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"간단히 말해서, Selection Sort은 어떻게 작동하나요?","In brief, how does selection sort work?","각 패스에서 이전 최소값을 지나 최소값 항목을 찾고, 이전 최소값 다음으로 가장 왼쪽 위치로 전환하세요.","Find the minimum item on each pass, past the previous minimum, and swap it into the leftmost position after the previous minimum.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Insertion Sort은 언제 n 로그 n 시간 내에 실행될 수 있나요?,When can insertion sort run in n log n time?,Binary Search Tree에 로드합니다. 그런 다음 순서대로 이동합니다.,Load into a binary search tree. Then inorder traversal.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
힙으로 Selection Sort 속도를 높이려면 어떻게 해야 하나요?,How can you speed up selection sort with a heap?,정렬되지 않은 부분을 미니 힙으로 교체하세요. O(log n) 제거를 제공합니다. 전체적으로 n개의 로그 n을 만듭니다.,Replace the unsorted portion with a min-heap. Gives O(log n) removal. Makes n log n overall.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Heap Sort에 적합한 데이터 구조와 나쁜 구조는 무엇인가요?,What data structure is well suited for a heap sort and which is bad?,"배열 - 양호
연결된 목록 - 서투름","Array - good
Linked list - clumsy",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"Merge Sort에 적합한 데이터 구조는 무엇이며, 어떤 것이 괜찮을까요?",What data structure is well suited for a merge sort and which is just okay?,"연결된 목록 - 자연스러운 목록
배열은 제자리에서 사용할 수 없습니다","Linked list - a natural
Array does not allow for in-place",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
피벗할 세그먼트가 큰 경우(무작위 선택이 아닌) 피벗을 찾는 것을 최적화하려면 어떻게 해야 하나요?,How can you optimize finding a pivot when the segment to pivot is large (not random choice)?,세 개의 중앙값을 선택하세요.,Choose a median of three.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
카운팅이란 무엇인가요?,What is counting sort?,"카운팅 정렬은 작은 정수인 키에 따라 객체 모음을 정렬하는 알고리즘, 즉 정수 정렬 알고리즘입니다. 각 키 값이 서로 다른 객체의 수를 세고, 해당 개수에 대한 산술을 사용하여 출력 시퀀스에서 각 키 값의 위치를 결정하는 방식으로 작동합니다. 실행 시간은 항목 수와 최대 키 값과 최소 키 값의 차이가 선형적이므로 키의 변동이 항목 수보다 크게 크지 않은 상황에서만 직접 사용하기에 적합합니다. 그러나 더 큰 키를 더 효율적으로 처리할 수 있는 또 다른 정렬 알고리즘인 래딕스 정렬에서는 하위 루틴으로 자주 사용됩니다.","Counting sort is an algorithm for sorting a collection of objects according to keys that are small integers; that is, it is an integer sorting algorithm. It operates by counting the number of objects that have each distinct key value, and using arithmetic on those counts to determine the positions of each key value in the output sequence. Its running time is linear in the number of items and the difference between the maximum and minimum key values, so it is only suitable for direct use in situations where the variation in keys is not significantly greater than the number of items. However, it is often used as a subroutine in another sorting algorithm, radix sort, that can handle larger keys more efficiently.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
래딕스 종류란 무엇인가요?,What is radix sort?,"Radix 정렬은 동일한 중요한 위치와 값을 공유하는 개별 숫자로 키를 그룹화하여 정수 키로 데이터를 정렬하는 비교 불가능한 정수 정렬 알고리즘입니다. 
래딕스 정렬의 두 가지 분류는 최소 유효 자릿수(LSD) 래딕스 정렬과 최대 유효 자릿수(MSD) 래딕스 정렬입니다. LSD 래딕스 정렬은 정수 표현을 최소 자릿수에서 시작하여 가장 유효한 자릿수로 이동하는 과정을 처리합니다. MSD 래딕스 정렬은 그 반대로 작동합니다.","Radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value. 
Two classifications of radix sorts are least significant digit (LSD) radix sorts and most significant digit (MSD) radix sorts. LSD radix sorts process the integer representations starting from the least digit and move towards the most significant digit. MSD radix sorts work the other way around.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
카운트 정렬 실행 시간은 어떻게 되나요?,What is the counting sort running time?,O(q + n) 여기서 q는 고유 항목의 수입니다. q가 O(n)에 있다면 선형 시간입니다.,"O(q + n) where q is the number of unique items. If q is in O(n), then linear time.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가장 자연스럽게 사용할 수 있는 라디칼은 무엇인가요?,What radix is most natural to use?,2 라디칼의 거듭제곱.,A power of 2 radix.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
IEEE 부동 소수점 번호에 대해 라디우스 정렬은 어떻게 작동하나요?,How would radix sort work for IEEE floating point numbers?,모든 비트를 음수로 바꾸고 정렬한 다음 다시 뒤집습니다.,"Flip all bits for negative numbers, do sort, then flip back.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
래딕스 정렬을 위해 q를 선택하는 방법은 무엇인가요?,How to choose q for radix sort?,"2의 거듭제곱 n 내에서 q를 선택합니다. 통과 횟수가 적을 것을 보장합니다. 가장 좋은 규칙은 다음 2의 거듭제곱 n으로 반올림하는 것입니다.
메모리를 절약하려면 제곱근(n)을 2의 다음 거듭제곱으로 반올림합니다. 패스 수는 두 배입니다.","Choose q within a power of 2 of n. Ensures the number of passes is small. Best rule is n rounded down to the next power of 2.
To save memory, round sqrt(n) down to the next power of 2. Twice as many passes.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
트랩은 어떤 작업에 최적화되어 있나요?,What operations are a treap optimized for?,"- 연합
- 교차점
- 차이","- union
- intersection
- difference",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
데이-스타우트-워런(DSW) 알고리즘은 무엇인가요?,What is the Day–Stout–Warren (DSW) algorithm?,"Day–Stout–Warren (DSW) 알고리즘은 이진 검색 트리의 효율적인 균형을 맞추기 위한 방법입니다. 즉, 이진 검색 트리의 높이를 O(log n) 노드로 줄이는 것입니다. 여기서 n은 총 노드 수입니다. 자체 균형 이진 검색 트리와 달리, 이는 각 작업 동안 점진적으로 수행되는 것이 아니라 주기적으로 수행되므로 많은 작업에서 비용을 상각할 수 있습니다.","The Day–Stout–Warren (DSW) algorithm is a method for efficiently balancing binary search trees — that is, decreasing their height to O(log n) nodes, where n is the total number of nodes. Unlike a self-balancing binary search tree, it does not do this incrementally during each operation, but periodically, so that its cost can be amortized over many operations.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
래딕스는 안정적인가요?,Is radix sort stable?,네.,Yes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
래딕스 정렬의 알고리즘 time complexity는 무엇인가요?,What is the algorithmic time complexity of radix sort?,O(숫자),O(digits),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
모든 비교 기반 정렬은 어떤 복잡성에 의해 제한되나요?,All comparison-based sorting is bounded by what complexity?,오메가(n 로그 n),Omega(n log n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정점 u에서 정점 v로 향하는 모든 방향의 간선 uv에 대해 순서대로 u가 v보다 먼저 오는 방향 그래프의 선형 순서를 뭐라고 부르나요?,"What do you call a linear ordering of a directed graph of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering?",위상 정렬,Topological sort,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
위상 정렬을 수행하는 데 좋은 방법은 무엇인가요?,What is a good method for performing a topological sort?,"1. 각 노드에 대한 차수 내 계산. O(v + e)
2. 0을 통과하여 대기열에 추가하세요.
3. 대기열에 있는 각 항목에 대해 각 연결을 살펴보고, 각 항목의 차수가 0에 도달하면 대기열에 추가하고 반복합니다.","1. Calculate in-degree for each node. O(v + e)
2. Go through 0s, add to queue.
3. For each item in queue, look at each connection, and decrement in-degree of each, if they got to 0, add to queue, repeat.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프의 모든 노드에 걸쳐 있는 가능한 트리는 몇 개인가요?,How many possible trees are there that span all nodes in a graph?,4^n,4^n,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 행렬에서 Prim 알고리즘의 time complexity는 얼마인가요?,What is the time complexity of Prim's algorithm on an adjacency matrix?,O(v^2),O(v^2),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 목록과 이진 힙에서 Prim 알고리즘의 time complexity는 얼마인가요?,What is the time complexity of Prim's algorithm on an adjacency list and a binary heap?,"O(로그 v)
다음에서 파생됨:
O((e + v) log v)","O(e log v)
derived from:
O((e + v) log v)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 목록과 피보나치 힙에서 Prim 알고리즘의 time complexity는 얼마인가요?,What is the time complexity of Prim's algorithm on an adjacency list and a Fibonacci heap?,O(e + v log v),O(e + v log v),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
크루스칼 알고리즘의 time complexity는 얼마인가요?,What is the time complexity of Kruskal's algorithm?,"O(E 로그 V)
또는
O(e log e + e α(v) + v)","O(E log V)
or
O(e log e + e α(v) + v)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
크루스칼의 알고리즘은 무엇인가요?,What is Kruskal's algorithm?,"크루스칼의 알고리즘은 최소 스패닝 트리 알고리즘으로, 숲의 두 트리를 연결하는 최소 가중치의 엣지를 찾습니다. 이 알고리즘은 연결된 가중치 그래프에 대해 각 단계에서 비용 증가 호를 추가하는 최소 스패닝 트리를 찾기 때문에 그래프 이론에서 탐욕스러운 알고리즘입니다. 즉, 트리의 모든 엣지의 총 가중치가 최소화되는 모든 정점을 포함하는 트리를 구성하는 엣지의 하위 집합을 찾습니다. 그래프가 연결되지 않은 경우 최소 스패닝 포레스트(연결된 각 구성 요소에 대한 최소 스패닝 트리)를 찾습니다.","Kruskal's algorithm is a minimum-spanning-tree algorithm which finds an edge of the least possible weight that connects any two trees in the forest. It is a greedy algorithm in graph theory as it finds a minimum spanning tree for a connected weighted graph adding increasing cost arcs at each step. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. If the graph is not connected, then it finds a minimum spanning forest (a minimum spanning tree for each connected component).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
연결된 구성 요소의 수를 어떻게 찾을 수 있나요?,How can you find the number of connected components?,"각 노드에 대해:
  노드가 아직 방문하지 않은 경우 구성 요소 수를 늘리고 DFS를 수행합니다.","For each node:
  if node not yet visited, increment component count and do DFS.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DFS를 사용하여 위상 정렬을 어떻게 얻을 수 있나요?,How can you get a topological sort with DFS?,"DFS를 수행하고 각 노드가 완료로 표시되면 노드를 목록에 추가합니다.
목록을 뒤집으세요.","Do a DFS, and when each node is being marked as complete, add node to a list.
Reverse the list.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DFS와의 주기를 어떻게 확인할 수 있나요?,How can you check for a cycle with DFS?,"각 이웃 노드에 대해:
방문한 것으로 표시되지 않고 부모가 아닌 경우 DFS
그렇지 않으면 주기입니다","for each neighbor node:
if not marked as visited (and is not parent) then DFS
else it's a cycle",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프의 강하게 연결된 구성 요소를 어떻게 얻을 수 있나요?,How can you get the strongly connected components of a graph?,"1. DFS - 각 노드의 완료 시간 계산
2. 그래프의 가장자리를 뒤집습니다
3. 역 그래프의 노드에서 완료 시간의 역순으로 DFS를 호출합니다.","1. DFS - calculate the finish times for each node
2. Reverse the edges in the graph
3. Call DFS on nodes in reverse graph in reverse order of finishing times.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 행렬로 표시된 방향 그래프의 가장자리를 어떻게 되돌리나요?,How do you reverse the edges in a directed graph represented as an adjacency matrix?,"행렬을 전치하면 [i, j]가 [j, i]가 됩니다","Transpose the matrix, so [i, j] becomes [j, i]",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DAG에서 가장 짧은 경로를 어떻게 찾을 수 있나요?,How can you find the shortest path on a DAG?,"1. 위상 정렬
2. 위상 정렬을 따르고 편안한 가장자리를 유지합니다","1. Topological sort
2. follow the topological sort, relaxing edges",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가중 DAG에서 가장 긴 경로를 찾는 방법은 무엇인가요?,How to find the longest path on a weighted DAG?,"1. 모든 모서리를 음의 무게로 설정하세요.
2. 위상 정렬 
3. 위상 정렬을 따르고 편안한 가장자리를 유지합니다","1. Set all edges to their negative weight.
2. Topological sort 
3. follow the topological sort, relaxing edges",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프의 지름은 얼마인가요?,What is the diameter of a graph?,"가장 먼 노드 중 가장 짧은 경로입니다. 즉, 정점 쌍 사이의 가장 큰 거리입니다. 그래프의 지름을 구하려면 먼저 각 정점 쌍 사이의 최단 경로를 구합니다. 이러한 경로 중 가장 long long는 그래프의 지름입니다.","The shortest path of the farthest nodes. That is, it is the greatest distance between any pair of vertices. To find the diameter of a graph, first find the shortest path between each pair of vertices. The greatest length of any of these paths is the diameter of the graph.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
어떤 조건에서 지크스트라의 알고리즘을 사용할 수 없나요?,Under what condition can you not use Djikstra's algorithm?,그래프에 음의 간선이 포함된 경우. 무한히 순환하는 사이클을 일으킬 수 있습니다.,When the graph contains a negative edge. Can cause a cycle that will be traversed infinitely.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"간단히 말해서, 크루스칼의 알고리즘은 어떻게 작동하나요?","In plain words, how does Kruskal's algorithm work?","1. 집합 T를 생성하고 결과를 위한 목록 만들기
2. G의 모든 간선 목록 만들기
3. 가장자리를 최소부터 최대까지 무게별로 정렬합니다.
4. 모서리를 정렬된 순서대로 반복합니다.
5. 각 간선마다 u와 v가 T에 속하지 않으면 u와 v를 T에 더하고, 결과 목록에 간선을 추가하세요.","1. Create a set T and list for result
2. Make a list of all edges in G
3. Sort edges by weight, from least to greatest.
4. Iterate edges in sorted order.
5. For each edge, if u and v are not in T, add u and v to T, and add edge to result list.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가장 동적인 프로그래밍 문제는 무엇으로 표현할 수 있나요?,What can most dynamic programming problems be expressed as?,DAG에서 최단 경로를 찾습니다. 이렇게 공식화하면 선형 또는 선형 산술 시간 내에 해결할 수 있습니다.,Finding the shortest path in a DAG. Formulating it this way ensures you can solve it in linear or linearithmic time.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
텍스트 정당화 문제에서 선의 불량성을 측정하는 데 사용할 수 있는 지표는 무엇인가요?,What metric can you use to measure the badness of a line in a text justification problem?,"(페이지 너비 - 텍스트 너비)^3
선의 심각도의 합을 최소화하세요.","(page width - text width)^3
Minimize the sum of the badness of the lines.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프가 2색인지 어떻게 알 수 있나요?,How can you tell if a graph is 2-colorable?,이분법적이라면. 모든 나무는 이분법적입니다.,If it's bipartite. All trees are bipartite.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
재귀 중에 베이스 케이스가 너무 많을 때 그것을 뭐라고 부르나요?,What is it called when you have too many base cases in your recursion?,팔 길이 재귀,arm's length recursion,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
재귀의 기본 사례는 무엇인가요?,What is the base case of a recursion?,가장 작은 하위 문제에 대한 해결책을 제시하는 데 필요한 코드입니다.,The code required to give the solution to the smallest subproblem.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n 선택 k의 공식은 무엇인가요?,What is the formula for n choose k?,n! / k!(n - k)!,n! / k!(n - k)!,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동적 프로그래밍은 어떤 종류의 문제에 가장 적합한가요?,What kinds of problems is dynamic programming best suited for?,"- 왼쪽에서 오른쪽 시퀀스 최적화(strings, 배열로서의 트리 노드, 순열)
- 결과를 저장하면서 모든 가능성을 검색하여 다시 계산하지 않도록 합니다","- optimizing left to right sequences (strings, tree nodes as array, permutations)
- search all possibilities while storing results to avoid recomputing",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n 선택이란 무엇인가요?,What is n choose n?,1,1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n 선택 1이란 무엇인가요?,What is n choose 1?,n,n,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n 선택 0이란 무엇인가요?,What is n choose 0?,1,1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
플로이드-워샬 알고리즘이란 무엇인가요?,What is the Floyd-Warshall algorithm?,플로이드-워샬 알고리즘은 양의 또는 음의 에지 가중치를 가진 가중 그래프에서 최단 경로를 찾기 위한 동적 프로그래밍 알고리즘입니다(음의 사이클은 없지만).,The Floyd–Warshall algorithm is a dynamic programming algorithm for finding shortest paths in a weighted graph with positive or negative edge weights (but with no negative cycles).,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
베이즈의 규칙(공식)은 무엇인가요?,What is the Bayes' rule (formula)?,P(A|B) = (P(B|A) * P(A)) / P(B),P(A|B) = (P(B|A) * P(A)) / P(B),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
P(A|B)를 어떻게 계산하시겠습니까?,How would you calculate P(A|B)?,P(A and B) / P(B),P(A and B) / P(B),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
P(A와 B)를 어떻게 계산하시겠습니까?,How would you calculate P(A and B)?,P(A) * P(B),P(A) * P(B),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
P(A 또는 B)를 어떻게 계산하시겠습니까?,How would you calculate P(A or B)?,P(A) + P(B) - P(AB),P(A) + P(B) - P(AB),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
P(A와 B)를 쓰는 또 다른 방법은 무엇인가요?,What's another way to write P(A and B)?,P(AB),P(AB),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
마르코프 연쇄란 무엇인가요?,What is a Markov chain?,마르코프 연쇄는 확률로 표시된 전이로 연결된 상태로 구성됩니다. 상태는 반드시 단어일 필요는 없습니다. 어떤 상태든 나타낼 수 있습니다.,A Markov chain consists of states linked by transitions labeled with probabilities. The states do not have to be words. They could represent any state.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이진 검색을 사용하여 제곱근(n)을 계산하는 함수를 작성하세요.,Write a function that computes the sqrt(n) using binary search.,어떻게?,How?,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
What is P(A|A)?,What is P(A|A)?,1,1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n개의 버킷을 해싱할 때 충돌이 예상되는 항목은 몇 개인가요?,At how many items should you expect a collision when hashing among n buckets?,sqrt(n)에서 확률은 1/2입니다,At sqrt(n) the probability is 1/2,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
What is n/n^2?,What is n/n^2?,1/n,1/n,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
P(! B )란 무엇인가요?,What is the P( ! B ) ?,1 - P(B),1 - P(B),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
3번의 플립 중 최소 1H의 확률은 얼마인가요?,What is the probability of at least 1 H in 3 flips?,1 - P(TTT) = 1 - 1/8 = 7/8,1 - P(TTT) = 1 - 1/8 = 7/8,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
공정한 동전을 사용하면 4번의 동전 던지기에서 정확히 1H를 얻을 확률은 얼마인가요?,"With a fair coin, what is the probability of getting exactly 1 H in 4 flips?",P(HTTT) + P(THTT) + P(TTHT) + P(TTTH) = 1/16 + 1/16 + 1/16 + 1/16 = 4/16 = 1/4,P(HTTT) + P(THTT) + P(TTHT) + P(TTTH) = 1/16 + 1/16 + 1/16 + 1/16 = 4/16 = 1/4,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
공정한 동전을 사용하면 n번의 플립에서 정확히 k H를 얻을 확률은 얼마인가요?,"With a fair coin, what is the probability of getting exactly k H in n flips?",(n choose k)/2^n,(n choose k)/2^n,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"대부분의 의사 결정 문제(P, Exp, R, 외부 R)는 어떤 영역에 있나요?","In what domain are most decision problems (P, Exp, R, outside R)?",외부 R - 계산할 수 없습니다,Outside R - they are uncomputable,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
문제가 NP-난해하다는 것은 무엇을 의미하나요?,What does it mean when a problem is NP-Hard?,NP의 다른 어떤 문제만큼이나 어렵습니다. NP-Hard의 모든 문제 Y가 X로 축소되면 문제 X는 NP-Hard입니다.,It is as hard as any other problem in NP. A problem X is NP-Hard if every problem Y in NP-Hard reduces to X.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
문제 A를 문제 B로 축소한다는 것은 무엇을 의미하나요?,What does it mean to reduce a problem A to a problem B?,입력을 알고리즘 A로 변환하여 알고리즘 B로 변환하면 A에 대한 답을 얻을 수 있습니다.,"Converting the input to algorithm A into input into algorithm B, providing an answer for A.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"""3D 매칭""은 NP-완전인가요?","Is ""3-D matching"" NP-Complete?",네.,Yes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"""트리플 컬러링은 그래프"" NP-완전인가요?","Is ""triple coloring a graph"" NP-Complete?",네.,Yes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"""두 가지 색칠은 그래프""는 NP-완전인가요?","Is ""two coloring a graph"" NP-Complete?",아니요.,No,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"""부분 집합 합""이 NP-완전인가요?","Is ""subset sum"" NP-Complete?",네.,Yes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"""빈 패킹""은 NP-완전인가요?","Is ""bin packing"" NP-Complete?",네.,Yes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"""정점 덮개""는 NP-완전인가요?","Is ""vertex cover"" NP-Complete?",네.,Yes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"""세트 커버""는 NP-완전인가요?","Is ""set cover"" NP-Complete?",네.,Yes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
NP-완전 문제 몇 가지를 말해보세요.,Name some NP-Complete problems.,"- tsp
- 배낭 문제(decision 문제)
- 만족 가능성
- 3D 매칭
- 삼색화
- 부분 합
- 직사각형 포장
- 쓰레기통 포장
- 정점 덮개
- 표지 설정","- tsp
- knapsack problem (decision problem)
- satisfiability
- 3D matching
- tricoloring
- subset sum
- rectangle packing
- bin packing
- vertex cover
- set cover",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
대략적인 여행 세일즈맨을 하는 한 가지 방법은 무엇인가요?,What is one way of doing approximate traveling salesman?,"정점을 루트로 선택하세요.
MST를 구축하세요.
사전 주문 트래버스를 수행하고 노드를 H에 저장합니다.
반환 H (해밀토니안 사이클)","Select a vertex as root.
Build a MST.
Do a preorder traversal, store nodes in H.
Return H (a Hamiltonian cycle)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
GC 멈춤으로 고통받는 것은 무엇인가요?,What suffers from GC pauses?,"- 서버와 같은 장기적인 프로세스
- 비디오 처리와 같은 실시간 애플리케이션","- long-running processes like servers
- real-time applications like video processing",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
링크된 목록으로 LRU 캐시를 구현하려면 어떻게 해야 하나요?,How can an LRU cache be implemented with a linked list?,"항목에 접근하면 목록의 맨 앞으로 이동합니다.
후행 항목은 새 항목으로 덮어쓰거나 제거할 수 있습니다.","When an item is accessed, it moves to the head of the list.
The trailing items can be overwritten with new items, or removed.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DRAM 셀 데이터는 얼마나 자주 다시 작성되나요?,How often are DRAM cells data rewritten?,매 10ms마다.,Every 10ms.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스카이레이크 건축은 어떤 모습인가요?,What does Skylake architecture look like?,"스카이레이크: 

L1 데이터 캐시 = 32KB, 64 B/라인, 8-WAY. 캐시 웨이당 64개의 캐시 라인
L1 명령어 캐시 = 32KB, 64 B/라인, 8-WAY. 캐시 웨이당 64개의 캐시 라인
L2 캐시 = 256KB, 64B/라인, 4-WAY
L3 캐시 = 8MB, 64B/라인, 16-WAY","Skylake: 

L1 Data cache = 32 KB, 64 B/line, 8-WAY. 64 cache lines per cache way
L1 Instruction cache = 32 KB, 64 B/line, 8-WAY. 64 cache lines per cache way
L2 cache = 256 KB, 64 B/line, 4-WAY
L3 cache = 8 MB, 64 B/line, 16-WAY",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
TLB란 무엇인가요?,What is a TLB?,"번역 룩어사이드 버퍼(TLB)는 메모리 관리 하드웨어가 가상 주소 번역 속도를 향상시키기 위해 사용하는 캐시입니다. 대부분의 데스크톱, 노트북 및 서버 프로세서는 메모리 관리 하드웨어에 하나 이상의 TLB를 포함하며, 이는 거의 항상 호출되거나 분할된 가상 메모리를 사용하는 모든 하드웨어에 존재합니다.","A translation lookaside buffer (TLB) is a cache that memory management hardware uses to improve virtual address translation speed. The majority of desktop, laptop, and server processors includes one or more TLBs in the memory management hardware, and it is nearly always present in any hardware that utilizes paged or segmented virtual memory.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
직접 매핑 또는 집합 연관 캐시에서 캐시 크기의 특별한 점은 무엇인가요?,"In a direct mapped or set associative cache, what is special about the cache size?",주 메모리는 페이지로 나뉘며 메모리 페이지는 캐시 웨이 크기에 직접 매핑됩니다. 따라서 캐시 페이지의 항목은 8방향 연관 캐시의 8가지 캐시 웨이 중 하나에 매핑할 수 있습니다. 직접 매핑된 캐시에는 캐시 웨이가 하나만 있지만 동일한 방식으로 작동합니다.,"Main memory is divided into pages, and a memory page maps directly to the cache way size. So an item in a cache page can be mapped to any one of 8 cache ways in an 8-way associative cache. A direct mapped cache simply has one cache way, but it works the same way.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SHA1은 몇 비트를 생성하나요?,How many bits does a SHA1 produce?,160,160,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SHA2와 SHA3는 몇 비트를 생성하나요?,How many bits does a SHA2 and SHA3 produce?,224에서 512까지,224 to 512,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
우리가 항상 압축에서 찾고 있는 것은 글자인가요?,Is it always letters we are looking for in compression?,"아니요. 거의요.
우리는 문자가 아닌 이산 기호를 압축하려고 합니다. 단어가 몇 개 있다면 기호가 될 수 있습니다.
우리는 가장 긴 기호 사슬과 가장 낮은 엔트로피를 균형 있게 맞추려고 노력합니다.","No. Hardly.
We are looking to compress discrete symbols, not letters. If we have a few words, they could be symbols.
We try to balance longest chains of symbols and the lowest entropy.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Zopfli?,What is Zopfli?,"Zopfli는 데이터를 DEFLATE, gzip, zlib 형식으로 인코딩하는 데이터 압축 소프트웨어입니다. 다른 DEFLATE/zlib 구현보다 더 높은 압축을 달성하지만, 압축을 수행하는 데 훨씬 더 오랜 시간이 걸립니다. 이 소프트웨어는 2013년 2월에 Google에 의해 처음 출시되었습니다.","Zopfli is data compression software that encodes data into DEFLATE, gzip and zlib formats. It achieves higher compression than other DEFLATE/zlib implementations, but takes much longer to perform the compression. It was first released in February 2013 by Google.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
중국의 나머지 정리는 무엇인가요?,What is the Chinese remainder theorem?,"정수 n의 나눗셈의 나머지를 여러 정수로 알고 있다면, 나눗셈이 쌍대 동치라는 조건 하에서 n의 나눗셈의 나머지를 이 정수들의 곱으로 유일하게 결정할 수 있습니다.","If one knows the remainders of the division of an integer n by several integers, then one can determine uniquely the remainder of the division of n by the product of these integers, under the condition that the divisors are pairwise coprime.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2s 보체 양의 정수를 음수로 어떻게 변경하나요?,How do you change a 2s complement positive integer into a negative one?,모든 비트를 뒤집고 +1,Flip all bits and + 1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2s 보체 음의 정수를 양의 정수로 어떻게 변경하나요?,How do you change a 2s complement negative integer into a positive one?,모든 비트를 뒤집고 +1(반대 방향으로 가는 것과 동일),Flip all bits and + 1 (same as going the other way),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스택은 어느 방향으로 성장하나요?,Which way does the stack grow?,낮은 메모리 주소까지.,Down to lower memory addresses.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OO에서 다형성이란 무엇인가요?,What is polymorphism in OO?,"OO의 속성으로, 클래스에 따라 추상화 작업을 다양한 방식으로 수행할 수 있지만 인터페이스를 공유할 수 있습니다.
또한 이름은 같지만 서명이 다른 여러 메서드를 의미할 수도 있습니다.","A property of OO in which an abstraction operation may be performed in different ways in different classes, but share an interface.
Also can mean multiple methods of the same name but different signature.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OO의 4가지 주요 원칙은 무엇인가요?,What are the 4 main tenets of OO?,"추상화
다형성
상속 
캡슐화

파이(acronym)","Abstraction
Polymorphism
Inheritance 
Encapsulation

a pie (acronym)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동적 바인딩이란 무엇인가요?,What is dynamic binding?,"동적 바인딩, 또는 동적 디스패치는 런타임에 프로시저 호출을 특정 코드 시퀀스(메소드)에 연결하는 과정입니다. 동적 바인딩은 레이트 바인딩 또는 런타임 바인딩이라고도 합니다. 동적 바인딩은 객체 지향 프로그래밍 개념으로 다형성 및 상속과 관련이 있습니다.","Dynamic binding, also called dynamic dispatch, is the process of linking procedure call to a specific sequence of code (method) at run-time. Dynamic binding is also known as late binding or run-time binding. Dynamic binding is an object oriented programming concept and it is related with polymorphism and inheritance.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
패키지란 무엇인가요?,What is a package?,클래스 그룹이 함께 묶여 있습니다.,A group of classes bundled together.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OO에서 인터페이스란 무엇인가요?,What is an interface in OO?,추상적인 데이터 유형과 유사하지만 단순히 클래스의 예상 동작을 정의할 뿐 구현을 제안하지는 않습니다.,"Similar to an abstract data type, but simply defines the expected behaviors of a class, but does not suggest an implementation.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프레임워크란 무엇인가요?,What is a framework?,일반화된 문제에 대한 일반적인 해결책을 구현하는 재사용 가능한 소프트웨어입니다. 문제 도메인의 근접 모델로 시간을 절약하고 구현자가 코딩한 세부 정보로 100%에 도달할 수 있습니다.,A reusable piece of software that implements a generic solution to a generalized problem. It saves time by being a close model of the problem domain and can reach 100% with details coded by the implementer.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
훅이란 무엇인가요?,What are hooks?,프레임워크의 일부는 호출되지만 아무것도 하지 않고 필요할 때 구현이 필요한 부분입니다.,"The portions of a framework that are called, but do nothing and require implementation when needed.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
서버란 무엇인가요?,What is a server?,다른 프로그램이 연결될 수 있도록 서비스를 제공하는 프로그램입니다.,A program that provides a service for other programs to connect to it.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
OCL이란 무엇인가요?,What is an OCL?,객체 제약 언어. 소프트웨어 모듈에서 제약 조건을 공식적으로 지정하도록 설계된 사양 언어입니다. OCL 표현식은 참으로 유지되어야 하는 시스템에 대한 논리적 사실을 지정합니다.,Object constraint language. A specification language designed to formally specify constraints in software modules. An OCL expression specifies a logical fact about the system that must remain true.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
책임 사슬 패턴이란 무엇인가요?,What is the Chain of Responsibility pattern?,요청을 처리할 수 있는 두 개 이상의 객체를 제공하여 요청 발신자를 수신자와 연결하지 않도록 합니다. 수신 객체를 체인으로 연결하고 객체가 요청을 처리할 때까지 체인을 따라 전달합니다.,Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
명령 패턴이란 무엇인가요?,What is the Command pattern?,"요청을 객체로 캡슐화하여 다양한 요청, 대기열 또는 로그 요청을 가진 클라이언트를 매개변수화하고 되돌릴 수 없는 작업을 지원할 수 있습니다.","Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
요청을 처리할 수 있는 두 개 이상의 객체를 제공하여 요청 발신자를 수신자와 연결하지 않는 디자인 패턴은 무엇인가요?,What design pattern avoids coupling the sender of a request to its receiver by giving more than one object a chance to handle the request?,책임의 사슬,Chain of Responsibility,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
요청을 객체로 캡슐화하여 다양한 요청을 가진 클라이언트를 매개변수화할 수 있는 디자인 패턴은 무엇인가요?,"What design pattern encapsulates a request as an object, thereby letting you parameterize clients with different requests?",명령 패턴,Command pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인터프리터 패턴이란 무엇인가요?,What is the Interpreter pattern?,"언어가 주어졌을 때, 해당 언어의 문법에 대한 표현과 그 표현을 사용하여 해당 언어의 문장을 해석하는 해석기를 정의하세요.","Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
언어에 주어진 디자인 패턴 중 문법에 대한 표현과 해당 표현을 사용하여 해당 언어의 문장을 해석하는 인터프리터를 정의하는 것은 무엇인가요?,"What design pattern, given a language, defines a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language?",인터프리터 패턴,Interpreter pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
반복 패턴이란 무엇인가요?,What is the Iterator pattern?,집계 객체의 기본 표현을 노출하지 않고 순차적으로 요소에 액세스할 수 있는 방법을 제공합니다.,Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
집합 객체의 기본 표현을 노출하지 않고 순차적으로 요소에 액세스할 수 있는 방법을 제공하는 디자인 패턴은 무엇인가요?,What design pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation?,반복자 패턴,Iterator pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
중재자 패턴이란 무엇인가요?,What is the Mediator pattern?,"객체 집합이 상호 작용하는 방식을 캡슐화하는 객체를 정의합니다. 객체가 서로를 명시적으로 참조하지 않도록 하여 느슨한 결합을 촉진하고, 객체 간의 상호 작용을 독립적으로 변경할 수 있도록 합니다.",Defines an object that encapsulates how a set of objects interact. Promotes loose coupling by keeping objects from referring to each other explicitly and it lets you vary their interactions independently.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
객체 집합이 상호 작용하는 방식을 캡슐화하는 객체를 정의하는 디자인 패턴은 무엇인가요?,What design pattern defines an object that encapsulates how a set of objects interact?,중재자 패턴,Mediator pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메멘토 패턴이란 무엇인가요?,What is the Memento pattern?,캡슐화를 위반하지 않고 객체의 내부 상태를 캡처하고 외부화하여 객체가 나중에 이 상태로 복원될 수 있도록 하세요.,"Without violating encapsulation, capture and externalize an object's internal state so that the object can be restore to this state later.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
물체의 내부 상태를 포착하고 외부화하여 나중에 이 상태로 복원할 수 있도록 하는 디자인 패턴은 무엇인가요?,What design pattern captures and externalize an object's internal state so that the object can be restore to this state later?,메멘토 패턴,Memento pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
옵저버 패턴이란 무엇인가요?,What is the Observer pattern?,"객체 간의 일대일 종속성을 정의하여, 하나의 객체가 상태를 변경하면 모든 종속 변수가 자동으로 통지되고 업데이트됩니다.","Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
객체 간의 일대일 종속성을 정의하여 하나의 객체가 상태를 변경하면 모든 종속 변수가 자동으로 통지되고 업데이트되도록 하는 디자인 패턴은 무엇인가요?,"What design pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically?",관찰자 패턴,Observer pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
주 패턴은 무엇인가요?,What is the State pattern?,객체의 내부 상태가 변경될 때 동작을 변경할 수 있습니다. 객체가 클래스를 변경하는 것처럼 보입니다.,Allows an object to alter its behavior when its internal state changes. The object will appear to change its class.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
물체의 내부 상태가 변할 때 동작을 변경할 수 있는 디자인 패턴은 무엇인가요?,What design pattern allows an object to alter its behavior when its internal state changes?,상태 패턴,State pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
전략 패턴이란 무엇인가요?,What is the Strategy pattern?,알고리즘 패밀리를 정의하고 각 알고리즘을 캡슐화하여 상호 호환되도록 합니다. 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있습니다.,"Defines a family of algorithms, encapsulates each one, and makes them interchangeable. Lets the algorithm vary independently from clients that use it.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"알고리즘 패밀리를 정의하고, 각 알고리즘을 캡슐화하여 상호 호환 가능하게 하며, 알고리즘을 사용하는 클라이언트와 독립적으로 다르게 만드는 디자인 패턴은 무엇인가요?","What design pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable, and lets the algorithm vary independently from clients that use it?",전략 패턴,Strategy pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
템플릿 메서드 패턴이란 무엇인가요?,What is the Template Method pattern?,작업에서 알고리즘의 골격을 정의하고 몇 가지 단계를 하위 클래스로 연기합니다. 하위 클래스는 알고리즘의 구조를 변경하지 않고도 알고리즘의 특정 단계를 재정의할 수 있습니다.,"Defines the skeleton of an algorithm in an operation, deferring some steps to subclasses. Lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
작업에서 알고리즘의 골격을 정의하는 설계 패턴은 하위 클래스로 몇 가지 단계를 미룰 수 있나요?,"What design pattern defines the skeleton of an algorithm in an operation, deferring some steps to subclasses?",템플릿 메서드 패턴,Template Method pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
방문자 패턴이란 무엇인가요?,What is the Visitor pattern?,객체 구조의 요소에 대해 수행할 작업을 나타냅니다. 해당 작업이 수행되는 요소의 클래스를 변경하지 않고 새 작업을 정의할 수 있습니다.,Represents an operation to be performed on the elements of an object structure. Lets you define a new operation without changing the classes of the elements on which it operates.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"객체 구조의 요소에 대해 수행해야 하는 작업을 나타내며, 해당 작업이 수행되는 요소의 클래스를 변경하지 않고 새로운 작업을 정의할 수 있는 디자인 패턴은 무엇인가요?",What design pattern represents an operation to be performed on the elements of an object structure and lets you define a new operation without changing the classes of the elements on which it operates?,방문자 패턴,Visitor pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
어댑터 패턴이란 무엇인가요?,What is the Adapter pattern?,클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환합니다. 호환되지 않는 인터페이스로 인해 그렇지 않은 클래스는 함께 작동하도록 합니다.,Converts the interface of a class into another interface clients expect. Lets classes work together that couldn't otherwise because of incompatible interfaces.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환하는 디자인 패턴은 무엇인가요?,What design pattern converts the interface of a class into another interface clients expect?,어댑터 패턴,Adapter pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
브리지 패턴이란 무엇인가요?,What is the Bridge pattern?,추상화를 구현에서 분리하여 두 추상화가 독립적으로 변할 수 있도록 합니다.,Decouples an abstraction from its implementation so that the two can vary independently.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
추상화를 구현에서 분리하여 두 가지가 독립적으로 달라질 수 있도록 하는 디자인 패턴은 무엇인가요?,What design pattern decouples an abstraction from its implementation so that the two can vary independently?,다리 패턴,Bridge pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
복합 패턴이란 무엇인가요?,What is the Composite pattern?,객체를 트리 구조로 구성하여 부분 전체 계층을 나타냅니다. 클라이언트가 개별 객체와 객체의 구성을 균일하게 처리할 수 있습니다.,Compose objects into tree structures to represent part-whole hierarchies. Lets clients treat individual objects and compositions of objects uniformly.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
부분 전체 계층 구조를 나타내기 위해 객체를 트리 구조로 구성하는 디자인 패턴은 무엇인가요?,What design pattern composes objects into tree structures to represent part-whole hierarchies?,복합 패턴,Composite pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
데코레이터 패턴이란 무엇인가요?,What is the Decorator pattern?,객체에 동적으로 추가 책임을 부여합니다. 기능을 확장하기 위해 하위 분류에 대한 유연한 대안을 제공합니다.,Attaches additional responsibilities to an object dynamically. Provides a flexible alternative to sub-classing for extending functionality.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
객체에 동적으로 추가적인 책임을 부여하고 기능 확장을 위한 하위 분류에 유연한 대안을 제공하는 디자인 패턴은 무엇인가요?,What design pattern attaches additional responsibilities to an object dynamically and provides a flexible alternative to sub-classing for extending functionality?,장식 패턴,Decorator pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파사드 패턴이란 무엇인가요?,What is the Facade pattern?,하위 시스템의 인터페이스 세트에 통합 인터페이스를 제공합니다. 하위 시스템을 더 쉽게 사용할 수 있도록 고급 인터페이스를 정의합니다.,Provides a unified interface to a set of interfaces in a subsystem. Defines a high-level interface that makes the subsystem easier to use.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
서브시스템의 인터페이스 세트에 통합 인터페이스를 제공하고 서브시스템을 더 쉽게 사용할 수 있는 고급 인터페이스를 정의하는 디자인 패턴은 무엇인가요.,What design pattern provides a unified interface to a set of interfaces in a subsystem and defines a high-level interface that makes the subsystem easier to use.,외관 패턴,Facade pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
플라이급 패턴이란 무엇인가요?,What is the Flyweight pattern?,공유를 사용하여 많은 세분화된 객체를 효율적으로 지원합니다.,Uses sharing to support large numbers of fine-grained objects efficiently.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
많은 수의 세밀한 객체를 효율적으로 지원하기 위해 공유를 사용하는 디자인 패턴은 무엇인가요?,What design pattern uses sharing to support large numbers of fine-grained objects efficiently?,플라이급 패턴,Flyweight pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프록시 패턴이란 무엇인가요?,What is the Proxy pattern?,다른 객체에 대한 접근을 제어할 수 있는 대리자 또는 자리 표시자를 제공합니다.,Provides a surrogate or placeholder for another object to control access to it.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
다른 객체에 대한 접근을 제어하기 위해 대리자 또는 플레이스홀더를 제공하는 디자인 패턴은 무엇인가요?,What design pattern provides a surrogate or placeholder for another object to control access to it?,프록시 패턴,Proxy pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
추상 공장 패턴이란 무엇인가요?,What is the Abstract Factory pattern?,구체적인 클래스를 지정하지 않고도 관련되거나 종속된 객체의 패밀리를 생성할 수 있는 인터페이스를 제공합니다.,Provides an interface for creating families of related or dependent objects without specifying their concrete class.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
구체적인 클래스를 지정하지 않고 관련되거나 종속된 객체의 패밀리를 만들 수 있는 인터페이스를 제공하는 디자인 패턴은 무엇인가요?,What design pattern provides an interface for creating families of related or dependent objects without specifying their concrete class?,추상 공장 패턴,Abstract Factory pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
빌더 패턴이란 무엇인가요?,What is the Builder pattern?,복잡한 객체의 구성과 그 표현을 분리하여 동일한 구성 프로세스가 서로 다른 표현을 만들 수 있도록 합니다.,"Separates the construction of a complex object from its representation, so the same construction process can create different representations.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"복잡한 객체의 구성과 표현을 구분하는 디자인 패턴은 무엇이며, 동일한 구성 프로세스가 서로 다른 표현을 만들 수 있을까요?","What design pattern separates the construction of a complex object from its representation, so the same construction process can create different representations?",빌더 패턴.,Builder pattern.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
공장 방식 패턴이란 무엇인가요?,What is the Factory Method pattern?,"(기술적으로는 관용구입니다)
객체를 만들기 위한 인터페이스를 정의하지만 하위 클래스가 인스턴스화할 클래스를 결정할 수 있도록 합니다. 클래스가 인스턴스화를 하위 클래스로 연기하도록 합니다.","(Technically it's an idiom)
Defines an interface for creating an object, but lets subclasses decide which class to instantiate. Lets a class defer instantiation to subclasses.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
객체를 만들기 위한 인터페이스를 정의하지만 하위 클래스가 인스턴스화할 클래스를 결정할 수 있도록 하는 디자인 패턴은 무엇인가요?,"What design pattern defines an interface for creating an object, but lets subclasses decide which class to instantiate?",공장 방식(기술적으로 디자인 패턴이 아닌 관용구),"Factory method (technically an idiom, not a design pattern)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로토타입 패턴이란 무엇인가요?,What is the Prototype pattern?,"프로토타입 인스턴스를 사용하여 생성할 객체의 종류를 지정하고, 이 프로토타입을 복사하여 새로운 객체를 만듭니다.","Specifies the kinds of objects to create using a prototypical instance, and creates new objects by copying this prototype.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로토타입 인스턴스를 사용하여 생성할 객체의 종류를 지정하고 이 프로토타입을 복사하여 새로운 객체를 생성하는 디자인 패턴은 무엇인가요?,"What design pattern specifies the kinds of objects to create using a prototypical instance, and creates new objects by copying this prototype?",프로토타입 패턴,Prototype pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
싱글턴 패턴이란 무엇인가요?,What is the Singleton pattern?,Ensures a class only has one instance and provides a global point of access to it.,Ensures a class only has one instance and provides a global point of access to it.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern ensures a class only has one instance and provides a global point of access to it?,What design pattern ensures a class only has one instance and provides a global point of access to it?,싱글톤 패턴,Singleton pattern,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
디자인 패턴이란 무엇인가요?,What are design patterns?,일반적인 계층 및 계층 관계 문제에 대한 반복적이고 재사용 가능한 해결책.,"Recurring, reusable solutions to common class and class relationship problems.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
데메테르의 법칙이란 무엇인가요?,What is the Law of Demeter?,"각 유닛은 현재 유닛과 ""가까운"" 유닛들만 다른 유닛에 대해 제한된 지식을 가져야 합니다. 각 유닛은 낯선 사람이 아닌 친구들과만 대화해야 합니다. 가까운 친구들과도만 대화해야 합니다.","Each unit should have only limited knowledge about other units - only units ""closely"" related to the current unit. Each unit should only talk to friends, not strangers. Only talk to immediate friends.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"캐시 라인 크기가 64B이고 메모리 버스 폭이 64비트인 경우, 캐시 라인당 전송 횟수는 몇 번인가요?","If a cache line size is 64B, and the memory bus is 64 bits wide, how many transfers per cache line?",8,8,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
독점 캐시 스타일이란 무엇인가요?,What does an exclusive cache style?,L1D에서 퇴거하면 캐시 라인 크기가 같은 L2로 캐시 라인이 밀려 내려갑니다. 각 퇴거는 점진적으로 더 비쌉니다.,"An eviction from L1D pushes the cache line down into L2, which has the same cache line size. Each eviction is progressively more expensive.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
독점 캐시 스타일을 사용하는 제조업체는 어디인가요?,What manufacturer uses an exclusive cache style?,AMD,AMD,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
포괄적 캐시 스타일은 어떻게 작동하나요?,How does an inclusive cache style work?,L1D의 각 캐시 라인도 L2에 있습니다. 따라서 L1D 삭제 속도가 빨라집니다.,Each cache line in L1D is also in L2. This makes L1D eviction faster.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
포괄적 캐시 스타일을 사용하는 제조업체는 어디인가요?,What manufacturer uses an inclusive cache style?,인텔,Intel,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
고속 푸리에 변환이란 무엇인가요?,What is the Fast Fourier Transform?,고속 푸리에 변환(FFT) 알고리즘은 시퀀스의 이산 푸리에 변환(DFT) 또는 그 역행렬을 계산합니다. 푸리에 분석은 원래 도메인(종종 시간 또는 공간)의 신호를 주파수 도메인의 표현으로 변환하거나 그 반대로 변환합니다. FFT는 DFT 행렬을 희소(대부분 0) 요인의 곱으로 분해하여 이러한 변환을 빠르게 계산합니다.,"A fast Fourier transform (FFT) algorithm computes the discrete Fourier transform (DFT) of a sequence, or its inverse. Fourier analysis converts a signal from its original domain (often time or space) to a representation in the frequency domain and vice versa. An FFT rapidly computes such transformations by factorizing the DFT matrix into a product of sparse (mostly zero) factors.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
건너뛰기 목록이란 무엇인가요?,What is a skip list?,"정렬된 요소 시퀀스 내에서 빠른 검색을 가능하게 하는 데이터 구조입니다. 각 연속적인 하위 시퀀스는 이전보다 적은 수의 요소를 건너뛰고 연결된 하위 시퀀스 계층을 유지함으로써 빠른 검색이 가능합니다. 검색은 가장 드문 하위 시퀀스에서 시작하여 검색된 요소보다 작거나 같은 두 개의 연속적인 요소가 발견될 때까지 계속됩니다.

건너뛰기 목록은 레이어로 구성되어 있습니다. 하위 레이어는 일반적인 순서대로 연결된 목록입니다. 각 상위 레이어는 아래 목록의 ""급행 차선"" 역할을 하며, 레이어 i의 요소는 고정된 확률 p(p에 대해 일반적으로 사용되는 두 값은 1/2 또는 1/4)로 레이어 i+1에 나타납니다.","A data structure that allows fast search within an ordered sequence of elements. Fast search is made possible by maintaining a linked hierarchy of subsequences, with each successive subsequence skipping over fewer elements than the previous one. Searching starts in the sparsest subsequence until two consecutive elements have been found, one smaller and one larger than or equal to the element searched for.

A skip list is built in layers. The bottom layer is an ordinary ordered linked list. Each higher layer acts as an ""express lane"" for the lists below, where an element in layer i appears in layer i+1 with some fixed probability p (two commonly used values for p are 1/2 or 1/4).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"스킵 리스트는 어떤 작업을 지원하며, 평균 시간과 최악의 경우 시간은 어떻게 되나요?",What operations does a skip list support and what is their avg and worst case times?,"검색: O(log n) O(n)
삽입: O(log n) O(n)
삭제: O(로그 n) O(n)","search: O(log n) O(n)
insert: O(log n) O(n)
delete: O(log n) O(n)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
반 엠데 보아스 트리는 어떤 연산을 지원하며 time complexity는 어떻게 되나요?,What operations does a van Emde Boas tree support and what are the time complexities?,"모두 O(로그 로그 M)이며, 여기서 M은 저장할 수 있는 총 항목 수 = 2^m입니다
또는 O(log m) 여기서 m은 저장된 실제 항목 수입니다
공간: O(M)

검색
삽입
삭제
전임자
후계자","All are O(log log M), where M is the total number of items that can be stored = 2^m
Or O(log m) where m is the actual number of items stored
Space: O(M)

Search
Insert
Delete
Predecessor
Successor",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
치료 작업의 복잡성은 무엇인가요?,What are the complexities for treap operations?,"모든 기본 유지보수 작업에 대해 O(log n) 평균 경우와 O(n) 최악의 경우입니다.
- 검색
- 삽입
- 삭제

이러한 작업의 경우, 크기가 m이고 n인 트랩에 대해 m ≤ n인 O(m log n/m)입니다. 
- 연합
- 교차점
- 차이","For all the basic maintenance operations, they are O(log n) average case and O(n) worst case.
- Search
- Insert
- Delete

For these operations, O(m log n/m) for treaps of sizes m and n, with m ≤ n. 
- union
- intersection
- difference",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
카탈루냐 숫자란 무엇인가요?,What are Catalan numbers?,"카탈루냐 수는 다양한 카운팅 문제에서 발생하는 일련의 자연수를 형성하며, 종종 재귀적으로 정의된 객체와 관련이 있습니다. 카탈루냐 수는 균형 잡힌 괄호의 집합으로 생각할 수 있습니다.","Catalan numbers form a sequence of natural numbers that occur in various counting problems, often involving recursively-defined objects. They can be thought of as the set of balanced parentheses.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
카라츠바 곱셈이란 무엇인가요?,What is Karatsuba multiplication?,"일반적으로 n자리 숫자 두 개의 곱셈을 최대 n^1.585개의 한 자릿수 곱셈으로 줄입니다(n이 2의 거듭제곱일 때 정확히 n^log(base2)3). 카라츠바 알고리즘은 이차 ""학년"" 알고리즘보다 점진적으로 빠른 최초의 곱셈 알고리즘이었습니다.","It reduces the multiplication of two n-digit numbers to at most n^1.585 single-digit multiplications in general (and exactly n^log(base2)3 when n is a power of 2). The Karatsuba algorithm was the first multiplication algorithm asymptotically faster than the quadratic ""grade school"" algorithm.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
포드-풀커슨의 time complexity는 무엇인가요?,What is the time complexity of Ford-Fulkerson?,O(E max|f|),O(E max|f|),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16^0 ?,16^0 ?,1,1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16^1 ?,16^1 ?,16,16,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16^2 ?,16^2 ?,256,256,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16^3 ?,16^3 ?,4096,4096,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16^4 ?,16^4 ?,"65,536","65,536",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16^5 ?,16^5 ?,"1,048,576","1,048,576",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16^6 ?,16^6 ?,"1,600만",16 million,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16^7,16^7,"2억 6,800만",268 million,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16^8 ?,16^8 ?,"42억 9,400만, 2^32와 동일","4.294 billion, same as 2^32",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
소수점에서 0xB는 무엇인가요?,What is 0xB in decimal?,11,11,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
소수점에서 0xC는 무엇인가요?,What is 0xC in decimal?,12,12,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
소수점에서 0xD는 무엇인가요?,What is 0xD in decimal?,13,13,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
소수점에서 0xE는 무엇인가요?,What is 0xE in decimal?,14,14,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
소수점에서 0xF는 무엇인가요?,What is 0xF in decimal?,15,15,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
소수점에서 0xA는 무엇인가요?,What is 0xA in decimal?,10,10,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이진법에서 0xA란 무엇인가요?,What is 0xA in binary?,1010,1010,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이진법에서 0xB란 무엇인가요?,What is 0xB in binary?,1011,1011,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이진법에서 0xC란 무엇인가요?,What is 0xC in binary?,1100,1100,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이진법에서 0xD란 무엇인가요?,What is 0xD in binary?,1101,1101,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이진법에서 0xE는 무엇인가요?,What is 0xE in binary?,1110,1110,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이진법에서 0xF란 무엇인가요?,What is 0xF in binary?,1111,1111,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
트랩의 우선순위는 어떻게 할당되나요?,How are the priorities of a treap assigned?,삽입 시 무작위로 생성됩니다. 이러한 무작위성은 트리의 균형을 유지하는 데 사용됩니다.,Randomly generated upon insertion. That randomness is used to keep the tree balanced.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
결합 법선 형식의 명제를 예로 들어보세요.,Give an example of a proposition in conjunctive normal form.,(A + ~B)(A + B),(A + ~B)(A + B),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
하프 애더는 덧셈을 어떻게 처리하나요?,How does a half-adder handle an addition?,합계에 대한 XOR과 캐리에 대한 AND,XOR for the sum and AND for the carry,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
기하학적 슈타이너 트리는 NP-완전인가요?,Is a geometric Steiner tree NP-Complete?,네.,Yes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
볼록 껍질을 위한 두 가지 알고리즘은 무엇인가요?,What are the 2 algorithms for convex hull?,"- 그레이엄 스캔
- 자비스 행진(선물 포장 방법)","- Graham scan
- Jarvis march (gift-wrapping method)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그레이엄 스캔은 볼록 껍질을 찾는 데 어떻게 작동하나요?,How does a Graham scan work in finding convex hull?,O(n log n)에서는 모든 지점을 정렬한 다음 간단한 단일 패스를 사용하여 반시계 방향으로 회전하면서 왼쪽으로만 회전합니다. 다음 지점이 우회전할 때는 모든 지점을 역추적하여 스택과 팝업 포인트를 사용하여 왼쪽으로 회전할 때까지 모든 지점을 지나갑니다.,"At O(n log n), uses a sort and then a simple single pass of all the points, and making only left turns as it goes around the perimeter counter-clockwise. When the next point is a right turn, it backtracks past all points (using a stack and popping points off) until that turn turns into a left turn.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
자비스 행진은 볼록 껍질을 찾는 데 어떻게 작동하나요?,How does the Jarvis march work in finding convex hull?,"맨 왼쪽 점 p부터 시작합니다: 
각 지점을 통과하여 해당 지점의 오른쪽으로 이동하고 p를 피벗으로 사용하여 어느 지점이 가장 시계 방향인지 찾습니다. O(n)
새로운 p - O(1)로 가장 시계 방향의 점을 구합니다
새로운 p로 다시 루프

이것은 시작 지점이 O(h)에 도달할 때까지 계속됩니다 - 여기서 h는 선체 지점의 수입니다","Starting with the leftmost point p: 
Go through each point to the right of that point, and using p as a pivot, find which point is the most clockwise. O(n)
Get the most clockwise point as the new p - O(1)
Loop again with new p

This continues until the starting point is reached O(h) - where h is the number of hull points",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
자비스 행진의 최악의 경우 time complexity는 무엇인가요?,What is the worst case time complexity of a Jarvis march?,"O(n^2)
대부분의 지점이 선체의 일부일 때 발생하며, 선체에 포함된 지점은 거의 없습니다.","O(n^2)
Occurs when most points are part of the hull, and few points contained in the hull.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
자비스 행진의 평균 복잡성은 무엇인가요?,What is the average complexity of a Jarvis march?,O(n * h) 여기서 h는 선체를 구성하는 점의 수입니다.,O(n * h) where h is the number of points that compose the hull.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
화이트박스 테스트란 무엇인가요?,What is white-box testing?,테스터는 프로그램 내부에 대한 지식을 활용하고 있습니다.,The tester is using knowledge of the program's internals.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
블랙박스 테스트란 무엇인가요?,What is black-box testing?,테스터가 내부 정보 없이 테스트하고 있습니다.,The tester is testing without knowledge of the internals.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
단위 테스트란 무엇인가요?,What is unit testing?,단일 모듈을 개별적으로 테스트합니다.,Testing a single module in isolation.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
API 입력 외에 테스트에 영향을 미칠 수 있는 것은 무엇인가요?,"What can affect testing, apart from API inputs?","- 입력 타이밍
- 디스크 가득
- 네트워크 지연 시간
- 네트워크 장애","- timing of inputs
- disk full
- network latency
- network failures",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
테스트에서 입력 타이밍이 중요한 3가지 상황은 무엇인가요?,What are 3 situations where timing of inputs is important in testing?,"- SUT이 하드웨어 장치와 직접 상호 작용할 때
- SUT이 네트워크의 다른 컴퓨터와 인터페이스할 때
- SUT은 멀티스레드입니다","- when SUT interacts directly with hardware devices
- when SUT interfaces with other machines on the network
- SUT is multithreaded",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
모의 물체란 무엇인가요?,What is a mock object?,SUT에 볼트로 고정할 수 있는 더 큰 시스템의 인터페이스와 상호 작용을 복제하는 데 사용되는 객체입니다.,An object used to replicate the interfaces and interactions of a larger system that can be bolted on to the SUT.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
통합 테스트란 무엇인가요?,What is integration testing?,통합 동작이 예상대로 작동하는지 확인하기 위해 유닛을 함께 테스트합니다.,Testing units together to ensure the integrated behavior performs as expected.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
시스템 테스트란 무엇인가요?,What is system testing?,"- 내부와 관련이 없는
- 시스템이 중요한 사용 사례에 대해 한동안 허용 가능한 성능을 발휘합니다","- not concerned with internals
- does system as a while perform acceptably for the important use cases",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
감별 테스트란 무엇인가요?,What is differential testing?,테스트 입력을 두 가지 다른 구현으로 실행한 다음 동일성을 테스트합니다. 이는 여러 버전의 소프트웨어를 테스트하는 데 유용합니다.,Running test inputs into 2 different implementations and then testing for equality. This is useful for testing multiple versions of the software.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스트레스 테스트란 무엇인가요?,What is stress testing?,"코드나 시스템을 정상적으로 사용하지 않는 테스트.
대규모 입력 테스트.
많은 요청을 테스트합니다.","Testing code or a system beyond its normal usage.
Testing large inputs.
Testing many requests.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
어떻게 하면 충분히 테스트하고 있다고 말할 수 있나요?,How can you tell you're testing enough?,코드 커버리지 메트릭(몇 가지가 있음),Code coverage metrics (of which there are a few),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
코드 커버리지는 무엇을 알려주지 않나요?,What does code coverage not tell you?,"- 누락된 오류
- 사양 항목이 누락된 코드
- 코드가 올바른 횟수로 반복되었음을 알려주지 않습니다","- missing errors of omission
- code that misses a specification item
- does not tell us that code looped the correct number of times",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
모든 코드가 포함되지 않는다는 것을 알게 되면 어떻게 해야 하나요?,What should you do when you discover that not all code is covered?,"모든 사례를 다루기 위해 맹목적으로 시험을 작성하지 마세요.
테스트를 다시 생각해 보세요. 아마도 그들이 기능을 잘못 해석하고 있는 것 같습니다.","Don't blindly write tests to cover all cases.
Rethink the tests. Perhaps they are interpreting the functionality incorrectly.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
보장 지표에는 어떤 것들이 있나요?,What are some coverage metrics?,"- 라인 커버리지
- 진술 범위(한 줄에 여러 개의 진술)
- 지점 커버리지
- MC/DC 커버리지
- 루프 커버리지","- line coverage
- statement coverage (multiple statements on a line)
- branch coverage
- mc/dc coverage
- loop coverage",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
MC/DC 커버리지란 무엇인가요?,What is mc/dc coverage?,"수정된 조건/결정

- 특정 유형의 항공 전자 소프트웨어에 필요함
- 가능한 모든 가지와 조건을 테스트합니다","modified condition / decision

- Required for certain types of avionics software
- Tests every possible branch and condition",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
경로 보장이란 무엇인가요?,What is path coverage?,코드의 특정 장소에 도착하는 경로와 관련된 커버리지.,Coverage that is concerned with the paths taken to arrive at a place in the code.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
실행 불가능한 코드란 무엇인가요?,What is infeasible code?,"절대 사실일 수 없는 코드.
실행 불가능한 코드는 순방향 또는 역방향으로 도달할 수 없는 코드입니다. 실행 불가능한 코드는 반드시 오류는 아니지만 코드에 문제가 있다는 좋은 지표이며, 예를 들어 항공전자공학에서는 실행 불가능한 코드가 현재 표준에 의해 금지되어 있습니다.","Code that can never be true.
Infeasible code is code that is either not forward- or not backward-reachable. Infeasible code is not necessarily an error but it is a good indicator that something is wrong with the code and, e.g., in avionics, infeasible code is forbidden by current standards.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
코드 커버리지 지표에 통합 테스트를 포함해야 하나요?,Should you include integration tests in code coverage metrics?,아니요.,No,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
보고된 버그를 수정하기 전에 무엇을 해야 하나요?,What should you do before fixing a reported bug?,테스트를 작성하세요. 이 관행을 피하면 버그가 다시 나타날 수 있습니다.,Write a test. Avoiding this practice allows bugs to re-appear.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
왜 검사는 무력하고 고립되어야 하나요?,Why should tests be idempotent and isolated?,"테스트를 어떤 순서로든 실행하고, 다시 실행하고, 병렬화할 수 있습니다.","It allows tests to be run in any order, re-run, and parallelized.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
삭제(순서 없이 단일 링크된 목록),delete (unordered singly linked list),O(n),O(n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
찾기(순서 없이 단일 링크된 목록),find (unordered singly linked list),O(n),O(n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
삭제(단일 링크 목록 정렬),delete (ordered singly linked list),O(n),O(n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
찾기(바이너리 검색 트리),find (Binary Search Tree),O(h),O(h),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
추가(바이너리 검색 트리),add (Binary Search Tree),O(h),O(h),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스택 상단에 요소 추가 - 푸시,Add element to the top of the stack - push,O(1),O(1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스택의 상단 요소 제거 - 팝,Remove the top element of the stack - pop,O(1),O(1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스택의 최상위 요소 값을 제거하지 않고 반환합니다.,Return the value of the top element of the stack without removing it.,O(1),O(1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
대기열에 요소를 추가합니다.,Add an element to a queue.,O(1),O(1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
대기열 앞쪽에서 요소를 제거합니다. 대기열 해제,Remove an element from the front of the queue. dequeue,O(1),O(1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
요소를 제거하지 않고 대기열 앞쪽에서 반환합니다,Return the element from the front of the queue without removing it. - front,O(1),O(1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
찾기(순서가 없는 배열),find (unordered array),O(n),O(n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
추가(순서가 없는 배열),add (unordered array),O(1),O(1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
삭제(순서가 없는 배열),delete (unordered array),O(N),O(N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
찾기(sorted 배열),find (sorted array),"O(로그 n)
이진 검색","O(log n)
binary search",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
추가(sorted 배열),add (sorted array),O(n),O(n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정렬된 배열에서 요소 삭제,delete an element from a sorted array,O(N),O(N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
찾기(순서 없이 단일 링크된 목록),find (unordered singly linked list),O(N),O(N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
추가(순서 없이 단일 링크된 목록),add (unordered singly linked list),O(1),O(1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
삭제(순서 없이 단일 링크된 목록),delete (unordered singly linked list),O(N),O(N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
찾기(단일 링크 목록 정렬),find (ordered singly linked list),O(N),O(N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
추가(단일 링크 목록 정렬),add (ordered singly linked list),O(N),O(N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
삭제(단일 링크 목록 정렬),delete (ordered singly linked list),O(N),O(N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
찾기(바이너리 검색 트리),find (Binary Search Tree),O(h),O(h),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
추가(바이너리 검색 트리),add (Binary Search Tree),O(h),O(h),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
삭제(바이너리 검색 트리),delete (Binary Search Tree),O(h),O(h),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
찾기(균형 이진 검색 트리),find (Balanced Binary Search Tree),O(로그 N),O(log N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
추가(균형 이진 검색 트리),add (Balanced Binary Search Tree),O(로그 N),O(log N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
삭제(균형 이진 검색 트리),delete (Balanced Binary Search Tree),O(로그 N),O(log N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
찾기(균형 이진 검색 트리),find (Balanced Binary Search Tree),O(로그 N),O(log N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
추가(균형 이진 검색 트리),add (Balanced Binary Search Tree),O(로그 N),O(log N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
삭제(균형 이진 검색 트리),delete (Balanced Binary Search Tree),O(로그 N),O(log N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
건너뛰기 목록이란 무엇인가요?,What is a skip list?,"항목의 점점 더 희소해지는 하위 시퀀스를 연결하는 링크된 목록의 계층 구조를 사용하여 정렬된 항목 목록을 저장하는 데이터 구조입니다.
O(로그 N) 모든 작업에 대한 예상 시간, O(N) 최악의 경우.","A data structure for storing a sorted list of items using a hierarchy of linked lists that connect increasingly sparse subsequences of the items.
O(log N) expected time for all operations, O(N) worst case.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
트랩이란 무엇인가요?,What is a treap?,"트리 + 힙
모든 키에 무작위 우선순위가 할당되며 두 가지 속성을 유지해야 합니다:
- 그들은 일반적인 Binary Search Tree에서처럼 키에 대해 순서대로 배열되어 있습니다
- 우선순위에 따라 힙 순서대로 정렬됩니다. 즉, 어떤 키도 우선순위가 낮은 키를 조상으로 사용하지 않습니다
O(로그 N) 모든 작업에 대한 예상 시간, O(N) 최악의 경우.","Tree + heap
A random priority is assigned to every key and must maintain two properties:
- They are in order with respect to their keys, as in a typical binary search tree
- They are in heap order with respect to their priorities, that is, no key has a key of lower priority as an ancestor
O(log N) expected time for all operations, O(N) worst case.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
맥스 힙이란 무엇인가요?,What is a max-heap?,"각 요소에 ""우선순위""가 할당된 대기열입니다. 우선순위가 높은 요소는 우선순위가 낮은 요소보다 먼저 제공됩니다.","A queue in which each element has a ""priority"" assigned to it. Elements with higher priorities are served before lower priorities.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
min (순서 순서 없음),min (unordered sequence),O(N),O(N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
삽입(순서 순서 없음),insert (unordered sequence),O(1),O(1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
removeMin (순서 순서 없음),removeMin (unordered sequence),O(N),O(N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
min (순서 순서),min (ordered sequence),O(1),O(1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
삽입(순서 순서대로),insert (ordered sequence),O(N),O(N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
removeMin (순서),removeMin (ordered sequence),O(1),O(1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
빌드(순서 순서),build (ordered sequence),O(N 로그 N),O(N log N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최소 (binary 더미),min (binary heap),O(1),O(1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
삽입(binary 힙),insert (binary heap),O(로그 N),O(log N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
RemoveMin(이진 힙),removeMin (binary heap),O(로그 N),O(log N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
빌드(binary 힙),build (binary heap),O(N),O(N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이진 힙이란 무엇인가요?,What is a binary heap?,"완전한 힙 순서 이진 트리에 배열된 키 모음으로, 배열에서 레벨 순서로 표시됩니다(첫 번째 항목을 사용하지 않음). 위치 k에 있는 노드의 부모는 [k/2] 위치에 있고, 위치 k에 있는 노드의 두 자식은 위치 2k와 2k+1에 있습니다.","A collection of keys arranged in a complete heap-ordered binary tree, represented in level order in an array (not using the first entry). The parent of the node in position k is in position [k/2] and the two children of the node in position k are in position 2k and 2k+1.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
적응 가능한 우선순위 대기열이란 무엇인가요?,What is a Adaptable Priority Queue?,이미 대기열에 있는 객체의 우선순위를 변경할 수 있는 우선순위 대기열입니다.,A priority queue that allows you to change the priority of objects already in the queue.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
퀵소트의 time complexity는 어떻게 되나요?,What is the time complexity of quicksort?,"O(N^2 최악)
O(N 로그 N) - 최적 및 예상","O(N^2 worst)
O(N log N) - best & expected",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비교 기반 정렬의 하한선,Lower Bound for Comparison Based Sorting,비교 기반 정렬 알고리즘은 O(N 로그 N)보다 빠를 수 없습니다,No comparison based sorting algorithm can be faster than O(N log N),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
k번째로 작은 (전체 힙),k-th smallest (full heap),모든 값을 입력합니다. dok k removeMin 연산: O(N + k log N),"Put all values in, do k removeMin operations: O(N + k log N)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
연결 그래프란 무엇인가요?,What is a connected graph?,그래프의 모든 정점에서 다른 모든 정점으로 가는 경로가 존재합니다.,There exists a path from every vertex to every other vertex in the graph.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
나무란 무엇인가요?,What is a tree?,비순환 연결 그래프.,An acyclic connected graph.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
사이클이란 무엇인가요?,What is a cycle?,첫 번째 정점과 마지막 정점이 동일한 하나 이상의 간선이 있는 경로.,Path with at least one edge whose first and last vertices are the same.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스패닝 트리란 무엇인가요?,What is a spanning tree?,해당 그래프의 모든 정점과 단일 트리를 포함하는 하위 그래프.,A subgraph that contains all of that graph's vertices and a single tree.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 목록에 필요한 공간,Space required for an adjacency list,O(E + V),O(E + V),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"is_adjacent (u,v) (adj 인접 행렬)","is_adjacent (u,v) (adjacency matrix)",O(도(u)),O(degree(u)),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 목록 DFS의 복잡성은 무엇인가요?,What is the complexity of an adjacency list DFS?,O(E),O(E),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
미니 코스트 스패닝 트리의 다른 이름은 무엇인가요?,What is another name for a Min-Cost Spanning Tree?,최소 신장 트리,minimum spanning tree,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트와이즈: x에서 1인 가장 낮은 비트를 분리합니다,Bitwise: Isolate the lowest bit that is 1 in x,x & ~(x - 1),x & ~(x - 1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트와이즈: 1인 가장 낮은 비트를 0으로 바꿉니다,Bitwise: Replace the lowest bit that is 1 with 0,x & (x - 1),x & (x - 1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트와이즈: 오른쪽으로 가장 오른쪽으로 설정된 비트를 x로 전파합니다,Bitwise: Right propagate the rightmost set bit in x,x | (x & ~(x - 1) - 1),x | (x & ~(x - 1) - 1),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
휴리스틱이란 무엇인가요?,What are heuristics?,"문제 해결, 학습 또는 발견에 대한 모든 접근 방식은 최적이거나 완벽하다고 보장되지 않지만 즉각적인 목표에 충분합니다. 최적의 해결책을 찾는 것이 불가능하거나 비현실적인 경우 휴리스틱 방법을 사용하여 만족하는 해결책을 찾는 과정을 가속화할 수 있습니다. 휴리스틱은 의사 결정의 인지적 부담을 덜어주는 정신적 지름길이 될 수 있습니다. 이 방법의 예로는 경험 법칙, 교육받은 추측, 직관적 판단, 고정관념, 프로파일링 또는 상식을 사용하는 것이 있습니다","Any approach to problem solving, learning, or discovery that employs a practical method not guaranteed to be optimal or perfect, but sufficient for the immediate goals. Where finding an optimal solution is impossible or impractical, heuristic methods can be used to speed up the process of finding a satisfactory solution. Heuristics can be mental shortcuts that ease the cognitive load of making a decision. Examples of this method include using a rule of thumb, an educated guess, an intuitive judgment, stereotyping, profiling, or common sense",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
안정적인 정렬이란 무엇인가요?,What is stable sorting?,동일한 키를 가진 항목은 원래 순열에서 상대적 위치를 기준으로 정렬됩니다,Items with the same key are sorted based on their relative position in the original permutation,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
트라이의 다른 이름은 무엇인가요?,What is another name for a trie?,접두사 트리 또는 래딕스 트리.,Prefix tree or a radix tree.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
내부 정렬이란 무엇인가요?,What is internal sorting?,내부 정렬은 컴퓨터의 메인 메모리 내에서 전적으로 이루어지는 모든 데이터 정렬 프로세스입니다. 이는 정렬할 데이터가 모두 메인 메모리에 저장될 수 있을 만큼 작을 때마다 가능합니다. 더 큰 데이터셋을 정렬하려면 한 번에 메모리에 데이터 덩어리만 보관해야 할 수도 있습니다. 나머지 데이터는 일반적으로 하드 디스크와 같이 더 크지만 느린 매체에 보관됩니다. 이 느린 매체를 통해 데이터를 읽거나 작성하면 정렬 프로세스가 상당히 느려질 수 있습니다.,"An internal sort is any data sorting process that takes place entirely within the main memory of a computer. This is possible whenever the data to be sorted is small enough to all be held in the main memory. For sorting larger datasets, it may be necessary to hold only a chunk of data in memory at a time, since it won't all fit. The rest of the data is normally held on some larger, but slower medium, like a hard-disk. Any reading or writing of data to and from this slower media can slow the sortation process considerably.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
외부 정렬이란 무엇인가요?,What is external sorting?,"외부 정렬은 방대한 양의 데이터를 처리할 수 있는 정렬 알고리즘의 한 종류를 의미합니다. 정렬되는 데이터가 컴퓨팅 장치의 메인 메모리(일반적으로 RAM)에 맞지 않고 느린 외부 메모리(일반적으로 하드 드라이브)에 있어야 할 때 외부 정렬이 필요합니다. 외부 정렬은 일반적으로 하이브리드 정렬 병합 전략을 사용합니다. 정렬 단계에서는 메인 메모리에 들어갈 만큼 작은 데이터 덩어리를 읽고, 정렬한 후 임시 파일로 작성합니다. 병합 단계에서는 정렬된 하위 파일을 하나의 더 큰 파일로 결합합니다.

일반적으로 병합이 선호됩니다.","External sorting is a term for a class of sorting algorithms that can handle massive amounts of data. External sorting is required when the data being sorted do not fit into the main memory of a computing device (usually RAM) and instead they must reside in the slower external memory (usually a hard drive). External sorting typically uses a hybrid sort-merge strategy. In the sorting phase, chunks of data small enough to fit in main memory are read, sorted, and written out to a temporary file. In the merge phase, the sorted subfiles are combined into a single larger file.

Mergesort is typically preferred.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Merge Sort의 두 가지 장점은 무엇인가요?,What are 2 advantages of merge sort?,"- 링크된 목록에 적합한
- 외부 정렬에 적합한","- suitable for a linked list
- suitable for external sort",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Merge Sort의 단점은 무엇인가요?,What is disadvantages of merge sort?,병합된 데이터를 보관하려면 추가 버퍼가 필요합니다,Need an extra buffer to hold the merged data,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Heap Sort의 3가지 장점은 무엇인가요?,What are 3 advantages of heap sort?,"- 재귀가 필요하지 않습니다
- 대용량 데이터에 적합한
- 데이터의 지역성","- don't need recursion
- suitable for large data
- locality of data",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Heap Sort의 단점은 무엇인가요?,What is a disadvantage of heap sort?,보통 Merge Sort과 빠른 정렬보다 느립니다.,Usually slower than merge sort and quick sort.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
관절 정점이란 무엇인가요?,What is a articulation vertex?,그래프에서 가장 약한 점.,The weakest point in a graph.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
반음계 숫자는 무엇인가요?,What is the chromatic number?,그래프의 가장자리 색칠에 필요한 최소 색상 수입니다.,The smallest number of colors needed for an edge coloring of a graph.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
머신 러닝과 관련된 장기적인 문제는 무엇인가요?,What are long-term issues involved in machine learning?,"- 기술 부채
- 명확한 추상화 장벽의 부족 
- 모든 것을 바꾸는 것은 모든 것을 바꿉니다
- 피드백 루프 - 모델에 따른 사용 방식이 모델을 변경합니다
- 매력적인 성가심 (다른 도메인에 맞지 않는 성공적인 모델을 사용하여)
- 비정상성 - 현재 데이터를 유지하거나 새 데이터를 얻거나 재사용할 오래된 데이터의 양
- 데이터 종속성 추적 - 데이터 출처, 새 데이터를 얻는 방법","- technical debt
- lack of clear abstraction barriers 
- changing anything changes everything
- feedback loop - usage based on your model changes the model
- attractive nuisance (using a successful model in one domain where it doesn't fit in another)
- non-stationarity - stick with current data, or get new, and how much of old data to reuse
- tracking data dependencies - where did the data come from, how to get new data",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
12 x 16 행렬에는 몇 줄이 있나요?,How many rows are in a 12 x 16 matrix?,12,12,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
12 x 16 행렬에는 몇 개의 열이 있나요?,How many columns are in a 12 x 16 matrix?,16,16,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
선형 대수학에서 12개 원소의 벡터는 몇 개의 행을 가지고 있나요?,In linear algebra a vector of 12 elements has how many rows?,12,12,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
선형 대수학에서 12개 원소의 벡터는 몇 개의 열을 가지고 있나요?,In linear algebra a vector of 12 elements has how many columns?,1,1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
선형 대수학에서 12차원 벡터는 몇 개의 행을 가지고 있나요?,In linear algebra a 12-dimensional vector has how many rows?,12,12,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
선형 대수학에서 12차원 벡터의 벡터는 몇 개의 열을 가지고 있나요?,In linear algebra a vector of 12-dimensional vector has how many columns?,1,1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
4x3 행렬과 3x6 행렬을 곱할 때 최종 행렬의 크기는 어떻게 되나요?,"When multiplying a 4x3 matrix and a 3x6 matrix, what are the dimensions of the final matrix?",4x6,4x6,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
3x2 행렬과 2x3 행렬을 곱할 수 있나요?,Can you multiply a 3x2 and a 2x3 matrix?,네.,Yes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
3x2 행렬과 3x2 행렬을 곱할 수 있나요?,Can you multiply a 3x2 and a 3x2 matrix?,아니요.,No,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
3x2와 2x6 행렬을 곱할 수 있나요?,Can you multiply a 3x2 and a 2x6 matrix?,네.,Yes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
5x2 행렬과 2x5 행렬을 곱할 때 최종 행렬의 크기는 어떻게 되나요?,"When multiplying a 5x2 matrix and a 2x5 matrix, what are the dimensions of the final matrix?",5x5,5x5,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
행렬 곱셈은 가환적인가요? AxB = BxA인가요?,Is matrix multiplication commutative? Does AxB = BxA?,아니요.,No.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
행렬 곱셈은 연관성이 있나요? (AxB)xC = Ax(BxC)인가요?,Is matrix multiplication associative? Does (AxB)xC = Ax(BxC)?,네.,Yes,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
항등 행렬이 MxN 행렬과 곱하여 자신을 얻는 모습은 어떻게 될까요?,What would the identity matrix look like to multiply with an MxN matrix to get itself?,NxN 행렬은 왼쪽 위에서 오른쪽 아래 대각선에 1이 있는 것을 제외하고는 모두 0입니다.,An NxN matrix that is all zeroes except it has 1s on a top-left to bottom-right diagonal.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
행렬이 역행렬을 가지려면 적어도 행렬에 대해 무엇이 참이어야 하나요?,What must at least be true about a matrix for it to have an inverse?,정사각형이어야 합니다.,It must be square.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
행렬을 반전시킨다는 것은 무엇을 의미하나요?,What does it mean to invert a matrix?,특정 행렬에 곱하여 곱이 항등 행렬이 되도록 합니다.,Multiplying it by a specific matrix so that the product is the identity matrix.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
행렬의 역행렬을 계산하는 파이썬 라이브러리는 무엇인가요?,What Python library computes the inverse of a matrix?,"numpy.linalg.inv
또는
행렬이 가역적이지 않을 때 해결할 수 있는 numpy.linalg.pinv","numpy.linalg.inv
or
numpy.linalg.pinv which can solve when the matrix is non-invertible",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가역 행렬의 두 단어는 무엇인가요?,What are 2 words for matrices that are invertible?,"- 단수의
- 퇴화된","- singular
- degenerate",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"A가 행렬이고 Aij가 i번째 행, j번째 열인 경우, 사다리꼴 B는 무엇인가요?","If A is a matrix and Aij is the ith row, jth column, what is the traspose B?",비지,Bji,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이차의 다른 이름은 무엇인가요?,What is another name for quadratic?,이차 다항식,2nd-order polynomial,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
지도 학습이란 무엇인가요?,What is supervised learning?,"Supervised learning is the machine learning task of inferring a function from labeled training data. The training data consist of a set of training examples. In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal).","Supervised learning is the machine learning task of inferring a function from labeled training data. The training data consist of a set of training examples. In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
회귀 문제란 무엇인가요?,What is a regression problem?,연속적인 값의 출력을 예측하는 것. 분류에 사용되는 이산 반응 변수와는 달리 연속 반응 변수의 추정을 구체적으로 참조할 수 있습니다.,"One that predicts a continuously valued output. May refer specifically to the estimation of continuous response variables, as opposed to the discrete response variables used in classification.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
분류 문제란 무엇인가요?,What is a classification problem?,범주 구성원이 알려진 관찰(또는 인스턴스)을 포함하는 학습 데이터 세트를 기반으로 새로운 관찰이 어떤 범주(하위 집단)에 속하는지 식별하는 문제입니다.,"The problem of identifying to which of a set of categories (sub-populations) a new observation belongs, on the basis of a training set of data containing observations (or instances) whose category membership is known.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비지도 학습이란 무엇인가요?,What is unsupervised learning?,"Unsupervised learning is the machine learning task of inferring a function to describe hidden structure from unlabeled data. Since the examples given to the learner are unlabeled, there is no error or reward signal to evaluate a potential solution. This distinguishes unsupervised learning from supervised learning and reinforcement learning.","Unsupervised learning is the machine learning task of inferring a function to describe hidden structure from unlabeled data. Since the examples given to the learner are unlabeled, there is no error or reward signal to evaluate a potential solution. This distinguishes unsupervised learning from supervised learning and reinforcement learning.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
지도 학습을 활용하는 두 가지 유형의 문제는 무엇인가요?,What are the 2 types of problems that utilize supervised learning?,회귀 및 분류,Regression and classification,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
기계 학습에서 기호 m은 무엇에 사용되나요?,"In machine learning, what is the symbol m used for?",훈련 예시의 수.,the number of training examples.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
변수가 하나인 선형 회귀의 다른 용어는 무엇인가요?,What is another term for linear regression with one variable?,단변량 선형 회귀,Univariate linear regression,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
경사 하강법이란 무엇인가요?,What is gradient descent?,경사 하강법은 1차 반복 최적화 알고리즘입니다. 경사 하강법을 사용하여 비용 함수의 국소 최소값을 구하려면 현재 시점에서 함수의 경사(부분 미분 또는 탄젠트)의 음수에 비례하는 단계를 밟습니다.,"Gradient descent is a first-order iterative optimization algorithm. To find a local minimum of a cost function using gradient descent, one takes steps proportional to the negative of the gradient (partial derivative or tangent) of the function at the current point.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
모든 훈련 예제를 사용하여 경사 하강법을 계산할 때 이를 무엇이라고 하나요?,What is it called when all training examples are used to calculate gradient descent?,배치 경사 하강법,batch gradient descent,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
여러 변수가 있는 선형 회귀의 다른 용어는 무엇인가요?,What is another term for linear regression with multiple variables?,다변량 선형 회귀,Multivariate linear regression,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
기능 확장이 중요한 이유는 무엇인가요?,Why is feature scaling important?,특징 스케일링이 없으면 지역 최소값을 찾는 데 경사 하강이 훨씬 더 오래 걸릴 수 있습니다. 함수는 작은 움직임으로 훨씬 더 오래 진동할 수 있습니다.,"Without feature scaling, it can take gradient descent much longer to find the local minimum. The function may oscillate in small movements for much longer.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
기능을 어느 정도까지 확장하기에 좋은 범위인가요?,What is is good range to scale features down to?,-1에서 +1 또는 Ng의 범위: -3에서 +3,"-1 to +1, or Ng's range: -3 to +3",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
평균 정규화란 무엇인가요?,What is mean normalization?,기능의 값을 모두 서로 상대적인 범위 내에 있도록 스케일링하는 방법입니다.,A method of scaling a feature's values so that they all fall within a range relative to each other.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
평균 정규화를 위한 좋은 범위는 무엇인가요?,What is a good range for mean normalization?,-0.5에서 +0.5까지,-0.5 to +0.5,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
특징 집합에 대한 평균 정규화를 어떻게 계산할 수 있나요?,How can you calculate mean normalization over a set of features?,"각 x에 대해: xi = (xi - avg(x)) / (max_x - min_x)

(max_x - min_x)는 표준 편차로 대체할 수 있습니다","for each x: xi = (xi - avg(x)) / (max_x - min_x)

(max_x - min_x) can be replaced with the standard deviation",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"충분히 작은 알파가 주어졌을 때, 경사 하강에서 무엇을 기대할 수 있나요?","Given a sufficiently small alpha, what can you expect from gradient descent?",결국 수렴할 것입니다.,That it will eventually converge.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
앤드류 응은 경사 하강에 적합한 알파를 찾기 위해 무엇을 사용하나요?,What does Andrew Ng use to find an appropriate alpha for gradient descent?,"0.001
0.003
0.01
0.03
0.1
0.3
1","0.001
0.003
0.01
0.03
0.1
0.3
1",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
선형 회귀에서 고차 항을 사용하여 데이터를 더 잘 맞추려면 어떻게 해야 하나요?,How can you get your data to fit better using higher order terms in linear regression?,"데이터를 가져와서 제곱하거나 큐브를 맞추는 등의 작업을 수행할 수 있습니다. 

x1 = (somevalue)^2
x7 = (somevalue)^4

이것은 함수가 아닌 데이터에 적용됩니다. 함수는 여전히 theta1*x1 + theta2*x2 등입니다","You can take the data and square it, cube it, etc. 

x1 = (somevalue)^2
x7 = (somevalue)^4

This is applied to data, not the function. The function still is theta1*x1 + theta2*x2, etc",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
행렬의 가역성에 영향을 미칠 수 있는 것은 무엇인가요?,What can affect invertibility in a matrix?,"- 2 more more features are linearly dependent or redundant (size in meters and size in ft) - remove redundant features
- too few training examples (m) to features (n): m <= n  (remove some features or use regularization)","- 2 more more features are linearly dependent or redundant (size in meters and size in ft) - remove redundant features
- too few training examples (m) to features (n): m <= n  (remove some features or use regularization)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
언제 경사 하강 대신 정규 방정식을 사용하여 J(theta)를 최소화할 수 있을까요?,When can we use the normal equation instead of gradient descent to minimize J(theta)?,"- 기능이 10,000개 미만일 때
- 가역성을 보장해야 합니다","- when we have fewer than 10,000 features
- have to ensure invertibility",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
numpy.allclose()는 무엇을 하나요?,What does numpy.allclose() do?,두 배열이 허용 오차 내에서 요소별로 같으면 True를 반환합니다.,Returns True if two arrays are element-wise equal within a tolerance.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정규 방정식을 사용할 때 특징 스케일링이 필요한가요?,Is feature scaling needed when using the normal equation?,아니요.,No,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
일반 방정식은 무엇인가요?,What is the normal equation?,"기울기 하강법 대신 J(theta)를 최소화하여 세타를 구할 수 있는 방정식.

일반 최소 제곱(OLS) 또는 선형 최소 제곱이라고도 하는 이 방법은 선형 회귀 모델에서 알려지지 않은 매개변수를 추정하는 방법으로, 주어진 데이터셋에서 관찰된 반응과 설명 변수 집합의 선형 함수로 예측된 반응 간의 차이의 제곱 합을 최소화하는 것을 목표로 합니다.","An equation that can minimize J(theta), solving for theta, instead of using gradient descent.

Also called ordinary least squares (OLS) or linear least squares, it's a method for estimating the unknown parameters in a linear regression model, with the goal of minimizing the sum of the squares of the differences between the observed responses in the given dataset and those predicted by a linear function of a set of explanatory variables.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
행렬의 의사 역행렬을 결정하는 파이썬은 무엇인가요?,What Python determines the pseudo-inverse of a matrix?,numpy.linalg.pinv,numpy.linalg.pinv,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 거짓으로 취급되는 것은 무엇인가요?,What is treated as false in Python?,"• False
• None
• [] (an empty list)
• {} (an empty dict)
• """"
• set()
• 0
• 0.0","• False
• None
• [] (an empty list)
• {} (an empty dict)
• """"
• set()
• 0
• 0.0",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
점 제품이란 무엇인가요?,What is a dot product?,"두 벡터의 내적은 그들의 구성 요소별 곱의 합입니다.
v_1 * w_1 + ... + v_n * w_n","The dot product of two vectors is the sum of their componentwise products.
v_1 * w_1 + ... + v_n * w_n",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
분위수는 무엇인가요?,What is the quantile?,주어진 데이터 백분위수에서의 숫자.,The number at a given percentile of the data.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
모드가 무엇인가요?,What is the mode?,데이터 집합에서 가장 일반적인 값입니다. 동일한 수의 값을 가진 두 개의 하위 집합이 있는 경우 둘 이상의 값을 가질 수 있습니다.,Most-common value(s) in a set of data. Could have more than one if there are 2 subsets with the same number of values.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
분산이란 무엇인가요?,What is dispersion?,분산은 데이터가 얼마나 분산되어 있는지를 측정하는 척도를 의미합니다. 일반적으로 0에 가까운 값은 전혀 분산되지 않고 큰 값(의미가 무엇이든)은 매우 분산되어 있음을 나타내는 통계입니다.,Dispersion refers to measures of how spread out our data is. Typically they’re statistics for which values near zero signify not spread out at all and for which large values (whatever that means) signify very spread out.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
공분산이란 무엇인가요?,What is covariance?,두 편차의 곱의 평균값은 각각의 평균에서 다릅니다.,The mean value of the product of the deviations of two variates from their respective means.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
랜덤 변수란 무엇인가요?,What is a random variable?,"확률 변수는 가능한 값들이 연관된 확률 분포를 가지는 변수입니다.

동전 던지기가 앞면이 나오면 1, 뒷면이 나오면 0이 되는 매우 간단한 확률 변수입니다. 더 복잡한 변수는 동전 던지기를 10번 할 때 관찰되는 앞면의 수를 측정하거나 각 숫자가 동일할 가능성이 있는 범위(10)에서 선택한 값을 측정할 수 있습니다.","A random variable is a variable whose possible values have an associated probability distribution.

A very simple random variable equals 1 if a coin flip turns up heads and 0 if the flip turns up tails. A more complicated one might measure the number of heads observed when flipping a coin 10 times or a value picked from range(10) where each number is equally likely.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
PCA란 무엇이며 무엇에 사용되나요?,What is PCA and what is it used for?,주성분 분석. 우리는 이를 사용하여 데이터 변동의 가능한 한 많은 부분을 포착하는 하나 이상의 차원을 추출합니다.,Principal component analysis. We use it to extract one or more dimensions that capture as much of the variation in the data as possible.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
모델이란 무엇인가요?,What is a model?,서로 다른 변수들 사이에 존재하는 수학적(또는 확률적) 관계의 명세.,A specification of a mathematical (or probabilistic) relationship that exists between different variables.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
머신 러닝이란 무엇인가요?,What is machine learning?,데이터에서 학습한 모델을 만들고 사용합니다.,Creating and using models that are learned from data.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정점의 차수는 무엇인가요?,What is the degree of a vertex?,정점에 입사하는 모서리의 수와 루프가 두 번 계산됩니다.,"The number of edges incident of the vertex, with loops counted twice.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
퀵 셀렉트란 무엇인가요?,What is quick select?,정렬되지 않은 목록에서 k번째로 작은 요소를 찾기 위한 선택 알고리즘입니다. 퀵셀렉트는 퀵소트와 동일한 전체 접근 방식을 사용하여 하나의 요소를 피벗으로 선택하고 피벗을 기준으로 데이터를 두 개로 분할하여 피벗보다 작거나 크게 만듭니다. 그러나 퀵셀렉트는 퀵소트처럼 양쪽으로 재귀하는 대신 검색하는 요소가 있는 쪽인 한쪽으로만 재귀합니다. 이렇게 하면 평균 복잡성이 O(n 로그 n)에서 O(n)으로 줄어듭니다.,"A selection algorithm to find the kth smallest element in an unordered list. Quickselect uses the same overall approach as quicksort, choosing one element as a pivot and partitioning the data in two based on the pivot, accordingly as less than or greater than the pivot. However, instead of recursing into both sides, as in quicksort, quickselect only recurses into one side - the side with the element it is searching for. This reduces the average complexity from O(n log n) to O(n).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
선점이란 무엇인가요?,What is preemption?,선점은 컴퓨터 시스템이 수행하는 작업을 협력 없이 일시적으로 중단하고 나중에 작업을 재개할 의도로 하는 행위입니다. 이러한 변경은 컨텍스트 전환이라고 합니다.,"Preemption is the act of temporarily interrupting a task being carried out by a computer system, without requiring its cooperation, and with the intention of resuming the task at a later time. Such a change is known as a context switch.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
역지수란 무엇인가요?,What is an inverted index?,"단어나 숫자와 같은 콘텐츠에서 데이터베이스 파일, 문서 또는 문서 집합(문서에서 콘텐츠로 매핑하는 Forward Index와는 대조적으로 명명됨)의 위치로 매핑을 저장하는 인덱스 데이터 구조입니다. 역 인덱스의 목적은 문서가 데이터베이스에 추가될 때 처리 비용을 증가시키면서 빠른 전체 텍스트 검색을 가능하게 하는 것입니다.","An index data structure storing a mapping from content, such as words or numbers, to its locations in a database file, or in a document or a set of documents (named in contrast to a Forward Index, which maps from documents to content). The purpose of an inverted index is to allow fast full text searches, at a cost of increased processing when a document is added to the database.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
세트 partition이란 무엇인가요?,What is set partition?,어떤 보편적 집합의 요소들을 분리된 부분 집합으로 나누는 것입니다. 따라서 각 요소는 정확히 하나의 부분 집합에 있어야 합니다.,"A partitioning of elements of some universal set into a collection of disjointed subsets. Thus, each element must be in exactly one subset.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최대 신장 트리란 무엇인가요?,What is a maximum spanning tree?,최대 가중치를 가진 가중 그래프의 스패닝 트리입니다. 간선을 부정하고 Prim 또는 Kruskal의 알고리즘을 실행하여 계산할 수 있습니다.,A spanning tree of a weighted graph having maximum weight. It can be computed by negating the edges and running either Prim's or Kruskal's algorithms.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최소 제품 스패닝 트리는 무엇이며 언제 사용하시겠습니까?,What is a minimum product spanning tree and when would you use it?,"트리의 비용은 가중치의 합 대신 트리의 모든 엣지 가중치의 곱입니다. log(a*b) = log(a) + log(b)이므로 엣지 가중치가 로그로 대체된 그래프의 최소 스패닝 트리는 원래 그래프의 최소 곱 스패닝 트리를 제공합니다.
제품을 최소화하는 데 사용할 수 있습니다.","The cost of a tree is the product of all the edge weights in the tree, instead of the sum of the weights. Since log(a*b) = log(a) + log(b), the minimum spanning tree on a graph whose edge weights are replaced with their logarithms gives the minimum product spanning tree on the original graph.
You would use it to minimize the product.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
롤링 해시란 무엇인가요?,What is a rolling hash?,"롤링 해시(롤링 체크섬이라고도 함)는 입력을 통해 이동하는 창에서 입력이 해시되는 해시 함수입니다.

주요 응용 프로그램 중 하나는 롤링 해시를 사용하는 라빈-카프 문자열 검색 알고리즘입니다.","A rolling hash (also known as a rolling checksum) is a hash function where the input is hashed in a window that moves through the input.

One of the main applications is the Rabin-Karp string search algorithm, which uses the rolling hash.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
라빈-카프 알고리즘이란 무엇인가요?,What is the Rabin-Karp algorithm?,문자열의 해시 코드가 각 개별 문자의 덧셈 함수라는 속성을 가진 함수와 같이 길이가 s인 각 하위 문자열의 해시 코드를 계산합니다. 문자 슬라이딩 창의 해시 코드를 가져와 해시가 일치하는지 비교합니다.,"Compute hash codes of each substring whose length is the length of s, such as a function with the property that the hash code of a string is an additive function of each individual character. Get the hash code of a sliding window of characters and compare if the hash matches.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
sharding이란 무엇인가요?,What is sharding?,"sharding은 매우 큰 데이터베이스를 데이터 샤드라고 하는 더 작고, 빠르고, 더 쉽게 관리할 수 있는 부분으로 나누는 일종의 데이터베이스 분할입니다.","Sharding is a type of database partitioning that separates very large databases the into smaller, faster, more easily managed parts called data shards.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
폰 노이만 건축이란 무엇인가요?,What is von Neumann Architecture?,"존 폰 노이만이 만든 현대 컴퓨터 조직 모델은 두 가지 주요 특징을 가지고 있었습니다:
1) 데이터와 지침이 모두 같은 장소에 저장됩니다
2) 정보를 저장하는 단위는 정보를 처리하는 단위와 다릅니다","A model for modern computer organization created by John von Neumann, that had two main features:
1) Both data & instructions are stored in the same place
2) Units that store information are different from units that process information",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가져오기-실행 주기는 무엇인가요?,What is the fetch-execute cycle?,"CPU에서 작업이 수행되는 방식을 설명하는 4부 시스템입니다. 이 사이클에는 4부가 있습니다:
1) 가져오기 지침
2) 명령어 해독
3) 필요한 경우 데이터 가져오기
4) 지침 실행","A 4 part system that describes how actions are performed in the CPU. There are 4 parts to this cycle:
1) Fetch instructions
2) Decode instructions
3) Get data if needed
4) Execute the instructions",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
제어 장치(CU)는 무엇을 하나요?,What does a Control Unit (CU) do?,"CPU가 받는 모든 프로세스와 명령을 제어, 조직 및 처리합니다. 또한 가져오기-실행 주기도 담당합니다. 명령 레지스터와 프로그램 카운터라는 두 가지 특수 목적 레지스터가 있습니다.","Controls, organizes and deals with all the process and instruction the CPU receives. It is also in charge of the Fetch-Execute Cycle. Has two special purpose registers: the Instruction Register and the Program Counter.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
너비 우선 검색의 time complexity는 얼마인가요?,What is the time complexity of breadth-first search?,"O(m + n) 
대기열 사용","O(m + n) 
uses queue",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
너비 우선 검색의 time complexity는 얼마인가요?,What is the time complexity of breadth-first search?,"O(m + n) 
스택 사용","O(m + n) 
uses stack",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동적 프로그래밍을 사용하는 최소 편집 거리의 시간과 space complexity는 얼마인가요?,What is the time and space complexity of minimum edit distance using dynamic programming?,"시간 O(mn)
공간 O(mn)","Time O(mn)
Space O(mn)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
플로이드 워샬의 time complexity는 무엇인가요?,What is the time complexity of Floyd-Warshall?,세타(n^3),Theta(n^3),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n의 로그는 무엇인가요?,What is the log of n! ?,n 로그 n,n log n,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
벨먼-포드의 시간과 공간의 복잡성은 무엇인가요?,What is the time and space complexity of Bellman-Ford?,"Time : O (|V| |E|) or Theta(n^3) 
공간: O (|V|)","Time : O (|V| |E|) or Theta(n^3) 
Space: O (|V|)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
벨먼-포드 알고리즘이란 무엇인가요?,What is the Bellman–Ford algorithm?,가중 그래프에서 단일 소스 정점에서 다른 모든 정점까지의 최단 경로를 계산하는 알고리즘입니다. 동일한 문제에 대한 Dijkstra의 알고리즘보다 느리지만 일부 에지 가중치가 음수인 그래프를 처리할 수 있기 때문에 더 다재다능합니다.,"An algorithm that computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph. It is slower than Dijkstra's algorithm for the same problem, but more versatile, as it is capable of handling graphs in which some of the edge weights are negative numbers.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
해밀턴 사이클이란 무엇인가요?,What is a Hamiltonian cycle?,"방향이 없는 그래프 G = (V, E)가 주어졌을 때, 다음과 같은 간단한 것이 존재하는가
V의 모든 노드를 포함하는 사이클 γ?
인증서는 n개의 노드를 순열한 것으로, v에 있는 각 노드를 정확히 한 번만 포함합니다. 순열에는 각 adj 노드 쌍에 엣지가 있습니다.","Given an undirected graph G = (V, E), does there exist a simple
cycle Γ that contains every node in V ?
Certificate is a permutation of the n nodes, contain each node in v exactly once, there is an edge btw each pair of adj nodes in the permutation.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
세트 커버 문제는 무엇인가요?,What is the set cover problem?,"원소 집합 U가 주어졌을 때, 집합 S1, S2, ..., 부분 집합의 Sm
U와 정수 k의 합집합이 U와 같은 ≤ k개의 집합이 존재하나요?","Given a set U of elements, a collection S1, S2, ..., Sm of subsets of
U, and an integer k, does there exist a collection of ≤ k of these sets whose union is equal to U ?",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
힙소트의 시간과 공간 복잡성은 무엇인가요?,What is the time and space complexity of heapsort?,"O(n lg n) time
O(1) 공간","O(n lg n) time
O(1) space",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
병합 유형의 시간과 공간 복잡성은 무엇인가요?,What is the time and space complexity of merge sort?,"O(n lg n) time
O(n) 공간","O(n lg n) time
O(n) space",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
훈련 및 테스트를 위해 데이터 세트를 어떻게 나누시겠습니까?,How would you divide up a data set for training and testing?,"데이터 세트를 분할하여 그 중 3분의 2가 모델을 훈련시키는 데 사용되도록 하고, 그 후 나머지 3분의 1에서 모델의 성능을 테스트/측정합니다.","Split your data set, so that two-thirds of it is used to train the model, after which we test/measure the model’s performance on the remaining third.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
여러 모델 중에서 데이터 세트를 선택하려면 어떻게 해야 하나요?,How would you split up a data set in order to choose from multiple models?,"이러한 상황에서는 데이터를 세 부분으로 나누어야 합니다: 모델을 구축하기 위한 훈련 세트, 훈련된 모델 중에서 선택하기 위한 검증 세트(교차 검증 세트라고 함), 그리고 최종 모델을 판단하기 위한 테스트 세트입니다.","In such a situation, you should split the data into three parts: a training set for building models, a validation set for choosing among trained models (called the cross-validation set), and a test set for judging the final model.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
타입 1 오류란 무엇인가요?,What is a Type 1 error?,거짓 양성,A false positive,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
타입 2 오류란 무엇인가요?,What is a Type 2 error?,거짓 음성,A false negative,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
통계학에서 정밀도를 어떻게 계산하시겠습니까?,"In statistics, how would you calculate precision?",true_pos / (true_pos + false_pos),true_pos / (true_pos + false_pos),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
통계학에서 리콜을 어떻게 계산하시겠습니까?,"In statistics, how would you calculate recall?",true_pos / (true_pos + false_neg),true_pos / (true_pos + false_neg),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
통계에서 정밀도는 무엇을 측정하나요?,"In statistics, what does precision measure?",정밀도는 우리의 긍정적인 예측이 얼마나 정확한지를 측정합니다.,Precision measures how accurate our positive predictions are.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
통계에서 회상은 무엇을 측정하나요?,"In statistics, what does recall measure?",리콜은 우리 모델이 식별한 긍정적인 요소의 비율을 측정합니다.,Recall measures what fraction of the positives our model identified.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
F1 점수를 어떻게 계산하시겠습니까?,How would you calculate the F1 score?,2 * 정밀도 * 리콜 / (정밀도 + 리콜),2 * precision * recall / (precision + recall),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
F1 점수의 다른 이름은 무엇인가요?,What is another name for the F1 score?,정밀도와 회상의 조화 평균,the harmonic mean of precision and recall,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정밀도와 재현율 사이의 균형은 무엇인가요?,What is the trade-off between precision and recall?,"조금이라도 자신감이 있을 때 ""예""를 예측하는 모델은 높은 재현율을 가지지만 정밀도는 낮을 것입니다. 극도로 자신감이 있을 때만 ""예""를 예측하는 모델은 재현율이 낮고 정밀도가 높을 가능성이 높습니다.

또는 이것을 거짓 양성과 거짓 음성 사이의 절충안으로 생각할 수도 있습니다. ""예""를 너무 자주 말하면 (높은 기억력) 많은 거짓 양성이 나오고, ""아니오""를 너무 자주 말하면 (높은 정확도) 많은 거짓 음성이 나옵니다.","A model that predicts “yes” when it’s even a little bit confident will probably have a high recall but a low precision; a model that predicts “yes” only when it’s extremely confident is likely to have a low recall and a high precision.

Alternatively, you can think of this as a trade-off between false positives and false negatives. Saying “yes” too often (high recall) will give you lots of false positives; saying “no” too often will give you lots of false negatives (high precision).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
높은 편향과 낮은 분산은 일반적으로 ______에 해당합니다.,High bias and low variance typically correspond to _______.,과소적합,underfitting,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
편향은 낮지만 분산이 매우 높은 경우 일반적으로 _____.에 해당합니다.,Low bias but very high variance typically correspond to _______.,과적합,overfitting,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"모델의 편향이 높을 때(즉, 훈련 데이터에서도 성능이 좋지 않음을 의미함) 어떻게 할 수 있나요?",What can you do when your model has high bias (which means it performs poorly even on your training data)?,한 가지 시도해 볼 수 있는 것은 더 많은 기능을 추가하는 것입니다.,One thing to try is adding more features.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
모델이 높은 분산으로 인해 과적합으로 고통받는 경우 어떻게 할 수 있나요?,What can you do if your model suffers from overfitting due to high variance?,"기능을 제거할 수 있습니다. 또 다른 해결책은 더 많은 훈련 예제를 얻는 것입니다 (가능하다면).
또는 정규화를 사용하세요.","You can remove features. Another solution is to obtain more training examples (if you can).
Or use regularization.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
BFGS는 무엇을 의미하나요?,What does BFGS stand for?,브로이든-플레처-골드파브-샤노 알고리즘,Broyden–Fletcher–Goldfarb–Shanno algorithm,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
L-BFGS란 무엇인가요?,What is L-BFGS?,제한 메모리 BFGS(L-BFGS 또는 LM-BFGS)는 제한된 양의 컴퓨터 메모리를 사용하여 Broyden–Fletcher–Goldfarb–Shanno(BFGS) 알고리즘을 근사하는 준-뉴턴 방법 계열의 최적화 알고리즘입니다. 이 알고리즘은 머신 러닝에서 매개변수 추정에 널리 사용되는 알고리즘입니다.,Limited-memory BFGS (L-BFGS or LM-BFGS) is an optimization algorithm in the family of quasi-Newton methods that approximates the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm using a limited amount of computer memory. It is a popular algorithm for parameter estimation in machine learning.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
로지스틱 회귀 문제에 최적화할 수 있는 대체 알고리즘에는 어떤 것이 있나요?,What are some alternative algorithms that can optimize for a logistic regression problem?,"- 켤레 구배
- BGFS
- L-BGFS","- conjugate gradient
- BGFS
- L-BGFS",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
신경망이 회귀나 분류보다 우월한 이유는 무엇인가요?,What makes neural networks superior over regression or classification?,각 은닉층은 주어진 특징 대신 고유한 특징을 학습합니다.,Each hidden layer learns its own features instead of being given features.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
신경망을 위해 세타를 어떻게 초기화해야 하나요?,How should you initialize Theta for a neural network?,0과 1 사이의 무작위 실수 행렬로 초기화합니다. 세타 * 2*epsilon - epsilon을 사용하여 +/- epsilon 범위 내에서 제약합니다.,Initialize as a matrix of random reals between 0 and 1. Constrain within a range of +/- epsilon using Theta * 2*epsilon - epsilon.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
신경망의 입력층에 있는 뉴런(단위)의 수는 얼마인가요?,What are the number of neurons (units) at the input layer of a neural network?,특징의 수.,The number of features.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
분류를 수행하는 신경망의 출력층에 있는 뉴런(단위)의 수는 얼마인가요?,What are the number of neurons (units) at the output layer of a neural network performing classification?,분류하고 있는 클래스의 수입니다.,The number of classes you are classifying.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
신경망에는 몇 개의 숨겨진 층이 있어야 하나요?,How many hidden layers should there be in a neural network?,기본값으로 1부터 시작하여 하나 이상이면 각 레이어에서 동일한 수의 단위를 갖습니다. 많을수록 좋습니다. 각 숨겨진 레이어의 단위 수는 입력 단위보다 많거나 여러 개여야 합니다.,"Start with 1 as a default, and if more than one, have the same number of units at each layer. The more the better. The number of units in each hidden layer should be more than, or a multiple of, the input units.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
기계 학습: 다항식의 차수가 증가함에 따라 선형 모델에서 학습 오류는 어떻게 발생하는 경향이 있나요?,Machine learning: What tends to happen with the training error in a linear model as the degree of polynomial increases?,오차는 감소하지만 다항식의 차수가 너무 높으면 과적합이 발생합니다.,"The error decreases, but too high a degree of polynomial will cause overfitting.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
기계 학습: 다항식의 차수가 증가함에 따라 선형 모델에서 교차 검증 오류는 어떻게 발생하는 경향이 있나요?,Machine learning: What tends to happen with the cross-validation error in a linear model as the degree of polynomial increases?,높은 편향(높은 편향)에서 시작하여 감소하여 최소값에 도달한 다음 증가합니다(높은 분산).,"It starts high (high bias) and decreases, reaching a minimum, and then increases (high variance).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
터미널에서 이전에 실행된 명령을 실행하는 명령은 무엇인가요?,What command on the terminal will execute the previously run command?,!!,!!,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
우분투의 .bashrc에 포함된 ls -alF의 별칭은 무엇인가요?,What alias for ls -alF is included in Ubuntu's .bashrc?,ll,ll,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
명령줄 기록을 어떻게 볼 수 있나요?,How can you view your command line history?,역사,history,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
실행 중인 프로세스를 이름으로 검색할 수 있는 명령줄 도구는 무엇인가요?,What command line tool allows you to search running processes by name?,pgrep,pgrep,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
실행 중인 프로세스를 이름으로 찾아서 종료할 수 있는 명령줄 도구는 무엇인가요?,What command line tool allows you to find and kill running processes by name?,"pkill
모두 죽여라","pkill
killall",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
도메인 이름에서 IP 주소를 가져올 수 있는 명령줄 도구는 무엇인가요?,What command line tool allows you to get the IP address from a domain name?,파다,dig,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
사용자와 특정 서버 IP 또는 도메인 이름 간의 인터넷 연결을 확인할 수 있는 명령줄 도구는 무엇인가요?,What command line tool allows you to see the internet connections between you and a given server IP or domain name?,트레이서루트,traceroute,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
호스트별 인터페이스에서 대역폭 사용량을 표시할 수 있는 명령줄 명령어는 무엇인가요?,What command line command allows you to display bandwidth usage on an interface by host?,iftop -p -n,iftop -p -n,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
명령줄에서 a 또는 f로 시작하는 모든 파일을 어떻게 나열할 수 있나요?,"On the command line, how can you list all files beginning with a or f?",ls [af]*,ls [af]*,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
주어진 명령줄 명령어가 무엇에 대한 별칭인지 어떻게 알 수 있나요?,How can you tell what a given command line command is an alias for?,[명령어]를 입력합니다,type [command],2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
명령어 또는 명령어 집합에 대한 별칭을 어떻게 만들 수 있나요?,How can you create an alias for a command or set of commands?,"alias wowza='명령 1; 명령 2; 명령 3'

보존하려면 ~/.bashrc에 추가하세요","alias wowza='command 1; command 2; command 3'

To preserve it, add it to ~/.bashrc",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
명령어의 오류를 파일로 리디렉션하려면 어떻게 해야 하나요?,How can you redirect errors form a command to a file?,어떤 명령어 2> errorfile.txt,somecommand 2> errorfile.txt,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
명령어에서 파일로 stdout과 오류를 어떻게 리디렉션할 수 있나요?,How can you redirect stdout and errors from a command to a file?,"some 명령어 > somefile.txt 2>&1

또는:

some 명령 &> somefile.txt","somecommand > somefile.txt 2>&1

OR:

somecommand &> somefile.txt",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
명령에서 오류를 어떻게 버릴 수 있나요?,How can you throw away errors from a command?,어떤 명령 2> /dev/null,somecommand 2> /dev/null,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이프를 사용하여 파일에 저장하지만 다음 명령으로 계속 파이프를 연결할 수 있는 명령은 무엇인가요?,What command can you use with pipes to save to a file but continue piping to the next command?,some 명령 | tee file.txt | more 명령,somecommand | tee file.txt | morecommand,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
명령줄에서 한 번에 여러 디렉토리를 만들 수 있는 방법은 무엇인가요?,How can you make multiple directories at once from the command line?,mkdir {2009..2016},mkdir {2009..2016},2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
명령줄에서 환경 변수 목록을 어떻게 얻을 수 있나요?,How can you get a list of environment variables from the command line?,printenv,printenv,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
터미null이 이진 출력으로 인해 엉망이 되었을 때 어떤 명령을 사용할 수 있나요?,What command can you use when your terminal is messed up by binary output?,리셋,reset,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
명령줄에서 컴퓨터의 IP 주소를 어떻게 알 수 있나요?,How can you find out your computer's IP address from the command line?,컬 ifconfig.me,curl ifconfig.me,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
명령줄에서 ASCII 테이블에 빠르게 액세스하려면 어떻게 해야 하나요?,How can you get quick access to an ASCII table from the command line?,남자 아스키,man ascii,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
유니크를 사용하여 반복되는 선만 어떻게 표시하나요?,How do you show only repeated lines using uniq?,유니크 -d,uniq -d,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SED는 무엇을 의미하며 어떤 역할을 하나요?,What does sed stand for and what does it do?,스트림 편집기. 많은 작업을 수행하지만 주로 검색 및 교체에 사용됩니다.,Stream editor. It does many things but is mainly used for search and replace.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"grep, egrep, grep -P 사이에 큰 차이가 있나요?","Is there much difference between grep, egrep, and grep -P?","네, grep은 고급 레제그를 지원하지 않습니다.
egrep은 확장됩니다
grep -P는 펄 스타일을 사용하지만, 그것은 거의 egrep에 가깝습니다 - 차이를 볼 수 없습니다","Yes, grep doesn't support fancy regex.
egrep does extended
grep -P does perl-style but that's pretty close to egrep - can't see a difference",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SED에서 구분 기호로 무엇을 사용할 수 있나요?,What can you use as a delimiter in sed?,"/, :, |, _ 모두 괜찮아","/, :, |, _ are all ok",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
확장 정규 표현식을 켤 때 SED와 함께 어떤 깃발을 사용하나요?,What flag do you use with sed to turn on extended regular expressions?,sed -r,sed -r,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
C 프로그램 컴파일의 4가지 부분은 무엇인가요?,What are the 4 parts of compiling a C program?,"- 전처리기
- 컴파일러 - 출력 어셈블리
- 어셈블러 - 기계/객체 코드 출력
- Linked - 종속 객체 파일의 링크","- preprocessor
- compiler - outputs assembly
- assembler - outputs machine/object code
- linked - links in dependent object files",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
라인 번호의 grep 플래그는 무엇인가요?,What is the grep flag for line numbers?,-n,-n,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
일치하는 부분만 표시하는 grep 플래그는 무엇인가요?,What is the grep flag for showing matched portion only?,-o,-o,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
탭 중지된 열에 형식을 지정하는 데 사용할 수 있는 명령어는 무엇인가요?,What command can you use to format in tab-stopped columns?,열 -t,column -t,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"/etc/passwd 파일에서 home이라는 단어가 포함된 첫 번째, 두 번째, 네 번째 열을 어떻게 인쇄할 수 있나요?","How can you print the 1st, 2nd, and 4th columns in the /etc/passwd file that contain the word home?","awk -F: '/home/ {print $1, $2, $4}' /etc/passwd","awk -F: '/home/ {print $1, $2, $4}' /etc/passwd",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파일의 첫 번째와 두 번째 열에 foo라는 단어가 포함된 경우에만 어떻게 파일의 첫 번째와 두 번째 열을 인쇄할 수 있나요?,How can you print the 1st and 2nd column of a file only when the second column contains the word foo?,"awk '{ if($2 ~ /foo/) print $1,$2}' somefile","awk '{ if($2 ~ /foo/) print $1,$2}' somefile",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
트레이스란 무엇인가요?,What is strace?,"strace는 리눅스용 진단, 디버깅 및 교육용 사용자 공간 유틸리티입니다. 이 유틸리티는 시스템 호출, 신호 전달, 프로세스 상태 변경 등 프로세스와 리눅스 커널 간의 상호작용을 모니터링하는 데 사용됩니다. strace의 작동은 ptrace라는 커널 기능에 의해 가능해집니다.","strace is a diagnostic, debugging and instructional userspace utility for Linux. It is used to monitor interactions between processes and the Linux kernel, which include system calls, signal deliveries, and changes of process state. The operation of strace is made possible by the kernel feature known as ptrace.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
tcpdump란 무엇인가요?,What is tcpdump?,tcpdump는 정보 보안 전문가를 위한 최고의 네트워크 분석 도구입니다. TCP/IP에 대한 철저한 이해를 원하는 모든 사람에게 이 강력한 애플리케이션에 대한 확고한 이해는 필수적입니다.,tcpdump is the premier network analysis tool for information security professionals. Having a solid grasp of this über-powerful application is mandatory for anyone desiring a thorough understanding of TCP/IP.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
입력 라인을 무작위로 지정하는 Linux 명령어는 무엇인가요?,What Linux command randomizes the lines of its input?,슈프,shuf,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Linux에서는 형식이 좋지 않은 전화번호 파일 세트를 검색하고 빈 줄 없이 일반 전화번호 형식을 사용하여 숫자를 출력하려면 어떻게 해야 하나요?,"In Linux, how can you search a set of files of phone numbers, which are badly formatted, and output the numbers, using regular phone number formatting and no blank lines?",cat numbers-* | sed 's/[() -]//g' | grep -P '^\d{10}$' | sed -r 's/([0-9]{3})([0-9]{3})(.*)/(\1) \2-\3/',cat numbers-* | sed 's/[() -]//g' | grep -P '^\d{10}$' | sed -r 's/([0-9]{3})([0-9]{3})(.*)/(\1) \2-\3/',2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
deadlock를 어떻게 피할 수 있을까요?,How can we avoid deadlock?,잠금 장치에 순서를 할당하여 deadlock를 방지하고 해당 순서대로 잠금 장치를 확보하도록 요구할 수 있습니다. 그러나 이 접근 방식은 실제로는 자주 사용되지 않습니다.,"We can prevent deadlock by assigning an order to locks and require that the locks be acquired in that order. However, this approach is not often used in practice.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
두 개의 직사각형이 겹치지 않는지 어떻게 알 수 있나요?,How can you tell if 2 rectangles do not overlap?,"R1과 R2의 교차점은 왼쪽 하단 모서리가 (max(x1, x3), x(y1, y3))이고 오른쪽 상단 모서리가 (min(x2, x4), min(y2, y4))인 직사각형 R3가 될 것입니다. 만약 max(x1, x3) > min(x2, y3) 또는 max(y1, y3) > min(y2, y4)인 경우, R3는 존재하지 않으며, 즉 R1과 R2는 교차하지 않습니다.","The intersection of R1 and R2 will be a rectangle R3 whose bottom-left corner is at (max(x1, x3), max(y1, y3)) and top-right corner at (min(x2, x4), min(y2, y4)). If max(x1, x3) > min(x2, x4) or max(y1, y3) > min(y2, y4) then R3 does not exist, ie R1 and R2 do not intersect.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
__slots__를 추가하면 클래스는 어떻게 되나요?,What happens to a class when you add __slots__?,"__dict__가 각 인스턴스에 대해 생성되지 않기 때문에 공간이 절약됩니다. __slots__는 선언된 변수에 대한 공간을 예약하고 각 인스턴스에 대해 __dict_ 및 __weakref_의 자동 생성을 방지합니다.
약한 참조 지원이 필요한 경우 __slots__ 선언의 문자열 시퀀스에 '__weakref__'를 추가합니다.","Space is saved because __dict__ is not created for each instance. __slots__ reserves space for the declared variables and prevents the automatic creation of __dict__ and __weakref__ for each instance.
If weak reference support is needed, then add '__weakref__' to the sequence of strings in the __slots__ declaration.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
What happens when inheriting from a class without __slots__?,What happens when inheriting from a class without __slots__?,"When inheriting from a class without __slots__, the __dict__ attribute of that class will always be accessible, so a __slots__ definition in the subclass is meaningless.","When inheriting from a class without __slots__, the __dict__ attribute of that class will always be accessible, so a __slots__ definition in the subclass is meaningless.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
클래스에서 __slots__를 사용하면 하위 클래스에서는 어떤 일이 일어나나요?,"If you use __slots__ on a class, what happens in subclasses?",__slots__ 선언의 동작은 정의된 클래스로 제한됩니다. 따라서 하위 클래스는 __slots__도 정의하지 않는 한 __dict__를 가지게 됩니다 (추가 슬롯의 이름만 포함해야 합니다).,"The action of a __slots__ declaration is limited to the class where it is defined. As a result, subclasses will have a __dict__ unless they also define __slots__ (which must only contain names of any additional slots).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 약한 참조를 어떻게 할 수 있나요?,How can you make a weak reference in Python?,"from weakref import ref

r = ref(some_instance)","from weakref import ref

r = ref(some_instance)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
디버깅 문제가 주어졌을 때 확인해야 할 4가지 사항은 무엇인가요?,What 4 things should you check when given a debugging problem?,"- 입력이 유효하고 정확한가요?
- 각 줄이 정확하고 올바른 순서인지 확인합니다
- 출력이 올바른지 확인합니다
- 일반적인 오류와 알고리즘 또는 데이터 구조에 대한 특별한 경우를 확인합니다","- is the input valid and correct?
- check that each line is correct and in the right order
- check that the output is correct
- check for common errors, and special cases for and algorithm or data structure",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
나무의 높이를 결정하는 것은 무엇인가요?,What determines the height of a tree?,"나무의 높이는 가장 높은 하위 나무의 높이에 1을 더한 값과 같습니다.
1 + max 사용하기 (subtree1, subtree2)","The height of a tree equals the height of its tallest subtree plus one.
Use 1 + max(subtree1, subtree2)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
팀소트란 무엇인가요?,What is Timsort?,"Merge Sort과 Insertion Sort에서 파생된 하이브리드 안정 정렬 알고리즘으로, 다양한 종류의 실제 데이터에서 우수한 성능을 발휘하도록 설계되었습니다.
알고리즘은 이미 정렬된 데이터의 하위 시퀀스를 찾아내고, 그 지식을 사용하여 나머지를 더 효율적으로 정렬합니다. 이 작업은 특정 기준이 충족될 때까지 실행이라는 식별된 하위 시퀀스를 기존 실행과 병합하여 수행됩니다. Timsort는 버전 2.3부터 파이썬의 표준 정렬 알고리즘으로 사용되어 왔습니다.","A hybrid stable sorting algorithm, derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data.
The algorithm finds subsequences of the data that are already ordered, and uses that knowledge to sort the remainder more efficiently. This is done by merging an identified subsequence, called a run, with existing runs until certain criteria are fulfilled. Timsort has been Python's standard sorting algorithm since version 2.3.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동시성이란 무엇인가요?,What is concurrency?,지정되지 않은 순서로 거의 동시에 작업을 실행합니다. 이는 운영 체제의 컨텍스트 전환을 통해 이루어집니다.,Running tasks at almost the same time in an unspecified order. This is achieved through context switches by the operating system.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
뮤텍스란 무엇인가요?,What is a mutex?,리소스에 대한 상호 배타적 접근. 최대 동시성이 1인 세마포어의 특수한 경우입니다.,A mutually exclusive access to a resource. It's a special case of a semaphore with a maximum concurrency of 1.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
무엇이 기다리고 있나요?,What is busy waiting?,"대기 중, 대기 중, 대기 중, 회전 또는 회전은 키보드 입력이나 잠금 장치가 있는지와 같은 조건이 사실인지 반복적으로 확인하는 기술입니다.","Busy-waiting, busy-looping or spinning is a technique in which a process repeatedly checks to see if a condition is true, such as whether keyboard input or a lock is available.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
어떻게 하면 바쁜 기다림을 피할 수 있을까요?,How can you avoid busy waiting?,"세마포어 사용(파이썬, 자바)
이벤트(파이썬) 또는 카운트다운래치(자바) 사용
수면 (0)","Use Semaphore (Python, Java)
Use Event (Python) or CountDownLatch (Java)
sleep(0)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬으로 문자열의 단어를 어떻게 되돌릴 수 있나요? 구두점을 단어의 일부로 취급합니다.,How can you reverse the words in a string with Python? Treat punctuation as part of the words.,my_string.split()[::-1],my_string.split()[::-1],2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 목록을 문자열로 변환하려면 어떻게 해야 하나요?,How can you convert a list to a string in Python?,'. join(목록),''.join(thelist),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Selection Sort에 가장 적합한 경우 time complexity는?,Best case time complexity for selection sort?,O(n^2),O(n^2),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Selection Sort의 평균 사례 시간 복잡성?,Average case time complexity for selection sort?,O(n^2),O(n^2),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Selection Sort의 최악의 경우 time complexity는?,Worst case time complexity for selection sort?,O(n^2),O(n^2),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Insertion Sort에 가장 적합한 경우 time complexity는?,Best case time complexity for insertion sort?,데이터가 이미 정렬되었거나 거의 정렬된 경우 O(n).,O(n) when data is already sorted or almost sorted.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Insertion Sort의 평균 사례 time complexity는 얼마인가요?,Average case time complexity for insertion sort?,O(n^2),O(n^2),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Insertion Sort의 최악의 경우 time complexity는?,Worst case time complexity for insertion sort?,O(n^2),O(n^2),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
퀵소트의 최악의 경우 time complexity는?,Worst case time complexity for quicksort?,병리학적 피벗 선택으로 인한 O(n^2).,O(n^2) due to pathological pivot selection.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
퀵소트의 평균 사례 time complexity는 얼마인가요?,Average case time complexity for quicksort?,O(n 로그 n),O(n log n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
퀵소트에 가장 적합한 경우 time complexity는?,Best case time complexity for quicksort?,O(n 로그 n),O(n log n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Merge Sort에 가장 적합한 경우 time complexity는?,Best case time complexity for merge sort?,O(n 로그 n),O(n log n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
퀵소트의 최악의 경우 time complexity는?,Worst case time complexity for quicksort?,O(n 로그 n),O(n log n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
퀵소트의 평균 사례 time complexity는 얼마인가요?,Average case time complexity for quicksort?,O(n 로그 n),O(n log n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정렬된 목록이 하나 이상 있고 이를 정렬된 목록으로 결합해야 하는 경우 어떻게 해야 하나요?,What should you do when you have one or more lists that are sorted and you need to combine them into a sorted list?,Merge Sort의 병합 단계.,Merge step of merge sort.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정렬하고 싶은 데이터가 있고 키 비교는 저렴하지만 데이터 이동 비용이 많이 들 때 어떤 종류를 사용할 수 있나요?,What sort can you use when you have data you want to sort and the comparisons of keys are cheap but moving the data is expensive?,Selection Sort은 n - 1 스왑 이하를 보장합니다.,Selection sort guarantees no more than n - 1 swaps.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
데이터에 중복이 없고 제자리에서 수행해야 하는 경우 어떤 종류의 데이터를 사용할 수 있나요?,What kind of sort can you use when the data is guaranteed to have no duplicates and needs to be done in-place?,불안정하고 제자리에 있는 퀵소트 같은 것.,"An unstable, in-place sort like quicksort.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정렬되지 않은 목록을 이미 정렬된 목록으로 병합하는 데 무엇을 사용할 수 있나요?,What can you use to merge an unsorted list into an already sorted list?,"새 목록이 짧으면 Insertion Sort이 O(n)이 됩니다.
두 목록이 모두 긴 경우, 짧은 목록을 정렬한 다음 병합합니다.","If the new list is short, insertion sort would be O(n).
If both lists are long, sort the short list and then do a merge.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
직원 객체 목록을 성에 따라 정렬한 다음 대소문자 구분 없이 n_n이름을 지정하려면 어떻게 해야 하나요?,"How can you sort a list of Employee objects by surname then given_name, case-sensitive?","sorted_firstnames = sorted(디렉토리, 키=lambda emp: emp.given_name.lower ())
pprint(sorted_firstnames, key=lambda emp:emp.surname.lower())","sorted_firstnames = sorted(directory, key=lambda emp: emp.given_name.lower())
pprint(sorted(sorted_firstnames, key=lambda emp: emp.surname.lower()))",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
직원 객체 목록을 성에 따라 정렬한 다음 n_n이름을 부여하되 대소문자는 구분하지 않는 방법은 무엇인가요?,"How can you sort a list of Employee objects by surname then given_name, but case-insensitive?","수입업자

pprint(sorted(디렉토리, key=operator.atttrgetter ('surname, 'given_name'))","import operator

pprint(sorted(directory, key=operator.attrgetter('surname', 'given_name')))",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
sort/sorted에서 cmp 인수에 대해 무엇을 알아야 하나요?,What should you know about the cmp argument in sort/sorted?,"In general, the key and reverse conversion processes are much faster than specifying an equivalent cmp function. This is because cmp is called multiple times for each list element while key and reverse touch each element only once. 

The cmp argument was removed in 3.0.

Use functools.cmp_to_key() to convert an old-style cmp function to a key function.","In general, the key and reverse conversion processes are much faster than specifying an equivalent cmp function. This is because cmp is called multiple times for each list element while key and reverse touch each element only once. 

The cmp argument was removed in 3.0.

Use functools.cmp_to_key() to convert an old-style cmp function to a key function.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
불안정한 정렬 알고리즘을 사용하여 어떻게 안정적인 정렬을 얻을 수 있나요?,How can you get a stable sort using an unstable sorting algorithm?,"정렬할 객체에 새 시퀀스 속성을 추가하는 것처럼 데이터 요소에 시퀀스 번호를 추가합니다.

비교기에서 비교된 키가 같으면(차이가 0이면) e1.sequence - e2.sequence를 반환하여 타이를 끊습니다","Add a sequence number to the data elements, like adding a new sequence property to the objects to be sorted.

In your comparator, if the compared keys are equal (difference is 0), break ties by returning e1.sequence - e2.sequence",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
해밍 거리를 계산하는 지름길은 무엇인가요?,What is a shortcut for calculating the Hamming distance?,두 단어 A와 B의 해밍 거리는 A x 또는 B의 해밍 무게로 계산할 수 있습니다.,The Hamming distance of two words A and B can be calculated as the Hamming weight of A xor B.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
녹색 실이란 무엇인가요?,What are green threads?,"- 가상 머신으로 구현됨
- 더 빠르지만 여러 코어를 활용할 수 없습니다
- 멀티코어 기계의 보급으로 인해 사라지다","- implemented by a virtual machine
- faster but cannot take advantage of multiple cores
- going away due to prevalence of multicore machines",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
선제적 스레드란 무엇인가요?,What is preemptive threading?,OS는 타이밍이나 기타 인터럽트에 따라 스레드를 교체합니다.,The OS swaps threads based on timing or other interrupts.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스레드 협동 모델이란 무엇인가요?,What is the thread cooperative model?,"어떤 행동(수면, 양보)을 취하고 다른 스레드가 실행되도록 하려면 스레드가 필요합니다.","Requires a thread to take some action (sleep, yield) and let other threads run.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이벤트 중심 핸들러는 네트워크 응답을 기다리는 것과 같은 장기적인 프로세스를 어떻게 관리할 수 있을까요?,"How can an event-driven handler manage a long-running process, like waiting for a network response?",네트워크 리소스를 호출하기 위해 스레드를 생성합니다. 그런 다음 결과가 완료되면 부모 프로세스(또는 메인 이벤트 스레드)가 폴링 없이 응답하고 데이터에 액세스할 수 있도록 대기열에 넣습니다.,Spawn a thread to call the network resource. Then queue the result once complete so the parent process (or main event thread) can respond and access the data without polling.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
모니터란 무엇인가요?,What is a monitor?,모니터는 스레드가 상호 배제와 특정 조건이 성립할 때까지 대기(차단)할 수 있는 기능을 모두 가질 수 있도록 하는 동기화 구조입니다. 모니터는 또한 다른 스레드가 조건이 충족되었음을 알리는 메커니즘도 가지고 있습니다. 모니터는 뮤텍스(잠금) 객체와 조건 변수로 구성됩니다. 모니터는 스레드가 특정 조건이 충족될 때까지 기다리기 위해 일시적으로 독점 접근을 포기한 후 독점 접근을 회복하고 작업을 재개할 수 있는 메커니즘을 제공합니다.,"A monitor is a synchronization construct that allows threads to have both mutual exclusion and the ability to wait (block) for a certain condition to become true. Monitors also have a mechanism for signalling other threads that their condition has been met. A monitor consists of a mutex (lock) object and condition variables. Monitors provide a mechanism for threads to temporarily give up exclusive access in order to wait for some condition to be met, before regaining exclusive access and resuming their task.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스핀록이란 무엇인가요?,What is a spinlock?,"대기 중인 바쁜 형태로, 반복적으로 대기하며 잠금장치가 있는지 확인하는 것을 말합니다.","A form of busy waiting, that waits in a loop and repeatedly checks if a lock is available.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
다이닝 철학자 문제는 어떻게 해결하나요?,How do you solve the Dining Philosophers problem?,"- critical section is picking up one fork, second fork, and then eating then putting down forks.
- one philosopher should pick up fork 2 then fork 1. if (i == 0) swap fork 1 and 2
- one will get to eat more, the one to left of 0
- to even it out, just change order in which each picks up: if (i % 2 == 0) swap fork 1 and 2","- critical section is picking up one fork, second fork, and then eating then putting down forks.
- one philosopher should pick up fork 2 then fork 1. if (i == 0) swap fork 1 and 2
- one will get to eat more, the one to left of 0
- to even it out, just change order in which each picks up: if (i % 2 == 0) swap fork 1 and 2",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 인터페이스는 어떻게 처리되나요?,How are interfaces handled in Python?,"없어.
그냥 오리 타이핑을 사용하세요.
다중 상속 사용: ABC 만들기 및 상속","There are none.
Just use duck typing.
Use multiple inheritance: make an ABC and inherit",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
싱글턴 스레드를 안전하게 만들려면 어떻게 해야 하나요?,What should you do to make a Singleton thread-safe?,인스턴스가 호출될 때마다 스레드 안전 오버헤드가 발생하지 않도록 인스턴스를 생성하거나 스레드 안전을 유지하는 것이 가장 좋습니다.,"It's best to make getInstance() thread-safe, or make generating the instance thread-safe so getInstance does not suffer from thread-safety overhead each time it's called.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
ACID는 무엇을 의미하나요?,What does ACID stand for?,"원자성
일관성.
고립
내구성","Atomicity
Consistency
Isolation
Durability",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
C++와 Java의 차이점은 무엇인가요?,What are some differences between C++ and Java?,"C++:
- 저수준 액세스를 통한 프로그래머 제어
- C와의 하위 호환성
- 다중 상속
- 가치별로 지나가다

Java:
- 보안
- 휴대성
- VM에서 실행되며 바이트코드로 컴파일됩니다
- JIT는 속도를 크게 높입니다
- 쓰레기 수거
- 단일 상속(인터페이스를 사용하여 시뮬레이션된 다중 상속)
- 참고로 지나가다","C++:
- programmer control with low-level access
- backwards compatibility with C
- multiple inheritance
- pass by value

Java:
- security
- portability
- runs in a VM, compiles to bytecode
- JIT speeds it up considerably
- garbage collection
- single inheritance (multiple inheritance simulated by using interfaces)
- pass by reference",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
포인터와 참조의 차이점은 무엇인가요?,What is the difference between a pointer and a reference?,"- must dereference a pointer: foo->prop
- pointer can be null, a reference cannot
- deal with reference as if it was declared in the same scope: foo.prop","- must dereference a pointer: foo->prop
- pointer can be null, a reference cannot
- deal with reference as if it was declared in the same scope: foo.prop",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인라인 함수와 매크로의 차이점은 무엇인가요?,Difference between inline functions and macros?,"각각 프로그램 크기를 희생시키면서 함수 호출의 오버헤드를 줄입니다

매크로:
- 전처리기로 텍스트 대체
- 단선 전용
- 조심하지 않으면 예상치 못한 부작용이 발생할 수 있습니다

인라인:
- 인라인 함수 호출을 해당 함수의 본문으로 대체합니다
- 여러 줄에 대해 괜찮습니다
- 크기를 늘리고 반복적인 함수 호출의 오버헤드를 줄입니다","Each reduces overhead of function calls at the expense of program size

Macro:
- text replacement by preprocessor
- single line only
- unexpected side effects if not careful

Inline:
- replaces the call to an inline function with that function's body
- ok for multiple lines
- increases size, cuts down on overhead of repetitive function calls",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
쓰레기 수거의 장단점은 무엇인가요?,What are the pros and cons of garbage collection?,"좋아요:
- 매달린 포인터 없음
- 이중 할당 없음
- 메모리 누수 없음

나쁘다:
- 메모리를 과도하게 allocate 수 있습니다
- 정지 및 복사로 인해 부적절한 시간에 일시 중지될 수 있습니다
- 느린 성능
- 급속한 발전
- 순환 참조","Good:
- no dangling pointers
- no double allocation
- no memory leaks

Bad:
- can over-allocate memory
- stop and copy can cause pauses at inopportune times
- slower performance
- rapid development
- circular references",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
추적 쓰레기 수집기란 무엇인가요?,What is a tracing garbage collector?,표시 및 스위프: 프로그램 스레드에서 참조하는 모든 객체를 표시하기 위해 실행을 일시 중지합니다.,Mark and sweep: pauses execution in order to mark all objects referenced by any thread of the program.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
삼색 표시란 무엇인가요?,What is tri-color marking?,"이러한 성능 문제로 인해 대부분의 최신 추적(표시 및 스윕) 가비지 컬렉터는 일부 변형된 3색 마킹 추상화를 구현합니다. 이렇게 하면 마킹 및 스윕에 흔히 사용되는 실행 일시 중지를 피할 수 있습니다.

흰색, 검은색, 회색의 세 가지 세트가 생성됩니다:

- 화이트 세트 또는 디튼드 세트는 메모리를 재활용할 수 있는 후보 객체의 집합입니다.
- 블랙 세트는 화이트 세트의 객체에 대한 발신 참조가 없고 루트에서 도달할 수 있는 객체의 집합입니다. 블랙 세트의 객체는 수집할 수 있는 후보가 아닙니다.
- 회색 세트에는 뿌리에서 도달할 수 있지만 아직 ""흰색"" 객체에 대한 참조를 위해 스캔되지 않은 모든 객체가 포함되어 있습니다. 뿌리에서 도달할 수 있는 것으로 알려져 있기 때문에 쓰레기를 수거할 수 없으며 스캔 후 검은색 세트로 남게 됩니다.","Because of these performance problems, most modern tracing (mark and sweep) garbage collectors implement some variant of the tri-color marking abstraction. This avoids the execution pause common to mark and sweep.

Three sets are created – white, black and gray:

- The white set, or condemned set, is the set of objects that are candidates for having their memory recycled.
- The black set is the set of objects that can be shown to have no outgoing references to objects in the white set, and to be reachable from the roots. Objects in the black set are not candidates for collection.
- The gray set contains all objects reachable from the roots but yet to be scanned for references to ""white"" objects. Since they are known to be reachable from the roots, they cannot be garbage-collected and will end up in the black set after being scanned.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
32비트 애플리케이션과 64비트 애플리케이션의 차이점은 무엇인가요?,What are the difference between 32-bit and 64-bit applications?,"32비트:
- 32비트 메모리 주소 및 레지스터

64비트:
- 64비트 메모리 주소 지정 및 레지스터
- 64비트 프로세서, 64비트 운영 체제 필요
- 호환 모드에서 32비트 프로그램을 실행할 수 있습니다
- 포인터는 64비트가 필요하므로 더 많은 공간을 차지합니다
- 캐시에 맞는 항목 수 감소
- 64비트 x86-64에는 추가로 8개의 범용 레지스터가 있습니다","32-bit:
- 32-bit memory addresses and registers

64-bit:
- 64-bit memory addressed and registers
- requires 64-bit processor, 64-bit OS
- can run 32-bit programs in compatibility mode
- pointers require 64 bits so they take more space
- fewer items fit in cache
- x86-64 in 64-bit has an additional 8 additional general purpose registers",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
행렬에서 행렬을 어떻게 전치할 수 있나요?,How can you transpose a matrix in a matrix?,각 행과 열에 행과 열 번호를 표시합니다. 열별로 정렬한 다음 행별로 정렬합니다.,"Label each row and column with row and column number. Sort by column, then by row.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
크기 n의 배열을 k 위치만큼 회전하려면 어떻게 해야 하나요?,How can you rotate an array of size n by k positions?,"0을 k - 1로, k를 끝으로 되돌립니다. 그런 다음 모든 것을 뒤집습니다.","Reverse 0 to k - 1, reverse k to end. Then reverse it all.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메모리 매핑이란 무엇인가요?,What is memory-mapping?,파일의 메모리 매핑은 일반적인 I/O 기능을 사용하는 대신 운영 체제 가상 메모리 시스템을 사용하여 파일 시스템의 데이터에 직접 액세스합니다. 메모리 매핑은 각 액세스에 대해 별도의 시스템 호출이 필요하지 않고 버퍼 간에 데이터를 복사할 필요가 없기 때문에 일반적으로 I/O 성능을 향상시킵니다. 이 메모리는 커null과 사용자 애플리케이션 모두에서 직접 액세스합니다.,"Memory-mapping a file uses the operating system virtual memory system to access the data on the file system directly, instead of using normal I/O functions. Memory-mapping typically improves I/O performance because it does not involve a separate system call for each access and it does not require copying data between buffers – the memory is accessed directly by both the kernel and the user application.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
모든 쌍의 최단 경로를 계산하는 데 무엇을 사용할 수 있나요?,What can you use to compute all-pairs shortest-paths?,scipy.sparse.csgraph.floyd_warshall,scipy.sparse.csgraph.floyd_warshall,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 무한대를 어떻게 표현하나요?,How do you represent infinity in Python?,플로트('Inf'),float('Inf'),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 음수 무한대를 어떻게 표현하나요?,How do you represent negative infinity in Python?,-플로트('Inf'),-float('Inf'),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
bcrypt란 무엇인가요?,What is bcrypt?,bcrypt는 블로우피쉬 암호를 기반으로 한 비밀번호 해싱 함수입니다. bcrypt는 무지개 테이블 공격을 방지하기 위해 소금을 포함하는 것 외에도 적응형 함수입니다. 시간이 지남에 따라 반복 횟수를 늘려 속도를 늦출 수 있으므로 계산 능력이 증가하더라도 무차별 대입 검색 공격에 저항할 수 있습니다.,"bcrypt is a password hashing function based on the Blowfish cipher. Besides incorporating a salt to protect against rainbow table attacks, bcrypt is an adaptive function: over time, the iteration count can be increased to make it slower, so it remains resistant to brute-force search attacks even with increasing computation power.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
블룸 필터를 사용하는 위양성/음성과의 관계는 무엇인가요?,What is the relationship to false positives/negatives with a Bloom filter?,"거짓 부정은 불가능합니다.
오탐이 있을 수 있습니다.","False negatives are not possible.
False positives are possible.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
지역 민감 해싱에는 어떤 알고리즘이 사용되나요?,What algorithm is used for locality-sensitive hashing?,심해시,simhash,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
확률적 데이터 구조의 두 가지 예는 무엇인가요?,What are 2 examples of probabilistic data structures?,"블룸 필터
하이퍼로그로그","Bloom filter
HyperLogLog",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 선형 프로그래밍 문제를 해결하는 데 무엇을 사용할 수 있나요?,What can you use to solve linear programming problems in Python?,numpy.linalg.solve(),numpy.linalg.solve(),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
좋은 해싱 함수의 3가지 속성은 무엇인가요?,What are 3 properties of good hashing functions?,"- 충돌을 최소화하다
- 좋은 분포를 만듭니다
- 지속적으로 해시합니다","- minimize collisions
- produces a good distribution
- hashes consistently",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
해시 테이블의 3가지 좋은 용도는 무엇인가요?,What are 3 good uses of hash tables?,"- 빠른 조회, 삽입 및 삭제
- 중복 제거하기
- 캐싱","- quick lookups, inserts, and deletes
- removing duplicates
- caching",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"이것이 존재한다면, Dijkstra를 사용할 수 없습니다.","If this exists, you can't use Dijkstra.",마이너스 가중치 에지.,A negative-weight edge.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
세트 커버 문제를 어떻게 해결할 수 있나요?,How can you solve a set cover problem?,"- 발견되지 않은 대부분의 지점을 덮는 가장 큰 세트를 선택하세요
- 커버링 세트에 추가합니다
- 그 다음으로 큰, 겹치더라도

O(n^2)
욕심이 많지만 효과가 있습니다","- pick largest set that covers most of the uncovered spots
- add it to covering set
- then next largest, even if overlap

O(n^2)
greedy but it works",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
k-최근접 이웃을 사용할 때 점 n의 크기에 대해 어떤 k를 사용해야 하나요?,"When using k-nearest neighbors, what k should be used for size of points n?",sqrt(n),sqrt(n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
접미사 배열이란 무엇인가요?,What is a suffix array?,"접미사 배열은 문자열의 모든 접미사를 정렬한 배열입니다.

문자열의 접미사 배열은 문자열 S 내에서 하위 문자열 패턴 P의 모든 발생을 빠르게 찾는 인덱스로 사용할 수 있습니다. 패턴의 모든 발생을 찾는 것은 하위 문자열로 시작하는 모든 접미사를 찾는 것과 같습니다. 사전적 순서 덕분에 이러한 접미사는 접미사 배열에서 함께 그룹화되며 두 번의 이진 검색으로 효율적으로 찾을 수 있습니다. 첫 번째 검색은 간격의 시작 위치를 찾고 두 번째 검색은 끝 위치를 결정합니다.","A suffix array is a sorted array of all suffixes of a string.

The suffix array of a string can be used as an index to quickly locate every occurrence of a substring pattern P within the string S. Finding every occurrence of the pattern is equivalent to finding every suffix that begins with the substring. Thanks to the lexicographical ordering, these suffixes will be grouped together in the suffix array and can be found efficiently with two binary searches. The first search locates the starting position of the interval, and the second one determines the end position.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
배낭 문제는 NP-완전한가요?,Is knapsack problem NP-complete?,"배낭 문제의 결정 문제 형식(최소 V의 값을 가중치 W를 초과하지 않고 달성할 수 있습니까?)은 NP-완전이므로 모든 경우에 대해 올바르고 빠른(다항식 시간) 알고리즘이 알려져 있지 않습니다.

동적 프로그래밍을 사용하는 의사 다항식 시간 알고리즘이 있습니다.","The decision problem form of the knapsack problem (Can a value of at least V be achieved without exceeding the weight W?) is NP-complete, thus there is no known algorithm both correct and fast (polynomial-time) on all cases.

There is a pseudo-polynomial time algorithm using dynamic programming.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
NP에 없는 어려운 문제란 무엇인가요?,What is a hard problem that is not in NP?,"체스와 같은 2인용 게임은 NP에 없는 문제의 예를 제공합니다. 
어떤 움직임이 결국 게임에서 승리할지 확인하는 유일한 방법은 그의 반박할 수 없는 답변으로 모든 가능한 움직임의 전체 트리를 구성하고, 실제로 현재 위치에서 승리할 수 없음을 증명하는 것입니다. 이 전체 트리의 높이에는 가장 강력한 방어력을 잃기 전까지의 이동 횟수인 여러 노드가 지수적으로 표시됩니다.

이 트리는 다항 시간 내에 구성되고 분석될 수 없으므로 문제는 NP에 없습니다.","Two-player games such as chess provide examples of problems that are not in NP. 
The only way to check if a move would eventually win the game is to construct the full tree of all your possible moves with his irrefutable replies and demonstrate that you, in fact, cannot win from the current position. This full tree will have a number of nodes exponential in its height, which is the number of moves before you lose playing your most spirited possible defense.

This tree cannot be constructed and analyzed in polynomial time, so the problem is not in NP.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정렬된 배열을 유지하는 것이 어떤 종류의 작업에 좋은가요?,Maintaining a sorted array is good for what type of operations?,정렬된 배열은 삽입이나 삭제가 많지 않은 경우에만 적절할 것입니다.,A sorted array will be appropriate if and only if there are not many insertions or deletions.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
피보나치 힙은 왜 특별할까요?,Why are Fibonacci heaps special?,"피보나치 힙은 일정한 상각 시간 내에 삽입 및 감소 키 작업을 지원하며, O(lg n) 상각 시간 추출 및 삭제 작업을 수행합니다.","Fibonacci heaps support insert and decrease-key operations in constant amortized time, with O(lg n) amortized time extract-min and delete operations.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
반 엠데 보아스 나무의 특별한 점은 무엇인가요?,What makes van Emde Boas trees special?,"Van Emde Boas 우선순위 대기열은 각 키가 1부터 n까지의 요소인 O(lg lg n) 삽입, 삭제, 검색, 최대 및 최소 작업을 지원합니다.","Van Emde Boas priority queues support O(lg lg n) insertion, deletion, search, max, and min operations where each key is an element from 1 to n.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
평면 그래프에 가장 적합한 인접 목록이 있는 이유는 무엇인가요?,Why is an adjacency list for the best choice for a planar graph?,평면 그래프는 항상 희소합니다. 왜냐하면 n-정점 평면 그래프는 최대 3n - 6개의 간선을 가질 수 있기 때문입니다. 따라서 인접 목록을 사용하여 표현해야 합니다.,"Planar graphs are always sparse, since any n-vertex planar graph can have at most 3n − 6 edges. Thus they should be represented using adjacency lists.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 행렬에서 공간을 절약하기 위해 무엇을 할 수 있나요?,What can you do to save space in an adjacency  matrix?,모든 1과 0을 일련의 비트 벡터로 포장하세요.,Pack all of the ones and zeros into a series of bit vectors.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프가 매우 클 때 사용할 수 있나요?,Can you use when your graph is extremely large?,"그래프가 매우 큰 경우 정점을 하나의 정점으로 압축된 하위 그래프로 클러스터링하는 계층적 표현으로 전환해야 할 수도 있습니다. 이러한 계층적 분해를 구성하기 위해서는 두 가지 접근 방식이 존재합니다. 첫 번째는 그래프를 자연스러운 방식으로 또는 애플리케이션별 방식으로 구성 요소로 나눕니다. 예를 들어 도로와 도시의 그래프는 지도를 구, 읍, 군, 주로 분할하는 자연스러운 분해를 제안합니다.","If your graph is extremely large, it may become necessary to switch to a hierarcchical representation, where the vertices are clustered into subgraphs that are compressed into single vertices. Two approaches exist to construct such a hierar-chical decomposition. The first breaks the graph into components in a natural or application-specific way. For example, a graph of roads and cities suggests a natural decomposition—partition the map into districts, towns, counties, and states.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
대역폭 최소화는 NP-완전인가요?,Is bandwidth minimization NP-Complete?,"예. 입력 그래프가 최대 정점 차수가 3인 트리라도 NP-완전 상태를 유지하며, 이는 제가 어떤 문제에서든 본 것과 비슷한 조건입니다. 따라서 우리의 유일한 옵션은 무차별 대입 검색과 휴리스틱입니다.","Yes. It stays NP-complete even if the input graph is a tree whose maximum vertex degree is 3, which is about as strong a condition as I have seen on any problem. Thus our only options are a brute-force search and heuristics.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 행렬을 사용하여 길이 K의 두 점 사이에 얼마나 많은 경로가 존재하는지 어떻게 알 수 있나요?,Using an adjacency matrix how can you see how many paths exist between two points of length K?,"Matrix multiplication has a particularly interesting interpretation. Now consider the square of this matrix, A^2 = A × A. If A^2[i, j] ≥ 1. This means that there must be a vertex k such that A[i, k] = A[k, j] = 1, so i to k to j is a path of length 2 in G. More generally, A^k[i, j] counts the number of paths of length exactly k between i and j. This count includes nonsimple paths, where vertices are repeated, such as i to k to i to j.","Matrix multiplication has a particularly interesting interpretation. Now consider the square of this matrix, A^2 = A × A. If A^2[i, j] ≥ 1. This means that there must be a vertex k such that A[i, k] = A[k, j] = 1, so i to k to j is a path of length 2 in G. More generally, A^k[i, j] counts the number of paths of length exactly k between i and j. This count includes nonsimple paths, where vertices are repeated, such as i to k to i to j.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
행렬의 행렬식이 0이라면 그것은 무엇을 의미하나요?,What does it mean if the determinant of a matrix is zero?,그것은 되돌릴 수 없습니다.,It is not invertible.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
#P-완전이란 무엇을 의미하나요?,What does #P-complete mean?,"#P는 다항 시간 내에 ""카운팅"" 기계에서 풀 수 있는 문제의 한 종류입니다. 카운팅 기계는 문제에 대한 서로 다른 해의 수를 반환합니다. 그래프에서 해밀토니안 사이클의 수를 세는 것은 #P-완전 문제로, 그래프가 해밀토니안임을 증명하기 때문에 NP-난해(그리고 아마도 더 어려울 것입니다)합니다. 카운팅 문제는 해당 결정 문제가 다항 시간 내에 풀 수 있는 경우에도 #P-완전 문제가 될 수 있으며, 이는 영구적이고 완벽한 매칭으로 나타납니다.","#P is the class of problems solvable on a “counting” machine in polynomial time. A counting machine returns the number of distinct solutions to a problem. Counting the number of Hamiltonian cycles in a graph is a #P-complete problem that is trivially NP-hard (and presumably harder), since any count greater than zero proves that the graph is Hamiltonian. Counting problems can be #P-complete even if the corresponding decision problem can be solved in polynomial time, as shown by the permanent and perfect matchings.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정수 프로그래밍과 NP 완전성에 대해 무엇을 말할 수 있을까요?,What can be said of integer programming in and NP-completeness?,정수 또는 혼합 프로그램을 최적으로 해결하는 NP-완전. 그러나 실제로는 상당히 잘 작동하는 정수 프로그래밍 기법이 있습니다.,"NP-complete to solve integer or mixed programs to optimality. However, there are integer programming techniques that work reasonably well in practice.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
선형 프로그래밍 최대화 문제를 최소화 문제로 어떻게 변환할 수 있나요?,How can you convert a linear programming maximization problem into a minimization problem?,최대화 문제를 최소화 문제로 변환하려면 목적 함수의 각 계수에 -1을 곱하기만 하면 됩니다. 나머지 문제는 모델에 슬랙 변수를 추가하여 해결할 수 있습니다. 자세한 내용은 선형 프로그래밍 교과서를 참조하세요,"To convert a maximization problem to a minimization one, simply multiply each coefficient of the objective function by −1. The remaining problems can be solved by adding slack variables to the model. See any textbook on linear programming for details",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
NC란 무엇인가요?,What is NC?,NC(닉 클래스)는 병렬 컴퓨터에서 효율적으로 해결할 수 있는 문제로 생각할 수 있습니다. NC는 다항식 시간 순차 계산으로 다항식으로 시뮬레이션할 수 있기 때문에 P의 하위 집합입니다.,NC (Nick's class) can be thought of as the problems that can be efficiently solved on a parallel computer. NC is a subset of P because polylogarithmic parallel computations can be simulated by polynomial-time sequential ones.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
P-완전이란 무엇인가요?,What is P-Complete?,"결정 문제가 P에 속하고 P의 모든 문제를 적절히 축소하여 P로 축소할 수 있는 경우, P-완전 문제(복잡도 클래스 P에 대해 완전 문제)는 P-완전 문제입니다.",A decision problem is P-complete (complete for the complexity class P) if it is in P and every problem in P can be reduced to it by an appropriate reduction.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메르센 트위스터는 무엇인가요?,What is the Mersenne twister?,메르센 트위스터는 2^19937 - 1 주기의 빠른 난수 생성기입니다.,Mersenne twister is a fast random number generator of period 2^19937 − 1.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
무작위 럼버 생성에서 주기성이 중요한 이유는 무엇인가요?,Why is periodicity important in random rumber generation?,"이 기간은 난수 생성기가 수열을 반복하기 전까지 숫자를 생성하는 시간을 정의합니다. 
PRNG의 주기는 이렇게 정의됩니다: 모든 시작 상태에서 시퀀스의 반복 없는 접두사 길이의 최대값입니다. 주기는 일반적으로 비트 단위로 측정되는 상태의 수에 따라 제한됩니다. 그러나 주기의 길이는 각 비트의 ""상태""가 추가될 때마다 두 배가 될 수 있기 때문에, 많은 실용적인 응용을 위해 주기가 충분히 긴 PRNG를 쉽게 구축할 수 있습니다.","The period defines how long a random number generator will generate numbers before it repeats the sequence. 
The period of a PRNG is defined thus: the maximum, over all starting states, of the length of the repetition-free prefix of the sequence. The period is bounded by the number of the states, usually measured in bits. However, since the length of the period potentially doubles with each bit of ""state"" added, it is easy to build PRNGs with periods long enough for many practical applications.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
카마이클 숫자란 무엇인가요?,What are Carmichael numbers?,카마이클 수는 페르마의 작은 정리를 항상 만족하는 합성 정수입니다. 이들은 의사 소수입니다.,Carmichael numbers are composite integers that always satisfy Fermat's little theorem. They are pseudo-primes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
컨볼루션이란 무엇인가요?,What is a convolution?,"컨볼루션은 두 함수(f와 g)에 대한 수학적 연산으로, 일반적으로 원래 함수 중 하나의 수정된 버전으로 간주되는 세 번째 함수를 생성합니다.","A convolution is a mathematical operation on two functions (f and g); it produces a third function, that is typically viewed as a modified version of one of the original functions.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
FFT의 수학적 응용에는 무엇이 있나요?,What is in mathematical application of FFT?,두 개의 n비트 숫자를 O(n lg n lg n) 시간에 곱하는 FFT 기반 알고리즘은 Schonhagen과 Strassen에 의해 결정됩니다.,FFT-based algorithm that multiplies two n-bit numbers in O(n lg n lg lg n) time is due to Schonhagen and Strassen.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메모리가 제한된 디스크에서 매우 많은 양의 데이터를 어떻게 정렬할 수 있나요?,How can you sort extremely large amount of data on disk with limited memory?,"외부 정렬에 대한 가장 간단한 접근 방식은 데이터를 B-트리에 로드한 다음 트리의 순서대로 순회하여 정렬된 순서대로 키를 읽어내는 것입니다. 실제 고성능 정렬 알고리즘은 다중 경로 병합을 기반으로 합니다. 데이터의 일부가 포함된 파일은 빠른 내부 정렬을 사용하여 실행으로 정렬된 다음, 이러한 정렬된 실행이 있는 파일은 2방향 또는 k방향 병합을 사용하여 단계적으로 병합됩니다. 복잡한 병합 패턴과 외부 저장 장치의 속성에 기반한 버퍼 관리를 사용하여 성능을 최적화할 수 있습니다.","The simplest approach to external sorting loads the data into a B-tree and then does an in-order traversal of the tree to read the keys off in sorted order. Real high-performance sorting algorithms are based on multiway-mergesort. Files containing portions of the data are sorted into runs using a fast internal sort, and then files with these sorted runs are merged in stages using 2- or k-way merging. Complicated merging patterns and buffer management based on the properties of the external storage device can be used to optimize performance.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
퀵소트를 최적화하려면 어떻게 해야 하나요?,How can you optimize quicksort?,"• 무작위 배정을 사용하세요 – 정렬하기 전에 키를 무작위로 순열하세요.
• 중앙값 3 - 피벗 요소의 경우 배열의 첫 번째, 마지막, 중간 요소의 중앙값을 사용합니다. 
• Insertion Sort을 위해 작은 서브어레이를 남겨두기 - 퀵소트 재귀를 종료하고 Insertion Sort로 전환하는 것은 서브어레이가 작아질 때, 예를 들어 20개 이하의 요소로 전환하는 것이 합리적입니다.
• 작은 partition을 먼저 수행하세요 – 컴파일러가 꼬리 재귀를 제거할 만큼 똑똑하다고 가정합니다.","• Use randomization – randomly permute the keys before sorting.
• Median of three – For your pivot element, use the median of the first, last, and middle elements of the array. 
• Leave small subarrays for insertion sort – Terminating the quicksort recursion and switching to insertion sort makes sense when the subarrays get small, say fewer than 20 elements.
• Do the smaller partition first – Assuming that your compiler is smart enough to remove tail recursion.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
래딕스란 무엇인가요?,What is a radix?,밑변 또는 반지름은 반지름 점의 왼쪽에 있는 각 숫자에 대해 연속적인 거듭제곱으로 올리는 값입니다(소수점이라는 용어는 소수점에만 적용된다는 점에 유의하세요).,"The base, or radix, is the value that we raise to successive powers for each digit to the left of the radix point (note that the term decimal point only applies to decimal numbers).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16 * 2?,16 * 2?,32,32,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16 * 3?,16 * 3?,48,48,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16 * 4?,16 * 4?,64,64,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16 * 5?,16 * 5?,80,80,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16 * 6?,16 * 6?,96,96,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16 * 7?,16 * 7?,112,112,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16 * 8?,16 * 8?,128,128,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16 * 9?,16 * 9?,144,144,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16 * 10?,16 * 10?,160,160,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16 * 16?,16 * 16?,256,256,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16 * 11?,16 * 11?,176,176,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16 * 12?,16 * 12?,192,192,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16 * 13?,16 * 13?,208,208,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16 * 14?,16 * 14?,224,224,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
16 * 15?,16 * 15?,240,240,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
표준 인텔 80x86 워드 크기는 무엇인가요?,What is the standard Intel 80x86 word size?,16비트,16 bits,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
약하게 연결된 그래프란 무엇인가요?,What is a weakly connected graph?,방향 그래프는 가장자리의 방향을 무시하고 연결된 경우 약하게 연결됩니다. 따라서 약하게 연결된 그래프는 하나의 조각으로 구성됩니다. 방향 그래프는 모든 정점 쌍 사이에 방향 경로가 있는 경우 강하게 연결됩니다. 이 구분은 모든 도시의 단방향 및 양방향 도로 네트워크를 고려하여 가장 명확하게 할 수 있습니다. 네트워크는 두 위치 모두에서 합법적으로 운전할 수 있는 경우 강하게 연결됩니다. 네트워크는 두 위치 모두에서 합법적으로 또는 불법적으로 운전할 수 있는 경우 약하게 연결됩니다. 네트워크는 A에서 B로 운전할 수 있는 방법이 없는 경우 연결이 끊어집니다.,"A directed graph is weakly connected if it would be connected by ignoring the direction of edges. Thus, a weakly connected graph consists of a single piece. A directed graph is strongly connected if there is a directed path between every pair of vertices. This distinction is best made clear by considering the network of one- and two-way streets in any city. The network is strongly connected if it is possible to drive legally between every two positions. The network is weakly connected when it is possible to drive legally or illegally between every two positions. The network is disconnected if there is no possible way to drive from a to b.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프가 나무인지 어떻게 알 수 있나요?,How can you tell if a graph is a tree?,깊이 우선 검색을 사용하여 연결 여부를 테스트할 수 있습니다. 그래프가 연결되어 있고 n개의 정점에 대해 n - 1개의 간선이 있는 경우 트리가 됩니다.,"Depth-first search can be used to test whether it is connected. If the graph is connected and has n − 1 edges for n vertices, it is a tree.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
위상 정렬을 수행하려면 어떤 종류의 그래프가 필요하나요?,What kind of graph do you have to have in order to perform a topological sort?,DAG만 위상적으로 정렬할 수 있습니다. 왜냐하면 모든 방향성 사이클은 작업의 선형 순서에 내재된 모순을 제공하기 때문입니다.,"Only DAGs can be topologically sorted, since any directed cycle provides an inherent contradiction to a linear order of tasks.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
모든 DAG에서 중요한 것은 무엇인가요?,What is important about every DAG?,모든 DAG는 위상적으로 정렬될 수 있으므로 작업 간의 합리적인 우선순위 제약 조건에 대해 항상 최소한 하나의 스케줄이 있어야 합니다.,"Every DAG can be topologically sorted, so there must always be at least one schedule for any reasonable precedence constraints among jobs.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DAG를 위상학적으로 정렬하려면 어떻게 해야 하나요?,How can you topologically sort a DAG?,DFS 완료 시간을 줄이는 방법으로 정점을 정렬합니다.,Ordering the vertices in terms of decreasing DFS finishing time.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프에서 가능한 위상 정렬의 수에 대해 무엇을 말할 수 있나요?,What can you say about the number of possible topological sorts on a graph?,선형 확장의 수(위상 정렬 방법의 수)를 세는 문제는 NP-난해합니다.,The problem of counting the number of linear extensions (the number of ways to order a topological sort) is NP-hard.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프를 비순환적으로 만들기 위해 간선을 제거하는 것은 어려운 문제인가요?,"In removing edges in order to make a graph acyclic, is this a hard problem?",그래프를 비순환적으로 만들기 위해 최소 간선 수를 제거하면 위상 정렬이 NP 완료됩니다.,Removing the minimum number of edges in order to make a graph acyclic so that you can topological sort is NP complete.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Prim의 알고리즘과 Kruskal의 알고리즘 중 어느 것이 더 나은가요?,Which is better: Prim's algorithm or Kruskal's algorithm?,"Prim의 알고리즘은 O(n^2)에서 실행되는 반면, Kruskal의 알고리즘은 O(m log m) 시간이 걸립니다. 따라서 Prim의 알고리즘은 밀도가 높은 그래프에서 더 빠른 반면, Kruskal의 알고리즘은 희소 그래프에서 더 빠릅니다.","Prim's algorithm runs in O(n^2), while Kruskal's algorithm takes O(m log m) time. Thus Prim's algorithm is faster on dense graphs, while Kruskal's is faster on sparse graphs.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
무방향 그래프에서 최단 경로를 어떻게 찾을 수 있나요?,How can you find shortest path in an undirected graph?,"그래프에 가중치가 없는 경우, 소스 정점에서 시작하는 간단한 너비 우선 검색을 통해 선형 시간 내에 다른 모든 정점으로 가는 최단 경로를 찾을 수 있습니다.","If your graph is unweighted, a simple breadth-first search starting from the source vertex will find the shortest path to all other vertices in linear time.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DAG에서 최단 경로를 어떻게 찾을 수 있나요?,How can you find shortest paths on a DAG?,방향성 비순환 그래프에서 최단 경로는 선형 시간 내에 찾을 수 있습니다. 모든 간선이 소스 s에서 시작하여 왼쪽에서 오른쪽으로 이동하도록 정점을 정렬하기 위해 위상 정렬을 수행합니다.,Shortest paths in directed acyclic graphs can be found in linear time. Perform a topological sort to order the vertices such that all edges go from left to right starting from source s.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가장 짧은 간단한 사이클을 어떻게 찾을 수 있나요?,How can you find the shortest simple cycle?,"가장 짧은 단순 사이클을 찾기 위해 가장 쉬운 접근 방식은 i에서 다른 모든 정점까지의 최단 경로 길이를 계산한 다음, 각 정점에서 i까지의 허용 가능한 간선이 있는지 명시적으로 확인하는 것입니다.","To find the shortest simple cycle, the easiest approach is to compute the lengths of the shortest paths from i to all other vertices, and then explicitly check whether there is an acceptable edge from each vertex back to i.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프에서 가장 긴 주기를 어떻게 찾을 수 있나요?,How can you find the longest cycle in a graph?,그래프에서 가장 긴 사이클을 찾는 것은 해밀토니안 사이클을 특수한 경우로 포함하므로 NP-완전입니다.,"Finding the longest cycle in a graph includes Hamiltonian cycle as a special case, so it is NP-complete.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
전처리는 A* 시간에 어떤 영향을 미치나요?,How does preprocessing affect A* times?,"골드버그, 카플란, 베르넥은 2시간의 전처리 후 전국 규모의 도로망에서 포인트 투 포인트 쿼리에 1밀리초 만에 응답할 수 있는 A ∗ 구현 방식을 설명합니다.","Goldberg, Kaplan, and Werneck describe an implementation of A∗ capable of answering point-to-point queries in one millisecond on national-scale road networks after two hours of preprocessing.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
전이적 폐쇄란 무엇이며 어떻게 기록되나요?,What is transitive closure and how is it recorded?,트랜지티브 클로저는 도달 가능성 질문(y에서 x로 갈 수 있나요?)을 효율적으로 해결할 수 있는 데이터 구조를 구축하는 것으로 생각할 수 있습니다. 트랜지티브 클로저를 구성한 후 적절한 행렬 항목을 보고하기만 하면 모든 도달 가능성 질문에 일정한 시간 내에 답변할 수 있습니다.,"Transitive closure can be thought of as establishing a data structure that makes it possible to solve reachability questions (can I get to x from y?) efficiently. After constructing the transitive closure, all reachability queries can be answered in constant time by simply reporting the appropriate matrix entry.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
전이적 감소란 무엇인가요?,What is transitive reduction?,"전이 감소(최소 등가 디그래프라고도 함)는 전이 폐쇄의 역 연산으로, 동일한 도달 가능성 속성을 유지하면서 가장자리의 수를 줄이는 것을 말합니다. G의 전이 폐쇄는 G의 전이 축소의 전이 폐쇄와 동일합니다.","Transitive reduction (also known as minimum equivalent digraph) is the inverse operation of transitive closure, namely reducing the number of edges while maintaining identical reachability properties. The transitive closure of G is identical to the transitive closure of the transitive reduction of G.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
무방향 그래프에 오일러 사이클이 포함되어 있는지 어떻게 알 수 있나요?,How can you tell if an undirected graph contains a Eulerian cycle?,"무방향 그래프에는 오일러 사이클이 포함되어 있습니다 
(1) 연결되어 있습니다 
(2) 각 꼭짓점은 짝수 차수입니다.","An undirected graph contains an Eulerian cycle iff 
(1) it is connected, and 
(2) each vertex is of even degree.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
무방향 그래프에 오일러 경로가 포함되어 있는지 어떻게 알 수 있나요?,How can you tell if an undirected graph contains an Eulerian path?,"무방향 그래프에는 오일러 경로 if가 포함되어 있습니다 
(1) 연결되어 있습니다 
(2) 두 정점을 제외한 모든 정점은 짝수 차수입니다. 이 두 정점은 모든 경로의 시작점과 끝점이 됩니다.","An undirected graph contains an Eulerian path iff 
(1) it is connected, and 
(2) all but two vertices are of even degree. These two vertices will be the start and end points of any path.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
방향 그래프에 오일러 사이클이 포함되어 있는지 어떻게 확인할 수 있나요?,How can you determine if a directed graph contains an Eulerian cycle?,"유향 그래프는 오일러 사이클을 포함하고 있으며, 만약 (f) (1) 강하게 연결되어 있고, (2) 각 정점은 차수 내에서 차수가 외부와 동일합니다.","A directed graph contains an Eulerian cycle iff (1) it is strongly-connected, and (2) each vertex has the same in-degree as out-degree.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
방향 그래프에 오일러 경로가 포함되어 있는지 어떻게 알 수 있나요?,How can you tell if a directed graph contains a Eulerian path?,"방향 그래프에는 x에서 y iff까지의 오일러 경로가 포함되어 있습니다 
(1) 연결되어 있습니다 
(2) 다른 모든 정점은 차수 내의 정점과 차수 내의 정점이 같으며, x와 y는 차수 내의 정점이 차수 내의 degrees보다 각각 하나 더 적고 하나 더 많습니다.","A directed graph contains an Eulerian path from x to y iff 
(1) it is connected, and 
(2) all other vertices have the same in-degree as out-degree, with x and y being vertices with in-degree one less and one more than their out-degrees, respectively.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최소 정점 차수의 중요성은 무엇인가요?,What is the importance of minimum vertex degree?,최소 정점 차수는 간선과 정점 연결성 모두에 대한 상한입니다. 왜냐하면 모든 이웃을 삭제하거나 간선을 모든 이웃으로 자르면 그래프가 하나의 큰 정점과 하나의 단일 정점 구성 요소로 분리되기 때문입니다.,"The minimum vertex degree is an upper bound for both edge and vertex connectivity, since deleting all its neighbors (or cutting the edges to all its neighbors) disconnects the graph into one big and one single-vertex component.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이중 연결 그래프는 무엇을 의미하나요?,What does a biconnected graph mean?,"단일 정점 삭제가 G를 분리하기에 충분하지 않은 경우 G는 이중 연결이라고 합니다. 이러한 약점인 모든 정점을 조음 정점이라고 합니다. 브리지는 간선에 대한 유사한 개념으로, 삭제로 인해 그래프가 분리되는 단일 간선을 의미합니다.","We say that G is biconnected if no single vertex deletion is sufficient to disconnect G. Any vertex that is such a weak point is called an articulation vertex. A bridge is the analogous concept for edges, meaning a single edge whose deletion disconnects the graph.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최대 유량과 최소 절단의 관계는 무엇인가요?,What is the relation of maximum flow and minimum cut?,"G에서 vi, vj 사이의 최대 흐름은 vi와 vj를 분리하기 위한 가장 작은 간선 집합의 무게입니다.","The maximum flow between vi, vj in G is exactly the weight of the smallest set of edges to disconnect vi from vj.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"주어진 그래프에 대해 ""좋은"" 그래프를 그리는 휴리스틱 중 하나는 무엇인가요?","What is one heuristic to draw ""nice"" graphs for a given graph?",먼저 빠르고 더러운 그림으로 정점을 원 위에 고르게 배치한 다음 정점 사이를 직선으로 그리는 것을 권장합니다. 이러한 그림은 프로그래밍하기 쉽고 빠르게 구성할 수 있습니다. 이러한 그림은 세 개의 정점이 선형이 아니기 때문에 두 개의 모서리가 서로를 가리지 않는다는 상당한 장점이 있습니다. 이러한 아티팩트는 내부 정점을 그림에 허용하는 즉시 피하기 어려울 수 있습니다. 원형 그림에서 예상치 못한 즐거움은 정점이 그래프에 삽입된 순서대로 나타나기 때문에 때때로 드러나는 대칭성입니다. 시뮬레이션 어닐링을 사용하여 원형 정점 순서를 순열하여 교차점이나 가장자리 길이를 최소화하여 그림을 크게 개선할 수 있습니다. 좋은 범용 그래프 그리기 휴리스틱은 그래프를 스프링 시스템으로 모델링한 다음 에너지 최소화를 사용하여 정점을 공간화합니다. 인접한 정점은 분리의 로그에 비례하는 힘으로 서로 끌어당기고 인접하지 않은 모든 정점은 분리 거리에 비례하는 힘으로 서로 밀어냅니다. 이러한 가중치는 모든 모서리를 최대한 짧게 유지하면서 정점을 분리할 수 있는 인센티브를 제공합니다. 이러한 시스템의 동작은 특정 시간에 각 정점에 작용하는 힘을 결정한 다음 각 정점을 적절한 방향으로 소량 이동시킴으로써 근사화할 수 있습니다. 이러한 반복이 여러 번 반복되면 시스템은 합리적인 그림에서 안정화되어야 합니다.,"As a first quick and dirty drawing, I recommend simply spacing the vertices evenly on a circle, and then drawing the edges as straight lines between vertices. Such drawings are easy to program and fast to construct. They have the substantial advantage that no two edges will obscure each other, since no three vertices will be collinear. Such artifacts can be hard to avoid as soon as you allow internal vertices into your drawing. An unexpected pleasure with circular drawings is the symmetry sometimes revealed because vertices appear in the order they were inserted into the graph. Simulated annealing can be used to permute the circular vertex order to minimize crossings or edge length, and thus significantly improve the drawing. A good, general purpose graph-drawing heuristic models the graph as a system of springs and then uses energy minimization to space the vertices. Let adjacent vertices attract each other with a force proportional to (say) the logarithm of their separation, while all nonadjacent vertices repel each other with a force proportional to their separation distance. These weights provide incentive for all edges to be as short as possible, while spreading the vertices apart. The behavior of such a system can be approximated by determining the force acting on each vertex at a particular time and then moving each vertex a small amount in the appropriate direction. After several such iterations, the system should stabilize on a reasonable drawing.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최대 클리크를 찾는 것이 NP-완전인가요?,Is finding a maximum clique NP-Complete?,네.,Yes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
평면 그래프의 최대 클리크 크기는 얼마인가요?,What is the max clique size for a planar graph?,"평면 그래프는 크기가 4보다 큰 클리크를 가질 수 없으며, 그렇지 않으면 평면 그래프가 될 수 없습니다.","Planar graphs cannot have cliques of a size larger than four, or else they cease to be planar.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
브랜치 앤 바운드란 무엇인가요?,What is branch and bound?,"일반적으로 각 결정이 가장자리로 표시되는 의사 결정 트리의 형태입니다. 이 트리의 잎은 가능한 모든 솔루션의 집합입니다. 가장 최적화된 솔루션(즉, 잎 중 하나)을 찾기 위해 다음이 평가의 기초가 됩니다.
직관적으로 문제가 함수를 최적화하려는 함수에 대해 함수의 최대화(또는 거리를 최소화해야 하는 TSP의 경우 함수 최소화의 하한)를 요청하는 경우 루트에서 시작하여 상한을 계산하는 것입니다.","It usually of the form of a decision tree where each decision is represented by an edge. The leaves of this tree is the set of all possible solutions. To find the most optimized solution(i.e. one of the leaves) the following is the basis of evaluation.
The intuition is that you start from the root and calculate an upper bound if the problem asks the function to be maximized (or lower bound for function minimization in case of TSP where distance is to be minimized) for a function you want to optimize.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최대 독립 집합을 풀기 위한 휴리스틱이란 무엇인가요?,What is a heuristic for solving max independent set?,가장 간단한 합리적인 휴리스틱은 가장 낮은 차수의 정점을 찾아서 독립 집합에 추가한 다음 이를 포함한 모든 정점과 인접한 정점을 삭제하는 것입니다. 그래프가 비어 있을 때까지 이 과정을 반복하면 정점만 더하면 더 크게 만들 수 없기 때문에 최대 독립 집합이 됩니다.,"The simplest reasonable heuristic is to find the lowest-degree vertex, add it to the independent set, and then delete it and all vertices adjacent to it. Repeating this process until the graph is empty gives a maximal independent set, in that it can't be made larger by just adding vertices.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
버텍스 커버를 위한 간단한 휴리스틱이란 무엇인가요?,What is a simple heuristic for vertex cover?,"정점 커버에 대한 가장 간단한 휴리스틱은 정점을 가장 높은 차수로 선택하고 커버에 추가한 다음 인접한 모든 간선을 삭제한 다음 그래프가 비어 있을 때까지 반복합니다. 올바른 데이터 구조를 사용하면 선형 시간 내에 이 작업을 수행할 수 있으며, ""보통 꽤 좋은"" 커버를 생성해야 합니다. 그러나 이 커버는 특정 입력 그래프에 대한 최적의 커버보다 lg n배 더 나쁠 수 있습니다.","The simplest heuristic for vertex cover selects the vertex with highest degree, adds it to the cover, deletes all adjacent edges, and then repeats until the graph is empty. With the right data structures, this can be done in linear time, and should “usually” produce a “pretty good” cover. However, this cover might be lg n times worse than the optimal cover for certain input graphs.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정점 덮개에 대한 휴리스틱이란 무엇인가요?,What is a heuristic for vertex cover?,"그래프에서 임의의 간선 e를 선택하고, e와 정점을 공유하는 모든 간선을 삭제한 다음, 그래프가 간선을 벗어날 때까지 반복함으로써 최대 매칭을 점진적으로 구성할 수 있습니다. 최대 매칭에서 각 간선에 대한 두 정점을 모두 취하면 정점 덮개를 얻을 수 있습니다.","A maximal matching can be constructed incrementally, by picking an arbitrary edge e in the graph, deleting any edge sharing a vertex with e, and repeating until the graph is out of edges. Taking both of the vertices for each edge in a maximal matching gives us a vertex cover.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가중치가 없는 그래프에서 TSP의 특별한 경우는 무엇인가요?,What is a special case of TSP on an unweighted graph?,"그래프에 가중치가 없거나 모든 간선에 두 가지 가능한 비용 값 중 하나가 있는 경우, 문제는 해밀토니안 사이클을 찾는 것으로 축소됩니다.","If the graph is unweighted, or all the edges have one of two possible cost values, the problem reduces to finding a Hamiltonian cycle.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
TSP의 휴리스틱이란 무엇인가요?,What is a heuristic for TSP?,"휴리스틱은 사이트의 최소 신장 트리(MST)를 찾는 것으로 시작한 다음 결과 트리를 깊이 우선적으로 검색합니다. DFS 과정에서 우리는 n개의 - 1개의 간선 각각에 대해 정확히 두 번 걸으며, 한 번은 새로운 정점을 발견하기 위해 내려가는 것이고, 한 번은 백트랙할 때 올라가는 것입니다. 이제 정점이 발견된 시점을 기준으로 순서를 정하여 투어를 정의합니다. 그래프가 삼각형 부등식을 따르는 경우, 결과 투어는 최적의 TSP 투어 길이의 최대 두 배가 됩니다. 실제로는 일반적으로 최적보다 15%에서 20% 더 좋습니다. 또한, 실행 시간은 평면 내 점의 경우 O(n lg n)에 불과한 MST를 계산하는 시간에 의해 제한됩니다.","The heuristic starts by finding the minimum spanning tree (MST) of the sites, and then does a depth-first search of the resulting tree. In the course of DFS, we walk over each of the n − 1 edges exactly twice: once going down to discover a new vertex, and once going up when we backtrack. Now define a tour by ordering the vertices by when they were discovered. If the graph obeys the triangle inequality, the resulting tour is at most twice the length of the optimal TSP tour. In practice, it is usually better, typically 15% to 20% over optimal. Furthermore, the running time is bounded by that of computing the MST, which is only O(n lg n) in the case of points in the plane.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
하이퍼로그란 무엇인가요?,What is HyperLogLog?,"HyperLogLog는 카운트 구별 문제를 해결하기 위한 알고리즘으로, 멀티셋에서 구별되는 요소의 수를 근사화합니다.

HyperLogLog 알고리즘의 기초는 균일하게 분포된 난수의 다중 집합의 기수를 집합 내 각 수의 이진 표현에서 선행 0의 최대 수를 계산하여 추정할 수 있다는 관찰입니다. 관찰된 선행 0의 최대 수가 n인 경우, 집합 내 서로 다른 요소의 수에 대한 추정치는 2^n입니다.

HyperLogLog 알고리즘에서는 원래 멀티셋의 각 요소에 해시 함수를 적용하여 원래 멀티셋과 동일한 기수를 갖는 균일하게 분포된 난수의 멀티셋을 얻습니다. 그런 다음 위의 알고리즘을 사용하여 이 무작위로 분포된 집합의 기수를 추정할 수 있습니다.","HyperLogLog is an algorithm for the count-distinct problem, approximating the number of distinct elements in a multiset.

The basis of the HyperLogLog algorithm is the observation that the cardinality of a multiset of uniformly distributed random numbers can be estimated by calculating the maximum number of leading zeros in the binary representation of each number in the set. If the maximum number of leading zeros observed is n, an estimate for the number of distinct elements in the set is 2^n.

In the HyperLogLog algorithm, a hash function is applied to each element in the original multiset, to obtain a multiset of uniformly distributed random numbers with the same cardinality as the original multiset. The cardinality of this randomly distributed set can then be estimated using the algorithm above.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프 분할이란 무엇인가요?,What is graph partitioning?,정점을 대략 같은 크기의 m개의 부분 집합으로 분할하여 부분 집합을 아우르는 총 엣지 비용이 최대 k가 되도록 합니다.,Partition the vertices into m roughly equal-sized subsets such that the total edge cost spanning the subsets is at most k.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프 분할이 NP-완전한가요?,Is graph partition NP-complete?,더 나은 분할 기준은 정점을 대략 같은 크기의 조각으로 분할하는 작은 절단을 찾습니다. 안타깝게도 이 문제는 NP-완전 문제입니다. 다행히 아래에서 설명하는 휴리스틱은 실제로 잘 작동합니다.,"A better partition criterion seeks a small cut that partitions the vertices into roughly equal-sized pieces. Unfortunately, this problem is NP-complete. Fortunately, the heuristics discussed below work well in practice.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프의 3색과 4색의 난이도 차이는 무엇인가요?,What is the difficulty difference between 3-coloring and 4-coloring a graph?,"유명한 4색 정리에 따르면 모든 평면 그래프는 최대 4가지 다른 색을 사용하여 정점 색칠을 할 수 있습니다. 평면 그래프에서 4색을 찾는 효율적인 알고리즘은 알려져 있지만, 주어진 평면 그래프가 3색 가능한지 여부를 결정하는 것은 NP-완전합니다.","The famous four-color theorem states that every planar graph can be vertex colored using at most four distinct colors. Efficient algorithms for finding a four-coloring on planar graphs are known, although it is NP-complete to decide whether a given planar graph is three-colorable.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프의 색수를 결정하는 것이 NP-완전인가요?,Is determining the chromatic number of a graph NP-Complete?,"그래프의 색수를 계산하는 것은 NP-완전하기 때문에 정확한 해가 필요하다면 역추적에 의존해야 하며, 이는 특정 무작위 그래프를 색칠하는 데 놀라울 정도로 효과적일 수 있습니다.","Computing the chromatic number of a graph is NP-complete, so if you need an exact solution you must resort to backtracking, which can be surprisingly effective in coloring certain random graphs.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
브룩의 정리는 무엇인가요?,What is Brook's theorem?,"Brook의 정리에 따르면, 색수 χ(G) ≤ δ(G) + 1이며, 여기서 δ(G)는 G. 등식의 정점의 최대 차수입니다. 이는 색수가 3인 홀수 길이 사이클과 완전 그래프에 대해서만 성립합니다.","Brook's theorem states that the chromatic number χ(G) ≤ Δ(G) + 1, where Δ(G) is the maximum degree of a vertex of G. Equality holds only for odd-length cycles (which have chromatic number 3) and complete graphs.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가장자리 색수는 무엇인가요?,What is the edge-chromatic number?,"그래프의 가장자리 색을 입히는 데 필요한 최소 색상 수를 일부에서는 가장자리 색수라고 하고 다른 일부에서는 색지수라고 합니다. 짝수 길이 주기는 2가지 색으로 가장자리 색을 칠할 수 있는 반면, 홀수 길이 주기는 가장자리 색수가 3입니다.","The minimum number of colors needed to edge color a graph is called its edge-chromatic number by some and its chromatic index by others. Note that an even-length cycle can be edge-colored with 2 colors, while odd-length cycles have an edge-chromatic number of 3.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비징의 정리란 무엇인가요?,What is Vizing's theorem?,"비징의 정리에 따르면, 최대 정점 차수가 δ인 그래프는 최대 δ + 1 색상을 사용하여 엣지 컬러를 칠할 수 있습니다.",Vizing's theorem states that any graph with a maximum vertex degree of Δ can be edge colored using at most Δ + 1 colors.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프 동형사상의 난이도/복잡도에 대해 무엇을 말할 수 있나요?,What can you say about the difficulty/complexity of graph isomorphism?,"그래프 동형화에 대한 다항 시간 알고리즘은 알려져 있지 않지만, NP-완전 알고리즘도 알려져 있지 않습니다. 정수 인수분해와 함께, 이 알고리즘은 대략적인 계산 복잡성이 여전히 알려지지 않은 몇 안 되는 중요한 알고리즘 문제 중 하나입니다. 일반적인 통념은 P <> NP인 경우 동형화가 P와 NP-완전 사이에 있는 문제라는 것입니다.","No polynomial-time algorithm is known for graph isomorphism, but neither is it known to be NP-complete. Along with integer factorization, it is one of the few important algorithmic problems whose rough computational complexity is still not known. The conventional wisdom is that isomorphism is a problem that lies between P and NP-complete if P <> NP.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 행렬을 사용하여 경로를 계산하는 방법은 무엇인가요?,How can adjacency matrices be used to compute paths?,"G의 인접 행렬을 k번째 거듭제곱으로 올리면 Gk[i, j]가 i에서 j까지의 (단순하지 않은) 경로의 수를 세는 행렬이 됩니다.","Taking the adjacency matrix of G and raising it to the kth power gives a matrix where Gk[i, j] counts the number of (non-simple) paths from i to j.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동형사상-완전이라는 것은 무엇을 의미하나요?,What does it mean to be isomorphism-complete?,문제가 동형처럼 증명 가능하게 어려운 경우 동형 완전 문제라고 합니다.,A problem is said to be isomorphism-complete if it is provably as hard as isomorphism.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최소 슈타이너 트리의 난이도는 무엇인가요?,What is the difficulty of minimum Steiner tree?,"일반적인 최소 슈타이너 트리 문제는 NP-난해하며, 여전히 광범위한 제약 조건 하에 있습니다.","The general minimum Steiner tree problem is NP-hard, and remains so under a broad range of restrictions.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
슈타이너 트리를 찾기 위한 휴리스틱이란 무엇인가요?,What is a heuristic for finding Steiner trees?,"Construct a graph modeling your input, setting the weight of edge (i, j) equal to the distance from point i to point j. Find an MST of this graph. You are guaranteed a provably good approximation for both Euclidean and rectilinear Steiner trees.","Construct a graph modeling your input, setting the weight of edge (i, j) equal to the distance from point i to point j. Find an MST of this graph. You are guaranteed a provably good approximation for both Euclidean and rectilinear Steiner trees.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
유클리드 슈타이너 트리는 NP에 있나요?,Is Euclidean Steiner tree in NP?,유클리드 슈타이너 트리는 거리를 나타내는 데 있어 수치적인 문제가 있기 때문에 NP에 속하지 않는 것으로 알려져 있습니다.,"Euclidean Steiner tree is not known to be in NP, because of numerical issues in representing distances.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
좋은 피드백 엣지 세트를 어떻게 찾을 수 있나요?,How can I find a good feedback edge set?,효과적인 선형 시간 휴리스틱은 정점 정렬(위상 정렬)을 구성한 다음 잘못된 방향으로 가는 호를 삭제합니다. 정점 정렬의 경우 호의 절반 이상이 왼쪽에서 오른쪽으로 또는 오른쪽에서 왼쪽으로 이동해야 하므로 작은 분할을 피드백 세트로 사용하세요.,"An effective linear-time heuristic constructs a vertex ordering (topological sort) and then deletes any arc going in the wrong direction. At least half the arcs must go either left-to-right or right-to-left for any vertex order, so take the smaller partition as your feedback set.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
볼록 껍질과 그래프 직경 사이의 관계에 대해 무엇을 말할 수 있을까요?,What can be said of the relationship between convex hull and graph diameter?,"점 집합의 지름은 최대 거리만큼 떨어져 있는 점 쌍입니다. 
직경은 볼록 껍질의 두 지점 사이여야 합니다.","The diameter of a set of points is the pair of points that lie a maximum distance apart. 
The diameter must be between two points on the convex hull.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
삼각 측량 - 점 집합 또는 다면체의 내부를 삼각형으로 분할하려면 어떻게 해야 하나요?,Triangulation - how can you partition the interior of the point set or polyhedron into triangles?,"A triangulation in the plane is constructed by adding nonintersecting chords between the vertices until no more such chords can be added. The simplest such O(n lg n) algorithm first sorts the points by x-coordinate. It then inserts them from left to right as per the convex-hull algorithm, building the triangulation by adding a chord to each point newly cut off from the hull.","A triangulation in the plane is constructed by adding nonintersecting chords between the vertices until no more such chords can be added. The simplest such O(n lg n) algorithm first sorts the points by x-coordinate. It then inserts them from left to right as per the convex-hull algorithm, building the triangulation by adding a chord to each point newly cut off from the hull.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
보로노이 다이어그램이란 무엇인가요?,What is a Voronoi diagram?,보로노이 다이어그램은 주어진 사이트 집합 주변의 영향력 영역을 나타냅니다. 이러한 사이트가 맥도날드 레스토랑의 위치를 나타내는 경우 보로노이 다이어그램은 각 레스토랑 주변의 셀로 공간을 분할합니다. 특정 셀에 거주하는 각 사람에게 정의된 맥도날드는 빅맥을 구입하기에 가장 가까운 장소를 나타냅니다.,"Voronoi diagrams represent the region of influence around each of a given set of sites. If these sites represent the locations of McDonald's restaurants, the Voronoi diagram partitions space into cells around each restaurant. For each person living in a particular cell, the defining McDonald's represents the closest place to get a Big Mac.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you find the nearest neighbor of query point q from among a fixed set of points?,How can you find the nearest neighbor of query point q from among a fixed set of points?,"고정된 점 집합 S 중에서 쿼리 점 q의 가장 가까운 이웃을 찾는 것은 단순히 q를 포함하는 S의 보로노이 다이어그램에서 셀을 결정하는 문제입니다.
또는 kd-트리를 사용하여 포인트를 나누고 정복하세요.","Finding the nearest neighbor of query point q from among a fixed set of points S is simply a matter of determining the cell in the Voronoi diagram of S that contains q.
Or use a kd-tree to divide and conquer the points.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
맥도날드가 다른 레스토랑을 열고 싶다고 가정해 보겠습니다. 기존 맥도날드와의 간섭을 최소화하려면 가장 가까운 레스토랑에서 최대한 멀리 떨어져 있어야 합니다. 어떻게 찾을 수 있을까요?,"Suppose McDonald's wants to open another restaurant. To minimize interference with existing McDonald's, it should be located as far away from the closest restaurant as possible.  How can you find it?","이 위치는 항상 보로노이 다이어그램의 정점에 있으며, 모든 보로노이 정점을 통한 선형 시간 검색에서 찾을 수 있습니다.","This location is always at a vertex of the Voronoi diagram, and can be found in a linear-time search through all the Voronoi vertices.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
보로노이 정점이란 무엇인가요?,What is a Voronoi vertex?,보로노이 정점은 점들 중에서 가장 큰 빈 원의 중심을 정의합니다.,A Voronoi vertex defines the center of the largest empty circle among the points.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
델로네 삼각 측량이란 무엇인가요?,What is a Delaunay triangulation?,델로네 삼각 측량은 모든 삼각 측량에서 최소 각도를 최대화합니다(스키니 삼각 측량을 피합니다). 또한 보로노이 다이어그램의 쌍대 형태로 쉽게 구성할 수 있습니다.,"The Delaunay triangulation maximizes the minimum angle over all triangulations (avoids skinny triangles). Furthermore, it is easily constructed as the dual of the Voronoi diagram.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
2D 보로노이 다이어그램과 델로네 삼각 측량에 어떤 코드를 사용할 수 있나요?,What code can you use for 2D Voronoi diagrams and Delaunay triangulations?,"포춘스윕2는 보로노이 다이어그램과 델로네 삼각분할에 널리 사용되는 2D 코드로, C로 작성되었습니다. 이 코드는 보로노이 다이어그램만 있으면 간단하게 사용할 수 있습니다.","Fortune's Sweep2 is a widely used 2D code for Voronoi diagrams and Delaunay triangulations, written in C. This code is simple to work with if all you need is the Voronoi diagram.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
볼록 껍질과 다른 2D 기하학 알고리즘에 인기 있는 라이브러리는 무엇인가요?,What is a popular library for convex hull as well as other 2D geometric algorithms?,"Qhull은 2차원에서 약 8차원까지 유용한 인기 있는 저차원 볼록 껍질 코드입니다. 이 코드는 C로 작성되었으며 델로네 삼각분할, 보로노이 정점, 가장 먼 곳 보로노이 정점 및 반공간 교차를 구성할 수도 있습니다.","Qhull is a popular low-dimensional convex-hull code, useful for from two to about eight dimensions. It is written in C and can also construct Delaunay triangulations, Voronoi vertices, furthest-site Voronoi vertices, and half-space intersections.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
고차원 kd-트리를 사용하여 가장 가까운 이웃을 찾는 문제는 무엇인가요?,What is the problem in using a high-dimension kd-tree for finding nearest neighbors?,고차원 공간에서의 검색은 중심에서 거리가 r 이하인 모든 점을 나타내는 반지름 r의 구가 차원이 증가함에 따라 큐브에 비해 부피가 점점 더 적게 채워지기 때문에 어려워집니다. 따라서 점을 둘러싸는 부피로 분할하는 데이터 구조는 점점 더 효과적이지 않게 됩니다.,"Searches in high-dimensional spaces become hard because a sphere of radius r, representing all the points with distance ≤ r from the center, progressively fills up less volume relative to a cube as the dimensionality increases. Thus, any data structure based on partitioning points into enclosing volumes will become progressively less effective.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
임의의 고차원에서 근사적으로 가장 가까운 이웃 검색을 위한 라이브러리란 무엇인가요?,What is a library for approximate nearest neighbor searching in arbitrarily high dimensions?,ANN은 임의의 고차원에서 정확하고 근사적인 최근접 이웃 검색을 위한 C++ 라이브러리입니다. 최대 약 20차원에서 수십만 점 이상의 검색에 대해 우수한 성능을 발휘합니다. 유클리드 거리와 맨해튼 거리를 포함한 모든 lp 거리 노름을 지원합니다.,"ANN is a C++ library for both exact and approximate nearest neighbor searching in arbitrarily high dimensions. It performs well for searches over hundreds of thousands of points in up to about 20 dimensions. It supports all lp distance norms, including Euclidean and Manhattan distance.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
고차원 데이터 세트에서 가장 가까운 이웃 및 직교 범위 쿼리를 시각화하고 실험하는 도구는 무엇인가요?,What is a tool for visualizing and experimenting with nearest-neighbor and orthogonal-range queries in high-dimensional data sets?,"레인저는 다차원 검색 트리를 사용하여 고차원 데이터 세트에서 최근접 이웃 및 직교 범위 쿼리를 시각화하고 실험하는 도구입니다. 레인저는 네 가지 다른 검색 데이터 구조를 지원합니다: 순진한 kd-트리, 중앙값 kd-트리, 비직교 kd-트리, 그리고 유리점 트리입니다.","Ranger is a tool for visualizing and experimenting with nearest-neighbor and orthogonal-range queries in high-dimensional data sets, using multidimensional search trees. Four different search data structures are supported by Ranger: naive kd-trees, median kd-trees, nonorthogonal kd-trees, and the vantage point tree.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
고차원 범위 검색을 위한 유일한 실행 가능한 솔루션은 무엇일까요?,What turns out to be the only viable solution for high-dimensional range search?,kd-트리는 평면에서 잘 작동할 가능성이 높습니다. 고차원에서는 문제에 대한 유일한 실행 가능한 해결책을 제공합니다.,"kd-trees are likely to work just fine in the plane. In higher dimensions, they provide the only viable solution to the problem.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
쓰레기통 포장은 NP-완전인가요?,Is bin-packing NP-Complete?,가장 기본적으로 들리는 빈 패킹 문제조차도 NP-완전 문제입니다.,Even the most elementary-sounding bin-packing problems are NP-complete.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
쓰레기통 포장에 가장 적합한 휴리스틱은 무엇인가요?,What is the best heuristic for bin packing?,"분석적 및 실증적 결과에 따르면 첫 번째 적합도 감소가 가장 좋은 휴리스틱입니다. 가장 큰 물체가 먼저이고 가장 작은 물체가 마지막이 되도록 크기가 작은 순서대로 객체를 정렬합니다. 각 객체를 공간이 있는 첫 번째 빈에 하나씩 삽입합니다. 빈에 공간이 없는 경우 다른 빈을 시작해야 합니다. 1차원 빈 패킹의 경우 필요 이상으로 22% 이상의 빈을 필요로 하지 않으며 일반적으로 훨씬 더 나은 성능을 발휘합니다. 첫 번째 적합도 감소는 부피가 큰 물체를 먼저 포장하고 작은 물체가 균열을 채울 수 있기를 바라는 직관적인 매력이 있습니다.
첫 번째 맞춤 감소는 O(n lg n + bn) 시간 내에 쉽게 구현할 수 있으며, 여기서 b ≤ min(n, m)은 실제로 사용된 빈의 수입니다. 각 삽입 시 빈을 선형으로 스윕하기만 하면 됩니다. 이진 트리를 사용하여 각 빈에 남아 있는 공간을 추적함으로써 더 빠른 O(n lg n) 구현이 가능합니다.","Analytical and empirical results suggest that first-fit decreasing is the best heuristic. Sort the objects in decreasing order of size, so that the biggest object is first and the smallest last. Insert each object one by one into the first bin that has room for it. If no bin has room, we must start another bin. In the case of one-dimensional bin packing, this can never require more than 22% more bins than necessary and usually does much better. First-fit decreasing has an intuitive appeal to it, for we pack the bulky objects first and hope that little objects can fill up the cracks.
First-fit decreasing is easily implemented in O(n lg n + bn) time, where b ≤ min(n, m) is the number of bins actually used. Simply do a linear sweep through the bins on each insertion. A faster O(n lg n) implementation is possible by using a binary tree to keep track of the space remaining in each bin.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
중심축 변환이란 무엇인가요?,What is medial-axis transformation?,"중간축 변환은 다각형을 얇게 만들거나 때로는 골격을 찾는 데 유용합니다. 목표는 다각형의 모양을 간단하고 견고하게 표현하는 것입니다.

다각형 P의 중간 축 변환은 단순히 P. 내에 있는 선분 보로노이 다이어그램의 일부입니다. 따라서 모든 선분 보로노이 다이어그램 코드는 다각형을 얇게 만들기에 충분합니다.","The medial-axis transformation is useful in thinning a polygon, or as is sometimes said, finding its skeleton. The goal is to extract a simple, robust representation of the shape of the polygon.

The medial-axis transform of a polygon P is simply the portion of the line-segment Voronoi diagram that lies within P. Any line-segment Voronoi diagram code thus suffices to do polygon thinning.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
삼각 측량이란 무엇인가요?,What is triangulation?,"삼각분할은 모든 다각형 분할 문제의 모체로, 다각형의 내부를 완전히 삼각형으로 분할합니다. 삼각형은 볼록하고 세 변만 있으므로 가장 기본적인 다각형입니다.","Triangulation is the mother of all polygon partitioning problems, where we partition the interior of the polygon completely into triangles. Triangles are convex and have only three sides, making them the most elementary possible polygon.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n-정점 다각형의 삼각분할로 몇 개의 삼각형을 만들 수 있나요?,How many triangles can be made from triangulations of an n-vertex polygon?,n-정점 다각형의 모든 삼각형은 정확히 n - 2개의 삼각형을 포함합니다.,All triangulations of an n-vertex polygon contain exactly n − 2 triangles.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
볼록 분해를 위한 헤르텔-멜혼 휴리스틱이란 무엇인가요?,What is the Hertel-Mehlhorn heuristic for convex decomposition?,대각선을 사용한 볼록 분해를 위한 Hertel-Mehlhorn 휴리스틱은 간단하고 효율적입니다. 다각형의 임의의 삼각 측량으로 시작하여 볼록 조각만 남기는 코드를 삭제합니다. 코드 삭제는 180도 이상의 내부 각도를 생성하는 경우에만 비볼록 조각을 생성합니다.,The Hertel-Mehlhorn heuristic for convex decomposition using diagonals is simple and efficient. It starts with an arbitrary triangulation of the polygon and then deletes any chord that leaves only convex pieces. A chord deletion creates a non-convex piece only if it creates an internal angle that is greater than 180 degrees.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프의 모양 유사성에 대한 휴리스틱이란 무엇인가요?,What is a heuristic for shape similarity of graphs?,형상 유사성에 대한 더 강력한 접근 방식은 얇아짐을 사용하여 각 객체에 대해 나무와 같은 골격을 추출하는 것입니다. 이 골격은 원래 형상의 많은 측면을 포착합니다. 이제 문제는 나무의 위상과 가장자리의 길이/기울기와 같은 특징을 사용하여 두 가지 골격의 형상을 비교하는 것으로 축소됩니다. 이 비교는 길이와 기울기가 충분히 비슷할 때마다 일치하도록 허용되는 서브그래프 동형사상의 한 형태로 모델링할 수 있습니다.,"A more powerful approach to shape similarity uses thinning to extract a tree-like skeleton for each object. This skeleton captures many aspects of the original shape. The problem now reduces to comparing the shape of two such skeletons, using such features as the topology of the tree and the lengths/slopes of the edges. This comparison can be modeled as a form of subgraph isomorphism, with edges allowed to match whenever their lengths and slopes are sufficiently similar.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
민코프스키 합은 무엇이며 무엇에 사용되나요?,What is a Minkowski sum and what is it used for?,"민코프스키 합은 적절한 방식으로 물체를 살찌울 수 있는 유용한 기하학적 연산입니다. 예를 들어, 다각형 장애물이 있는 방에서 다각형 로봇의 모션 계획에 대한 인기 있는 접근 방식은 로봇의 모양과 함께 민코프스키 합을 취하여 각 장애물을 살찌웁니다. 이렇게 하면 문제가 더 쉽게 해결되는 점 로봇의 경우로 줄어듭니다.","Minkowski sums are useful geometric operations that can fatten objects in appropriate ways. For example, a popular approach to motion planning for polygonal robots in a room with polygonal obstacles fattens each of the obstacles by taking the Minkowski sum of them with the shape of the robot. This reduces the problem to the (more easily solved) case of point robots.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정점 덮개의 난이도와 현재 근사 알고리즘의 한계는 무엇인가요?,What is the difficulty of vertex cover and what is the limit of current approximation algorithms?,"집합 덮개는 꼭짓점 덮개만큼 단단해야 하므로 NP-완전이기도 합니다. 사실 다소 어렵습니다. 근사 알고리즘은 꼭짓점 덮개에 대해 최적의 두 배 이상이지만, 집합 덮개에 대한 최적의 근사 알고리즘은 θ(lg n) 곱하기 최적입니다.","Set cover must be at least as hard as vertex cover, so it is also NP-complete. In fact, it is somewhat harder. Approximation algorithms do no worse than twice optimal for vertex cover, but the best approximation algorithm for set cover is Θ(lg n) times optimal.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
세트 커버의 효과적인 휴리스틱이란 무엇인가요?,What is an effective heuristic of set cover?,탐욕은 집합 커버를 위한 가장 자연스럽고 효과적인 휴리스틱입니다. 먼저 커버의 가장 큰 부분 집합을 선택한 다음 유니버설 세트에서 모든 요소를 삭제합니다. 커버되지 않은 나머지 가장 많은 요소가 포함된 부분 집합을 모두 커버될 때까지 반복적으로 추가합니다.,"Greedy is the most natural and effective heuristic for set cover. Begin by selecting the largest subset for the cover, and then delete all its elements from the universal set. We add the subset containing the largest number of remaining un-covered elements repeatedly until all are covered.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
세트 패킹의 휴리스틱이란 무엇인가요?,What is a heuristic of set packing?,"집합 패킹을 위한 올바른 휴리스틱은 탐욕적이며, 집합 커버와 유사합니다. 만약 우리가 많은 (몇 개의) 집합을 가진 패킹을 찾고 있다면, 가장 작은 (가장 큰) 부분 집합을 반복적으로 선택하고, 이와 충돌하는 모든 부분 집합을 S에서 삭제한 후 반복합니다. 일반적으로, 이 접근 방식을 철저한 탐색이나 무작위화(모의 어닐링 형태)로 보강하면 추가적인 계산 비용으로 더 나은 패킹을 얻을 가능성이 높습니다.","The right heuristics for set packing are greedy, and similar to those of set cover. If we seek a packing with many (few) sets, then we repeatedly select the smallest (largest) subset, delete all subsets from S that clash with it, and repeat. As usual, augmenting this approach with some exhaustive search or randomization (in the form of simulated annealing) is likely to yield better packings at the cost of additional computation.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
보이어-무어 알고리즘은 시간을 절약하는 데 어떤 역할을 하나요?,What does the Boyer-Moore algorithm do that saves time?,"보이어-무어 알고리즘은 오른쪽에서 왼쪽으로 텍스트와 패턴을 일치시키며 불일치 시 큰 텍스트 덩어리를 보지 않을 수 있습니다. 패턴이 아브라카다브라이고 텍스트의 열한 번째 문자가 x라고 가정해 보겠습니다. 이 패턴은 텍스트의 처음 11개 시작 위치 중 어느 위치에서도 일치할 수 없으므로 다음으로 테스트해야 하는 위치는 22번째 문자입니다. 운이 좋으면 n/m 문자만 테스트하면 됩니다. 보이어-무어 알고리즘은 불일치의 경우 두 세트의 점프 테이블을 포함하는데, 하나는 지금까지 일치한 패턴을 기반으로 하고 다른 하나는 불일치에서 볼 수 있는 텍스트 문자에 있습니다.","The Boyer-Moore algorithm matches the pattern against the text from right to left, and can avoid looking at large chunks of text on a mismatch. Suppose the pattern is abracadabra, and the eleventh character of the text is x. This pattern cannot match in any of the first eleven starting positions of the text, and so the next necessary position to test is the 22nd character. If we get very lucky, only n/m characters need ever be tested. The Boyer-Moore algorithm involves two sets of jump tables in the case of a mismatch: one based on pattern matched so far, the other on the text character seen in the mismatch.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
보이어무어의 공연과 주의사항은 무엇인가요?,What is the performance and caveats of Boyer-Moore?,"텍스트에서 여러 번 패턴이 발생할 것으로 예상되지 않는 한, 길이가 m > 5인 패턴은 실제로 그만한 가치가 있습니다. 최악의 성능은 O(n + rm)이며, 여기서 r은 t에서 p가 발생한 횟수입니다.","It is worth it in practice for patterns of length m > 5, unless the pattern is expected to occur many times in the text. Its worst-case performance is O(n + rm), where r is the number of occurrences of p in t.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
접미사 트리/어레이를 효율적으로 사용하는 방법은 무엇인가요?,What is an efficient use of suffix trees/arrays?,성경과 같은 특정 텍스트 데이터베이스를 반복적으로 검색하는 프로그램을 구축한다고 가정해 보겠습니다. 텍스트는 고정된 상태로 유지되므로 검색 쿼리 속도를 높이기 위해 데이터 구조를 구축하는 것이 좋습니다. 접미사 트리와 접미사 배열 데이터 구조는 이 작업에 적합한 도구입니다.,"Suppose you are building a program to repeatedly search a particular text database, such as the Bible. Since the text remains fixed, it pays to build a data structure to speed up search queries. The suffix tree and suffix array data structures are the right tools for the job.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동일한 패턴을 사용하여 많은 텍스트를 검색하는 더 나은 방법은 무엇인가요?,What is a better method for searching many texts using the same patterns?,"텍스트 스트림에서 더러운 단어를 걸러내는 프로그램을 만들고 있다고 가정해 보겠습니다. 여기서 패턴 집합은 안정적으로 유지되며 검색 텍스트는 자유롭게 변경할 수 있습니다. 이러한 애플리케이션에서는 k가 상당히 클 수 있는 k개의 다른 패턴이 모두 발생하는 경우를 찾아야 할 수도 있습니다.

각 패턴에 대해 선형 시간 스캔을 수행하면 O(k(m + n)) 알고리즘이 생성됩니다. k가 크면 더 나은 솔루션이 이러한 모든 패턴을 인식하고 문자 불일치 시 적절한 시작 상태로 돌아가는 단일 유한 오토마톤을 구축합니다. Aho-Corasick 알고리즘은 이러한 오토마톤을 선형 시간 내에 구축합니다. 패턴 인식 오토마톤을 최적화하면 공간 절약을 달성할 수 있습니다. 이 접근 방식은 원래 버전의 fgrep에서 사용되었습니다.","Suppose you are building a program to screen out dirty words from a text stream. Here, the set of patterns remains stable, while the search texts are free to change. In such applications, we may need to find all occurrences of any of k different patterns where k can be quite large.

Performing a linear-time scan for each pattern yields an O(k(m + n)) algorithm. If k is large, a better solution builds a single finite automaton that recognizes all of these patterns and returns to the appropriate start state on any character mismatch. The Aho-Corasick algorithm builds such an automaton in linear time. Space savings can be achieved by optimizing the pattern recognition automaton. This approach was used in the original version of fgrep.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
라빈카프의 공연에 대해 뭐라고 말할 수 있나요?,What can you say about the performance of Rabin-Karp?,"라빈-카프 알고리즘은 해시 함수를 사용하여 선형 예상 시간에 문자열 매칭을 수행합니다. 최악의 경우 시간은 이차적으로 유지되며, 실제로는 다른 문자 비교 방법보다 성능이 다소 떨어지는 것으로 보입니다.","The Rabin-Karp algorithm uses a hash function to perform string matching in linear expected time. Its worst-case time remains quadratic, and its performance in practice appears somewhat worse than other character comparison methods.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
큰 단어 크기(레지스터)를 활용하여 문자열 매칭을 수행하는 데 무엇을 사용할 수 있나요?,What can you use to take advantage of large word sizes (in registers) to do string matching?,"최근 문자열 매칭에 대한 접근 방식은 현대 컴퓨터가 64비트 단어에 대해 한 번에 연산을 수행할 수 있다는 사실을 활용합니다. 이는 8비트 ASCII 문자 8개를 담을 수 있을 만큼 충분히 길며, 각 연산에 대해 여러 번 비교하는 비트 병렬 알고리즘을 설계할 동기를 제공합니다.

기본 아이디어는 매우 영리합니다. 알파벳의 각 문자 α에 대해 비트 마스크 Bα를 구성하여 i번째 비트 Bα[i] = 1 if 패턴의 i번째 문자가 α이면 됩니다. 이제 텍스트 문자열의 위치 j에 대해 일치하는 비트 vector Mj가 있다고 가정해 봅시다. 따라서 패턴의 첫 번째 i 비트가 (j - i + 1)번째부터 j번째 문자까지 정확히 일치하도록 Mj[i] = 1 if 패턴의 위치 j에 대해 일치하는 비트 vector Mj가 있다고 가정해 보겠습니다. 우리는 두 가지 연산만으로 Mj+1의 모든 비트를 찾을 수 있으며, (1) Mj를 오른쪽으로 한 비트 이동시킨 다음 (2) Bα를 사용하여 비트 단위 AND를 수행합니다. 여기서 α는 위치에 있는 문자입니다.","A recent approach to string-matching exploits the fact that modern computers can do operations on (say) 64-bit words in a single gulp. This is long enough to hold eight 8-bit ASCII characters, providing motivation to design bit-parallel algorithms, which do more than one comparison with each operation.

The basic idea is quite clever. Construct a bit-mask Bα for each letter α of the alphabet, such that ith-bit Bα[i] = 1 iff the ith character of the pattern is α. Now suppose you have a match bit-vector Mj for position j in the text string, such that Mj[i] = 1 iff the first i bits of the pattern exactly match the (j − i + 1)st through jth character of the text. We can find all the bits of Mj+1 using just two operations by (1) shifting Mj one bit to the right, and then (2) doing a bitwise AND with Bα, where α is the character in position.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
버로우스 휠러 변환기는 어떻게 작동하며 성능은 어떤가요?,How does the Burrows-Wheeler transform work and what is its performance?,"특히 흥미로운 단순화는 입력 문자열에 버로우스 휠러 변환을 적용한 결과입니다. 이 변환은 n개의 문자 입력에 대한 모든 n개의 순환 시프트를 정렬한 다음 각 시프트의 마지막 문자를 보고합니다. 예를 들어, ABAB의 순환 시프트는 ABAB, BABA, ABA입니다. 정렬 후 이들은 ABAB, ABAB, BABA가 됩니다. 각 문자열의 마지막 문자를 읽으면 변환 결과가 나옵니다: BBAA.

입력 문자열의 마지막 문자가 고유한 경우(예: 문자열 끝), 이 변환은 원래 입력으로 완벽하게 되돌릴 수 있습니다! 버로우스 휠러 문자열은 반복되는 단어가 반복되는 문자 블록으로 변환되기 때문에 일반적으로 원본 텍스트보다 10~15% 더 압축성이 뛰어납니다. 또한 이 변환은 선형 시간 내에 계산할 수 있습니다.","A particularly interesting simplification results from applying the Burrows-Wheeler transform to the input string. This transform sorts all n cyclic shifts of the n character input, and then reports the last character of each shift. As an example, the cyclic shifts of ABAB are ABAB, BABA, ABAB, and BABA. After sorting, these become ABAB, ABAB, BABA, and BABA. Reading the last character of each of these strings yields the transform result: BBAA.

Provided the last character of the input string is unique (e.g., end-of-string), this transform is perfectly reversible to the original input! The Burrows-Wheeler string is typically 10-15% more compressible than the original text, because repeated words turn into blocks of repeated characters. Further, this transform can be computed in linear time.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
허프만 코드란 무엇인가요?,What are Huffman codes?,"허프만 코드는 각 알파벳 기호를 가변 길이 코드 문자열로 대체합니다. 영어 텍스트를 인코딩하기 위해 기호당 8비트를 사용하는 것은 낭비입니다. 왜냐하면 특정 문자(예: ""e"")가 다른 문자(예: ""q"")보다 훨씬 더 자주 발생하기 때문입니다. 허프만 코드는 ""e""를 짧은 코드 단어로, ""q""를 긴 코드 단어로 할당하여 텍스트를 압축합니다.","Huffman codes replace each alphabet symbol by a variable-length code string. Using eight bits-per-symbol to encode English text is wasteful, since certain characters (such as “e”) occur far more frequently than others (such as “q”). Huffman codes assign “e” a short code word, and “q” a longer one to compress text.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
렘펠-지브 알고리즘은 어떻게 작동하나요?,How do Lempel-Ziv algorithms work?,렘펠-지브 알고리즘(인기 있는 LZW 변형 포함)은 문서를 읽을 때 즉시 코딩 테이블을 구축하여 텍스트를 압축합니다. 코딩 테이블은 텍스트의 모든 위치에서 변경됩니다. 영리한 프로토콜을 사용하면 인코더와 디코더가 항상 동일한 코드 테이블에서 작동하므로 정보가 손실되지 않습니다.,"Lempel-Ziv algorithms (including the popular LZW variant) compress text by building a coding table on the fly as we read the document. The coding table changes at every position in the text. A clever protocol ensures that the encoder and decoder are both always working with the exact same code table, so no information is lost.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
압축 알고리즘의 트레이드오프에 대해 무엇을 말할 수 있나요?,What can you say about the tradeoffs in compression algorithms?,"압축 비율과 압축 시간 사이에는 자연스러운 균형이 있습니다. 또 다른 선택은 Burrows-Wheeler 변환을 사용하는 bzip2입니다. 실행 시간에 다소 큰 비용을 들이면서 gzip보다 더 엄격한 인코딩을 생성합니다. 극단적으로 말하자면, 다른 압축 알고리즘들은 파일의 모든 비트를 압축하는 데 엄청난 실행 시간을 할애합니다.","There is a natural tradeoff between compression ratio and compression time. Another choice is bzip2, which uses the Burrows-Wheeler transform. It produces tighter encodings than gzip at somewhat greater cost in running time. Going to the extreme, other compression algorithms devote enormous run times to squeeze every bit out of a file.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
유한 오토마타는 어떻게 방향 그래프로 표현할 수 있나요?,How can finite automata be represented in a directed graph?,"유한 상태 기계는 방향 그래프로 정의됩니다. 각 정점은 상태를 나타내며, 각 문자 라벨이 붙은 가장자리는 주어진 알파벳 기호를 받으면 한 상태에서 다른 상태로의 전환을 정의합니다. 이러한 오토마타는 모든 그래프 데이터 구조를 사용하여 표현할 수 있습니다.","Finite state machines are defined by directed graphs. Each vertex represents a state, and each character-labeled edge defines a transition from one state to another on receipt of the given alphabet symbol. Such automata can be represented using any graph data structure.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비결정적 유한 오토마타를 결정론적 유한 오토마타로 변환할 때 주의해야 할 점과 난이도는 무엇인가요?,What is a caveat and hardness of converting non-deterministic to deterministic finite automata?,"NFA를 DFA로 변환하면 상태 수가 기하급수적으로 증가할 수 있으며, 이는 역으로 DFA를 최소화할 때 제거될 수 있습니다. 이러한 기하급수적인 증가는 대부분의 NFA 최소화 문제인 PSPACE를 어렵게 만들며, 이는 심지어 NP-완전 문제보다 더 나쁩니다.","Converting an NFA to a DFA might cause an exponential blowup in the number of states, which perversely might then be eliminated when minimizing the DFA. This exponential blowup makes most NFA minimization problems PSPACE-hard, which is even worse than NP-complete.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
선형 시간 내에 문자열 집합의 가장 긴 공통 부분 문자열을 어떻게 계산할 수 있나요?,How can you compute the longest common substring of a set of strings in linear time?,문자열 집합의 가장 긴 공통 하위 문자열은 접미사 트리를 사용하여 선형 시간 내에 식별할 수 있습니다. 요령은 모든 문자열을 포함하는 접미사 트리를 만들고 각 리프에 해당 문자열이 나타내는 입력 문자열로 레이블을 지정한 다음 깊이 우선 탐색을 수행하여 각 입력 문자열의 후손이 있는 가장 깊은 노드를 식별하는 것입니다.,"The longest common substring of a set of strings can be identified in linear time using suffix trees. The trick is to build a suffix tree containing all the strings, label each leaf with the input string it represents, and then do a depth-first traversal to identify the deepest node with descendants from each input string.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
편집 거리를 어떻게 공통 산란된 부분 시퀀스로 변환할 수 있나요?,How can you convert edit distance into common scattered subsequence?,"This algorithm is a special case of the dynamic program edit-distance computation.

Let M[i, j] denote the number of characters in the longest common substring of S[1], . . . , S[i] and T [1], . . . , T [j]. When S[i] <> T[j], there is no way the last pair of characters could match, so M[i, j] = max(M[i, j − 1], M[i − 1, j]). But if S[i] = T[j], we have the option to select this character for our substring, so M[i, j] = max(M[i − 1, j − 1] + 1, M[i − 1, j], M[i, j − 1]).

This recurrence computes the length of the longest common subsequence in O(nm) time. We can reconstruct the actual common substring by walking backward from M[n, m] and establishing which characters were matched along the way.","This algorithm is a special case of the dynamic program edit-distance computation.

Let M[i, j] denote the number of characters in the longest common substring of S[1], . . . , S[i] and T [1], . . . , T [j]. When S[i] <> T[j], there is no way the last pair of characters could match, so M[i, j] = max(M[i, j − 1], M[i − 1, j]). But if S[i] = T[j], we have the option to select this character for our substring, so M[i, j] = max(M[i − 1, j − 1] + 1, M[i − 1, j], M[i, j − 1]).

This recurrence computes the length of the longest common subsequence in O(nm) time. We can reconstruct the actual common substring by walking backward from M[n, m] and establishing which characters were matched along the way.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최단 공통 초끈의 난이도는 무엇인가요?,What is the difficulty of shortest common superstring?,가장 짧은 공통 초끈은 모든 합리적인 문자열 클래스에 대해 NP-완전입니다.,Shortest common superstring is NP-complete for all reasonable classes of strings.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최단 공통 초끈을 근사하는 표준 접근 방식은 무엇인가요?,What is the standard approach to approximating shortest common superstring?,탐욕 휴리스틱은 최단 공통 초끈을 근사하는 표준 접근 방식을 제공합니다. 어떤 문자열 쌍이 최대 중첩을 가지는지 식별합니다. 병합된 문자열로 대체하고 하나의 문자열만 남을 때까지 반복합니다. 이 휴리스틱은 실제로 선형 시간 내에 구현할 수 있습니다. 겉보기에는 가장 시간이 많이 소요되는 부분은 중첩 그래프를 구축하는 것입니다. 두 길이의 L 문자열의 최대 중첩을 찾기 위한 무차별 대입 접근 방식은 각 O(n^2) 문자열 쌍에 대해 O(L2)를 취합니다. 그러나 접미사 트리를 사용하면 더 빠른 시간이 가능합니다. S. 문자열 Si의 접미사가 Sj의 접두사와 일치하면 S. 문자열 Si가 Sj와 중첩되는 트리를 구축합니다. 이는 접미사 트리의 꼭짓점으로 정의되는 이벤트입니다. 루트에서 거리 순서대로 이러한 꼭짓점을 탐색하면 적절한 병합 순서가 정의됩니다.,"The greedy heuristic provides the standard approach to approximating shortest common superstring. Identify which pair of strings have the maximum overlap. Replace them by the merged string, and repeat until only one string remains. This heuristic can actually be implemented in linear time. The seemingly most time-consuming part is in building the overlap graph. The brute-force approach to finding the maximum overlap of two length-L strings takes O(L2) for each of O(n^2) string pairs. However, faster times are possible by using suffix trees. Build a tree containing all suffixes of all strings of S. String Si overlaps with Sj iff a suffix of Si matches the prefix of Sj — an event defined by a vertex of the suffix tree. Traversing these vertices in order of distance from the root defines the appropriate merging order.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
많은 CPU에서 주소 지정 가능한 가장 작은 데이터 항목은 무엇인가요?,What is the smallest addressable data item on many CPUs?,"바이트는 8비트이며 많은 CPU에서 주소 지정이 가능한 가장 작은 데이터 항목입니다. 즉, CPU는 메모리에서 8비트 경계의 데이터를 효율적으로 검색할 수 있습니다.","A byte is eight bits and it is the smallest addressable data item on many CPUs. That is, the CPU can efficiently retrieve data on an 8-bit boundary from memory.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n비트로 표현할 수 있는 범위는 무엇인가요?,What is the range representable by n bits?,range −2^(n−1) to +2^(n−1)−1,range −2^(n−1) to +2^(n−1)−1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
두 개의 보어 번호 체계에서 가장 작은 음수 값을 무효화하면 어떻게 되나요?,What happens when you negate the smallest negative value in the two's complement numbering system?,"그것은 저절로 됩니다.
일반적으로, 두 개의 보완 번호 체계에서 가장 작은 음수 값을 부정할 수 없습니다.","It becomes itself.
In general, you cannot negate the smallest negative value in the two's complement numbering system.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이진수의 LO n 비트가 모두 0을 포함한다는 것은 무엇을 의미하나요?,What does it mean if the LO n bits of a binary number all contain zero?,"이진수의 LO n 비트가 모두 0을 포함한다면, 그 숫자는 2n으로 균등하게 나눌 수 있습니다.","If the LO n bits of a binary number all contain zero, then the number is evenly divisible by 2n.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
왜 같은 산술 표현식이나 과제 문장 내에서 다양한 크기의 변수를 혼합하는 것에 주의해야 하나요?,Why should you be careful about mixing variables of different sizes within the same arithmetic expression or assignment statement?,부호와 영 확장에 대해 알아야 할 중요한 점은 부호와 영 확장이 항상 자유로운 것은 아니라는 것입니다. 더 큰 정수에 더 작은 정수를 할당하려면 같은 크기의 정수 변수 두 개 사이에서 데이터를 이동하는 것보다 더 많은 기계 명령어(실행하는 데 더 오래 걸릴 수 있음)가 필요할 수 있습니다.,The important thing to realize about sign and zero extension is that they aren't always free. Assigning a smaller integer to a larger integer may require more machine instructions (taking longer to execute) than moving data between two like-sized integer variables.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
숫자 값을 계약하려면 어떤 조건이 필요하나요?,What conditions do you have to have in order to sign contract a numeric value?,"첫째, HO 바이트에는 모두 0 또는 0xFF가 포함되어야 합니다. 다른 값을 발견하면 해당 값에 서명할 수 없습니다. 둘째, 결과 값의 HO 비트는 숫자에서 제거한 모든 비트와 일치해야 합니다.","First, the HO bytes must all contain either zero or 0xFF. If you encounter any other values, you cannot sign contract the value. Second, the HO bit of your resulting value must match every bit you've removed from the number.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
포화란 무엇인가요?,What is saturation?,채도는 정수 값의 크기를 줄이는 또 다른 방법입니다. 채도는 더 큰 물체를 더 작은 물체로 변환하고 싶을 때 유용하며 정밀도를 잃을 수도 있습니다.,Saturation is another way to reduce the size of an integer value. Saturation is useful when you want to convert a larger object to a smaller object and you're willing to live with possible loss of precision.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인텔 80x86 프로세서 제품군에서 MMX 명령 확장은 무엇을 제공하나요?,"On the Intel 80x86 processor family, what do the MMX instruction extensions provide?",MMX 명령어 확장은 포화 기능을 제공합니다. 대부분의 CPU 표준 명령어 세트와 대부분의 고급 언어는 포화를 직접 지원하지 않지만 포화는 어렵지 않습니다.,"The MMX instruction extensions provide saturation capabilities. Most CPUs' standard instruction sets, as well as most high-level languages, do not provide direct support for saturation, but saturation is not difficult.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
BCD란 무엇인가요?,What is BCD?,이진 코드 십진법(BCD) 형식은 이름에서 알 수 있듯이 이진 표현을 사용하여 십진법 값(0-9)을 인코딩합니다.,"The binary-coded decimal (BCD) format, as its name suggests, encodes decimal values (0-9) using a binary representation.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
BCD 값이란 무엇인가요?,What are BCD values?,"BCD 값은 일련의 니블로 구성되며, 각 니블은 0.9 범위의 값을 나타냅니다.","BCD values consist of a sequence of nibbles, with each nibble representing a value in the range 0..9.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"16비트 정수, 16비트 분수 형식으로 가능한 것은 무엇인가요?","What is possible with 16-bit integer, 16-bit fractional format?","일부 3D 게임 애플리케이션은 32비트 부동 소수점 형식이 아닌 16:16(16비트 정수, 16비트 분수) 형식을 사용하여 더 빠른 계산을 수행할 수 있습니다.","Certain 3D gaming applications may produce faster computations using a 16:16 (16-bit integer, 16-bit fractional) format rather than a 32-bit floating-point format.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이진 십진법 형식이 2자리 십진법 형식에 비해 어떤 장점이 있나요?,What is an advantage of binary decimal format over 2 digit decimal format?,"대부분의 금융 계산이 요구하는 정확도를 고려할 때(일반적으로 소수점 오른쪽 네 자리 숫자는 중요한 금융 거래에 필요한 최소 정밀도), 일반적으로 이진 형식을 사용하는 것이 좋습니다.","Given the accuracy most financial computations require (generally four digits to the right of the decimal point is the minimum precision serious financial transactions require), it's usually better to use a binary format.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
축소된 숫자 형식의 장점은 무엇인가요?,What is an advantage of scaled numeric format?,스케일링된 숫자 형식의 장점 중 하나는 형식에 소수점뿐만 아니라 어떤 밑도 선택할 수 있다는 점입니다.,"One advantage of the scaled numeric format is that you can choose any base, not just decimal, for your format.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
합리적 표현이란 무엇인가요?,What is rational representation?,유리 표현은 분수 값을 나타내기 위해 정수 쌍을 사용합니다. 한 정수는 분수의 분자(n)를 나타내고 다른 정수는 분모(d)를 나타냅니다. 실제 값은 n/d와 같습니다.,"Rational representation uses pairs of integers to represent fractional values. One integer represents the numerator (n) of a fraction, and the other represents the denominator (d). The actual value is equal to n/d.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비트가 설정되었는지 어떻게 테스트할 수 있나요?,How can you test if a bit is set?,"논리적으로 그리고 특정 비트 위치에 하나를 포함하는 비트 문자열을 가진 값이라면, 해당 비트에 0이 포함된 경우 논리적 AND의 결과는 0이 되고, 비트가 설정된 경우 결과는 0이 아닙니다.","If you logically AND a value with a bit string that contains a one in a certain bit position, the result of the logical AND will be zero if the corresponding bit contains a zero, and the result will be nonzero if the bit is set.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
숫자가 16으로 나눌 수 있는지 어떻게 테스트할 수 있나요?,How can you test if a number is divisible by 16?,(ValueToTest & 0xF) == 0,(ValueToTest & 0xF) == 0,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
분할을 피하기 위해 AND를 사용하여 모드 32에 대한 모듈-n 카운터를 어떻게 작성할 수 있나요?,How can you write a module-n counter for mod 32 using AND to avoid division?,"(cntr + 1) & 0x3F; // AND with 6-bit mask, truncating a value to 0-31","(cntr + 1) & 0x3F; // AND with 6-bit mask, truncating a value to 0-31",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
부동 소수점 정밀도란 무엇인가요?,What is floating-point precision?,계산에서 유지되는 자릿수 또는 비트 수입니다.,The number of digits or bits maintained in a computation.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
부동 소수점 오류 누적을 최소화하는 한 가지 방법은 무엇인가요?,What is one way to minimize floating point error accumulation?,"덧셈과 뺄셈을 포함한 연쇄 계산을 수행하는 경우, 크기가 서로 가까운 값을 더하거나 뺄 수 있도록 연산을 그룹화한 후 크기가 서로 같지 않은 값을 더하거나 뺄 수 있도록 해야 합니다.","If you are performing a chain calculation involving addition and subtraction, you should attempt to group the operations so that you can add or subtract values whose magnitudes are close to one another before adding or subtracting values whose magnitudes are not as close.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
부동 소수점 덧셈과 뺄셈에 대한 주의사항은 무엇인가요?,What is a caveat for floating-point addition and subtraction?,"같은 기호를 가진 두 숫자를 빼거나 다른 기호를 가진 두 숫자를 더할 때, 결과의 정확도가 부동 소수점 형식에서 사용할 수 있는 정밀도보다 낮을 수 있습니다.","Whenever subtracting two numbers with the same signs or adding two numbers with different signs, the accuracy of the result may be less than the precision available in the floating-point format.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"What can you do to avoid floating-point error accumulation issues involving addition, subtraction, multiplication, and division?","What can you do to avoid floating-point error accumulation issues involving addition, subtraction, multiplication, and division?","덧셈, 뺄셈, 곱셈, 나눗셈을 포함한 일련의 계산을 수행할 때는 먼저 곱셈과 나눗셈 연산을 수행해 보세요.","When performing a chain of calculations involving addition, subtraction, multiplication, and division, try to perform the multiplication and division operations first.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
What can you do to avoid floating point error issues when you multiply and divide numbers?,What can you do to avoid floating point error issues when you multiply and divide numbers?,"숫자 집합을 곱하고 나눌 때, 같은 상대적인 크기를 가진 숫자를 곱하고 나누도록 하세요.","When multiplying and dividing sets of numbers, try to multiply and divide numbers that have the same relative magnitudes.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you avoid issues in precise comparison on floating point numbers?,How can you avoid issues in precise comparison on floating point numbers?,if( abs(값 1 - 값 2) <= 오류 ) 그러면 ...,if( abs(Value1 − Value2) <= error ) then ...,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
부동 소수점 숫자 두 개를 비교하려면 어떻게 해야 하나요?,What can you do to compare 2 floating-point numbers?,"원하는 오류 허용 오차 범위 내에서 값이 서로 같지 않다고 판단되면 값을 비교하여 한 값이 다른 값보다 작거나 큰지 확인할 수 있습니다. 이는 값보다 작거나 큰 값을 비교하는 비참한 접근 방식으로 알려져 있습니다(즉, 가능한 한 작거나 큰 값을 찾으려고 노력합니다).","If you determine that the values are not equal to one another within the desired error tolerance, then you can compare them to see if one value is less than or greater than the other. This is known as a miserly approach to comparing for less than or greater than (that is, we try to find as few values that are less than or greater than as possible).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
부동 소수점 비교에 대한 열정적인 접근 방식은 무엇인가요?,What is the eager approach to floating-point comparison?,"열성적인 접근 방식은 비교 결과를 가능한 한 자주 참으로 만들려고 시도합니다. 비교하고자 하는 두 값과 달성하고자 하는 오류 허용 오차를 고려할 때, 두 값을 비교하는 방법은 다음과 같습니다:

if( A < ( B + 오류), 그리고 Eager_A_lessthan_B; 
if( A > ( B - 오류)) 그러면 Eager_A_greater_B;","An eager approach attempts to make the result of the comparison true as often as possible. Given two values that you want to compare, and an error tolerance you’re interested in achieving, here’s how you’d eagerly compare the two values for less than or greater than:

if( A < (B + error)) then Eager_A_lessthan_B; 
if( A > (B − error)) then Eager_A_greaterthan_B;",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
확장 정밀도의 특별한 점은 무엇인가요?,What is special about extended precision?,확장 정밀도에는 계산 결과를 저장할 때 이중 정밀도 값으로 반올림하기 전에 가드 비트로 사용할 수 있는 16개의 추가 비트가 포함되어 있습니다.,Extended precision contains 16 extra bits that the calculations can use as guard bits before rounding down to a double-precision value when storing the result.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
단일 정밀도의 형식은 무엇인가요?,What is the format of single-precision?,"단일 정밀도 형식은 24비트 맨티사와 8비트 지수를 사용합니다. 맨티사는 일반적으로 1.0에서 2.0보다 작은 값을 나타냅니다. 맨티사는 일반적으로 1.0에서 2.0보다 작은 값을 나타냅니다. 맨티사의 HO 비트는 항상 하나로 가정되며 이진 점의 왼쪽에 있는 값을 나타냅니다. 나머지 23개의 맨티사 비트는 이진 점의 오른쪽에 나타나 값을 나타냅니다:
1.mmmmmmm mmmmmmmm mmmmmmmm","The single-precision format uses a 24-bit mantissa and an 8-bit exponent. The mantissa usually represents a value between 1.0 and just less than 2.0. The mantissa usually represents a value between 1.0 and just less than 2.0. The HO bit of the mantissa is always assumed to be one and represents a value just to the left of the binary point. The remaining 23 mantissa bits appear to the right of the binary point and represent the value:
1.mmmmmmm mmmmmmmm mmmmmmmm",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이중 정밀 형식이란 무엇인가요?,What is the double-precision format?,"이중 정밀도 형식은 단일 정밀도 부동 소수점의 문제를 극복하는 데 도움이 됩니다. 이중 정밀도 형식은 두 배의 공간을 사용하여 11비트 초과 1,023 지수와 53비트 맨티사(임의 HO 비트 1 포함)에 부호 비트를 더합니다. 이는 약 10±308의 동적 범위와 14 1/2 자리의 정밀도를 제공하여 대부분의 응용 분야에 충분합니다.","The double-precision format helps overcome the problems of the single-precision floating-point. Using twice the space, the double-precision format has an 11-bit excess-1,023 exponent and a 53-bit mantissa (including an implied HO bit of one) plus a sign bit. This provides a dynamic range of about 10±308 and 14 1/2 digits of precision, which is sufficient for most applications.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
확장 정밀도 형식은 무엇인가요?,What is the extended-precision format?,"확장 정밀도 형식은 64비트 가수, 15비트 초과 16,383 지수, 그리고 1비트 부호를 제공합니다.","The extended-precision format provides a 64-bit mantissa, a 15-bit excess-16,383 exponent, and a 1-bit sign.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인텔은 확장 정밀도를 어떻게 처리하나요?,How does Intel treat extended-precision?,"인텔은 항상 확장 정밀도 형식으로 작동합니다. 계산을 수행하기 전에 확장 정밀도로 변환합니다. 이를 통해 인텔은 많은 수의 가드 비트가 존재하여 계산의 정확성을 보장합니다. 인텔은 80비트를 사용하여 모든 계산을 수행함으로써 계산에서 32비트 또는 64비트의 전체 정확도를 보장(단, 보장하지는 않음)할 수 있도록 도와줍니다.","Intel always works in extended-precision format. It converts to extended precision before doing computations. By doing so, Intel guarantees a large number of guard bits are present to ensure the accuracy of your computations. By performing all computations using 80 bits, Intel helps ensure (but not guarantee) that you will get full 32- or 64-bit accuracy in your computations.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
부동 소수점 값을 정규화하려면 어떻게 해야 하나요?,How do you normalize a floating-point value?,거의 모든 비정규화된 값은 맨티사 비트를 왼쪽으로 이동시키고 지수를 감소시켜 맨티사의 HO 비트에 하나가 나타날 때까지 정규화할 수 있습니다.,Almost any unnormalized value can be normalized by shifting the mantissa bits to the left and decrementing the exponent until a one appears in the HO bit of the mantissa.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
반올림은 부동 소수점 값에 어떤 영향을 미치나요?,How does rounding-up affect a floating-point value?,"반올림은 가드 비트가 모두 0인 경우에만 값을 남기지만, 현재 맨티사가 목적지 비트에 정확히 맞지 않는 경우 반올림은 부동 소수점 형식에서 가능한 가장 작은 큰 값으로 결과를 설정합니다.","Rounding up leaves the value alone if the guard bits are all zero, but if the current mantissa does not exactly fit into the destination bits, then rounding up sets the result to the smallest possible larger value in the floating-point format.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
How does rounding down affect a floating-point value and how is it different from truncation?,How does rounding down affect a floating-point value and how is it different from truncation?,"반올림은 결과를 가능한 가장 큰 작은 값으로 반올림하는 것과 같습니다. 이는 잘림처럼 들릴 수 있지만, 잘림과 반올림 사이에는 미묘한 차이가 있습니다. 잘림은 항상 0을 향해 반올림합니다. 양수의 경우 잘림과 반올림은 같은 작업을 수행합니다. 그러나 음수의 경우 잘림은 단순히 맨티사의 기존 비트를 사용하는 반면, 음수의 경우 반올림은 실제로 결과가 음수인 경우 LO 위치에 1비트를 추가합니다.","Rounding down is just like rounding up, except it rounds the result to the largest possible smaller value. This may sound like truncation, but there is a subtle difference between truncation and rounding down. Truncation always rounds towards zero. For positive numbers, truncation and rounding down do the same thing. However, for negative numbers, truncation simply uses the existing bits in the mantissa, whereas rounding down will actually add a one bit to the LO position if the result was negative.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
부동 소수점에서 NaN을 어떻게 표현할 수 있나요?,How can you represent NaN in floating point?,"지수에 모든 값이 포함되어 있고 맨티사가 0이 아닌 경우(암시된 비트를 할인하는 경우), 맨티사의 HO 비트(암시된 비트를 다시 할인하는 경우)는 해당 값이 조용한 비숫자(QNaN)인지 신호 비숫자(SNAN)인지를 결정합니다(표 4-1 참조). 이러한 비숫자(NaN) 결과는 시스템에 심각한 계산 오류가 발생했으며 계산 결과가 완전히 정의되지 않았음을 알려줍니다.","If the exponent contains all ones and the mantissa is nonzero (discounting the implied bit), then the HO bit of the mantissa (again discounting the implied bit) determines whether the value represents a quiet not-a-number (QNaN) or a signaling not-a-number (SNaN) (see Table 4-1). These not-a-number (NaN) results tell the system that some serious miscalculation has taken place and that the result of the calculation is completely undefined.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
부동 소수점에서 무한대를 어떻게 표현할 수 있나요?,How can you represent infinity in floating-point?,지수에 모든 비트가 포함되고 맨티사에 모든 0이 포함된 경우 다른 두 개의 특수 값이 표시됩니다. 이러한 경우 부호 비트는 결과가 +무한대를 나타내는 것인지 -무한대를 나타내는 것인지 결정합니다.,"Two other special values are represented when the exponent contains all one bits, and the mantissa contains all zeros. In such a case, the sign bit determines whether the result is the representation for +infinity or −infinity.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
ASCII 문자를 대문자와 소문자로 변환하려면 어떻게 해야 하나요?,How can you convert an ASCII character between uppercase and lowercase?,이 사실을 사용하여 비트 5를 반전하기만 하면 대문자와 소문자 사이에서 알파벳 문자를 빠르게 변환할 수 있습니다. 대문자가 있는 경우 비트 5를 1로 설정하여 소문자로 강제할 수 있습니다. 소문자가 있는 경우 대문자로 강제로 전환하려면 비트 5를 0으로 설정하면 됩니다.,"You can use this fact to quickly convert an alphabetic character between upper- and lowercase by simply inverting bit five. If you have an uppercase character, you can force it to lowercase by setting bit five to one. If you have a lowercase character and you wish to force it to uppercase, you can do so by setting bit five to zero.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
ASCII 숫자 값의 이진 표현을 어떻게 얻을 수 있나요?,How can you obtain the binary representation of an ASCII numeric value?,ASCII 코드의 HO 니블을 제거(0으로 설정)하면 해당 숫자의 이진 표현을 얻을 수 있습니다. 반대로 HO 니블을 %0011 또는 소수점 3으로 설정하기만 하면 0.9 범위의 이진 값을 ASCII 문자 표현으로 변환할 수 있습니다.,"By stripping away (setting to zero) the HO nibble of the ASCII code, you obtain the binary representation of that digit. Conversely, you can convert a binary value in the range 0..9 to its ASCII character representation by simply setting the HO nibble to %0011, or the decimal value 3.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
길이 프리픽스 문자열이란 무엇인가요?,What are length-prefixed strings?,"길이 프리픽스 문자열은 제로 종단 문자열의 몇 가지 문제를 해결합니다. 길이 프리픽스 문자열은 파스칼과 같은 언어에서 일반적으로 사용되며, 일반적으로 문자열의 길이를 지정하는 단일 바이트와 0비트 이상의 8비트 문자 코드로 구성됩니다. 길이 프리픽스 방식에서 문자열 ""abc""는 길이 바이트(0x03), 그 다음으로 a, b, c의 네 바이트로 구성됩니다.","Length-prefixed strings overcome some of the problems with zero-terminated strings. Length-prefixed strings are common in languages like Pascal; they generally consist of a single byte that specifies the length of the string, followed by zero or more 8-bit character codes. In a length-prefixed scheme, the string “abc” would consist of four bytes: the length byte (0x03), followed by a, b, and c.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정적 문자열이란 무엇인가요?,What are static strings?,C/C++에서 제로 종단 문자열을 보관하는 데 사용할 문자 배열입니다. 프로그램이 실행되는 동안 이러한 정적 문자열의 최대 크기를 늘릴 수 있는 방법이 없습니다. 또한 사용할 저장 공간을 줄일 수 있는 방법도 없습니다.,"Arrays of characters that you will use to hold zero-terminated strings in C/C++. While the program is running, there is no way to increase the maximum sizes of these static strings. Nor is there any way to reduce the storage they will use.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
의사 동적 문자열이란 무엇인가요?,What are pseudo-dynamic strings?,의사 동적 문자열은 시스템이 실행 시 malloc과 같은 메모리 관리 함수를 호출하여 문자열의 저장 공간을 할당하여 길이를 설정하는 문자열입니다. 그러나 시스템이 문자열에 저장 공간을 할당하면 문자열의 최대 길이가 고정됩니다.,"Pseudo-dynamic strings are those whose length the system sets at run time by calling a memory-management function like malloc to allocate storage for the string. However, once the system allocates storage for the string, the maximum length of the string is fixed.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
다이나믹 스트링이란 무엇인가요?,What are dynamic strings?,일반적으로 디스크립터 기반 형식을 사용하는 동적 문자열 시스템은 새 문자열을 만들거나 기존 문자열에 영향을 미치는 작업을 수행할 때마다 문자열 객체에 대해 자동으로 충분한 저장 공간을 할당합니다. 이를 카피 온 라이트라고 하나요?,"Dynamic string systems, which typically use a descriptor-based format, will automatically allocate sufficient storage for a string object whenever you create a new string or otherwise do something that affects an existing string. This is called copy-on-write?",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
제약된 최적화 또는 비제약된 최적화가 NP-완전한가요?,Is constrained or unconstrained optimization NP-Complete?,아니요.,No.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
선형 프로그래밍은 NP-완전인가요?,Is linear programming NP-Complete?,아니요.,No.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
혼합(정수 및 선형 프로그래밍) NP-완전인가요?,Is mixed (integer and linear programming) NP-Complete?,"네, 최적성을 해결하기 위해서입니다. 하지만 실제로는 잘 작동하는 기술들이 있습니다.","Yes, to solve to optimality. But there are techniques that work well in practice.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
숫자를 인수분해하는 것이 NP인가요?,Is factoring numbers in NP?,"소인수분해 문제는 NP 클래스에 속하지만 NP-난해인지는 알 수 없습니다. 즉, 현재로서는 소인수분해 문제가 다항 시간(P)으로 풀 수 없다는 증거가 없습니다. 따라서 소인수분해에 의존하는 알고리즘이 어려워진다는 증거도 없습니다.","The prime factorization problem is in the NP class, but we don't know if it is NP-hard. In other words, there is currently no proof that prime factorization problem cannot be solved polynomial time (in P). Subsequently there is no proof that algorithms that rely on prime factorization being hard are rendered ineffective.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
오일러 경로를 계산하는 것이 NP-완전한가요?,Is calculating Eulerian path NP-Complete?,아니요.,No.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
오일러 사이클을 계산하는 것이 NP-완전한가요?,Is calculating Eulerian cycle NP-Complete?,아니요.,No.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비평면 그래프의 경우 그래프를 평평하게 표현하기 위해 교차하는 간선의 수를 최소화하는 것이 유용합니다. 이 접근 방식의 문제점은 무엇인가요?,"For non-planar graphs, it is useful to minimize the number of crossing edges to represent the graph in a flat manner. What is a problem with this approach?",그래프의 교차 수를 계산하는 것은 NP-완전입니다.,Computing the crossing number of a graph is NP-Complete.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
두 그래프의 교차점(충돌) 감지가 NP-완전한가요?,Is detection of intersection (collision) of two graphs NP-Complete?,"아니요, 하지만 매우 복잡할 수 있습니다.","No, but it can be very complicated.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
세트 커버와 세트 포장의 차이점은 무엇인가요?,What is the difference between set cover and set packing?,"세트 커버는 겹침을 허용하는 반면, 세트 포장은 그렇지 않습니다.","Set cover allows overlap, while set packing doesn't.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
세트 커버가 NP-완전한가요?,Is set cover NP-Complete?,"세트 커버링의 결정 버전은 NP-완전이며, 세트 커버의 최적화/검색 버전은 NP-난해합니다.","The decision version of set covering is NP-complete, and the optimization/search version of set cover is NP-hard.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
partition 설정이 NP-완전한가요?,Is set partition NP-Complete?,아니요. 세트 포장과 혼동하지 마세요.,No. Don't confuse it with set packing.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
세트 포장이 NP-완전한가요?,Is set packing NP-Complete?,"네, NP-완전 문제일 뿐만 아니라 최적화 버전(일반 최대 집합 패킹 문제)도 최대 클리크 문제만큼 근사하기 어렵다는 것이 입증되었습니다. 특히, 어떤 상수 요인 내에서도 근사할 수 없습니다.","Yes. It's not only NP-complete, but its optimization version (general maximum set packing problem) has been proven as difficult to approximate as the maximum clique problem; in particular, it cannot be approximated within any constant factor.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
문자열로 작성할 때 사본이란 무엇인가요?,What is copy on write with strings?,"문자열 함수가 동적 문자열의 일부 문자를 변경해야 할 때마다, 함수는 먼저 문자열의 복사본을 만든 다음 데이터 복사본에 필요한 모든 수정 사항을 추가합니다.","Whenever a string function needs to change some characters in a dynamic string, the function first makes a copy of the string and then makes whatever modifications are necessary to the copy of the data.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
폰 노이만 시스템의 세 가지 구성 요소는 무엇인가요?,What are the three components of a von Neumann system?,"일반적인 폰 노이만 시스템에는 중앙 처리 장치(CPU), 메모리, 입출력(I/O)이라는 세 가지 주요 구성 요소가 있습니다","A typical von Neumann system has three major components: the central processing unit (CPU), memory, and input/output (I/O)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CPU는 I/O 장치를 어떻게 볼 수 있나요?,How does a CPU see I/O devices?,CPU에게 대부분의 I/O 장치는 메모리처럼 보입니다.,"To the CPU, most I/O devices look like memory.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
데이터 버스란 무엇인가요?,What is the data bus?,CPU는 데이터 버스를 사용하여 컴퓨터 시스템의 다양한 구성 요소 간에 데이터를 섞습니다. 이 버스의 크기는 CPU마다 매우 다양합니다. 실제로 버스 크기는 프로세서의 '크기'를 정의하는 주요 속성 중 하나입니다.,"CPUs use the data bus to shuffle data between the various components in a computer system. The size of this bus varies widely among CPUs. Indeed, bus size is one of the main attributes that defines the “size” of the processor.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최신 데이터 버스의 크기는 어떻게 되나요?,What is the size of a modern data bus?,"대부분의 경우 개인용 컴퓨터의 CPU는 32비트 또는 64비트 데이터 버스를 사용하는 경향이 있으며, 64비트 데이터 버스가 가장 일반적입니다.","For the most part, the CPUs in personal computers tend to use 32-bit or 64-bit data buses (and 64-bit data buses are the most prevalent).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
주소 버스는 무엇이며 어떻게 작동하나요?,What is the address bus and how does it work?,소프트웨어가 특정 메모리 위치나 I/O 장치에 액세스하고자 할 때 해당 주소를 주소 버스에 배치합니다. 장치 내 회로는 이 주소를 확인하고 주소가 일치하는 경우 데이터를 전송합니다.,"When the software wants to access a particular memory location or I/O device, it places the corresponding address on the address bus. Circuitry within the device checks this address and transfers data if there is an address match.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
주소 라인이 n개인 주소는 얼마나 많은 메모리를 가질 수 있나요?,How much memory can be addresses with n address lines?,n개의 주소 라인을 사용하면 프로세서는 2^n개의 고유 주소에 액세스할 수 있습니다(n비트 이진수에는 2^n개의 고유 값이 있기 때문입니다). 따라서 주소 버스의 비트 수에 따라 주소 지정 가능한 최대 메모리 수와 I/O 위치가 결정됩니다. 64비트 주소 범위는 메모리에 관한 한 정말 무한합니다. 컴퓨터 시스템에 2^64바이트의 메모리를 넣고 더 많은 메모리가 필요하다고 느끼는 사람은 아무도 없을 것입니다. 이는 우주의 원자 그 이상입니다.,"With n address lines, the processor can access 2^n unique addresses (because there are 2^n unique values in an n-bit binary number). Therefore, the number of bits on the address bus will determine the maximum number of addressable memory and I/O locations. A 64-bit address range is truly infinite as far as memory is concerned. No one will ever put 2^64 bytes of memory into a computer system and feel that they need more. It's more than atoms in the universe.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
제어 버스란 무엇인가요?,What is the control bus?,제어 버스는 프로세서가 시스템의 나머지 부분과 통신하는 방식을 제어하는 다양한 신호 모음입니다. 시스템은 제어 버스에서 읽기와 쓰기 두 줄을 사용하여 데이터 흐름 방향(CPU에서 메모리 또는 메모리에서 CPU로)을 결정합니다. 따라서 CPU가 메모리에 데이터를 쓰기를 원할 때는 쓰기 제어 라인을 주장(신호 켜기)합니다. CPU가 메모리에서 데이터를 읽기를 원할 때는 읽기 제어 라인을 주장합니다.,"The control bus is an eclectic collection of signals that control how the processor communicates with the rest of the system. The system uses two lines on the control bus, read and write, to determine the data flow direction (CPU to memory, or memory to CPU). So when the CPU wants to write data to memory, it asserts (places a signal on) the write control line. When the CPU wants to read data from memory, it asserts the read control line.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
바이트 활성화 라인은 무엇인가요?,What are the byte enable lines?,"바이트 활성화 라인은 바이트 주소 지정 메모리를 지원하는 일부 CPU의 제어 버스에 표시됩니다. 이러한 제어 라인을 통해 16비트, 32비트 및 64비트 프로세서는 동반되는 데이터의 크기를 통신하여 더 작은 데이터 덩어리를 처리할 수 있습니다.","The byte enable lines appear on the control bus of some CPUs that support byte-addressable memory. These control lines allow 16-, 32-, and 64-bit processors to deal with smaller chunks of data by communicating the size of the accompanying data.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
하나의 주소 버스가 지원하는 두 개의 주소 공간은 무엇인가요?,What are the 2 address spaces supported by the one address bus?,"80x86 제품군은 다른 많은 프로세서와 달리 메모리용과 I/O용이라는 두 가지 별도의 주소 공간을 제공합니다. 그러나 I/O와 메모리용이라는 두 개의 별도 물리적 주소 버스는 없습니다. 대신, 시스템은 I/O 주소와 메모리 주소 모두에 대해 주소 버스를 공유합니다. 추가적인 제어 라인이 해당 주소가 메모리용인지 I/O용인지를 결정합니다.","The 80x86 family, unlike many other processors, provides two distinct address spaces: one for memory and one for I/O.However, it does not have two separate physical address buses (for I/O and memory). Instead, the system shares the address bus for both I/O and memory addresses. Additional control lines decide whether the address is intended for memory or I/O.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CPU가 다음과 같은 방식으로 데이터를 저장하는 방법: 메모리 [125] = 0,What does the CPU to save data like this: Memory[125] = 0,"Memory[125] = 0과 동등한 값을 실행하려면 CPU는 데이터 버스에 값 0을, 주소 버스에 주소 125를 배치하고 제어 버스에 쓰기 줄을 할당합니다.","To execute the equivalent of the statement Memory[125] = 0; the CPU places the value zero on the data bus, the address 125 on the address bus, and asserts the write line on the control bus.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
80x86 제품군은 데이터 단어를 어떻게 저장하나요?,How does the 80x86 family store a data word?,80x86 계열은 단어의 LO 바이트를 지정된 주소에 저장하고 HO 바이트를 다음 위치에 저장합니다. 따라서 단어는 두 개의 연속 메모리 주소를 소비합니다(단어는 두 바이트로 구성되기 때문에 예상대로). 마찬가지로 더블 워드는 네 개의 연속 메모리 위치를 소비합니다.,"The 80x86 family stores the LO byte of a word at the address specified and the HO byte at the next location. Therefore, a word consumes two consecutive memory addresses (as you would expect, because a word consists of two bytes). Similarly, a double word consumes four consecutive memory locations.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
바이트 주소 지정 메모리 배열이란 무엇인가요?,What is a byte-addressable memory array?,바이트 주소 지정 메모리 배열이라는 용어는 CPU가 단일 바이트만큼 작은 청크로 메모리를 주소 지정할 수 있다는 것을 의미합니다. 또한 프로세서로 한 번에 액세스할 수 있는 메모리 단위 중 가장 작다는 의미이기도 합니다.,The term byte-addressable memory array means that the CPU can address memory in chunks as small as a single byte. It also means that this is the smallest unit of memory you can access at once with the processor.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
64비트 데이터 버스에는 어떤 비트가 사용되나요?,What bits are used on a 64-bit data bus?,64비트 데이터 버스에는 LO 48비트만 사용됩니다. 256테라바이트입니다. 지금은 충분합니다.,Only the LO 48 bits are used on 64-bit data buses. That's 256 terabytes. Good enough for now.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
32비트 메모리 인터페이스의 주소 정렬은 무엇인가요?,What is the address alignment on a 32-bit memory interface?,32비트 메모리 인터페이스를 사용하면 주소 버스에 배치된 주소는 항상 4의 배수입니다.,"With a 32-bit memory interface, the address placed on the address bus is always some multiple of four.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
32비트 CPU는 단일 메모리 작업에서 어떻게 이중 단어에 접근할 수 있나요?,How can a 32-bit CPU can access a double word in a single memory operation?,32비트 CPU는 해당 값의 주소가 4로 균등하게 나눌 수 있는 경우에만 단일 메모리 작업에서 더블 워드에 액세스할 수 있습니다.,A 32-bit CPU can access a double word in a single memory operation only if the address of that value is evenly divisible by four.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최신 인텔 프로세서는 비정렬 데이터를 어떻게 처리하나요?,How do modern Intel processors deal with non-aligned data?,"펜티엄 및 이후 프로세서는 64비트 데이터 버스와 특수 캐시 메모리를 제공하여 비정렬 데이터 액세스의 영향을 줄입니다. 부적절한 주소로 데이터에 액세스하면 여전히 페널티가 있을 수 있지만, 최신 x86 CPU는 이전 CPU보다 문제의 빈도가 낮습니다.","The Pentium and later processors provide a 64-bit data bus and special cache memory that reduces the impact of non-aligned data access. Although there may still be a penalty for accessing data at an inappropriate address, modern x86 CPUs suffer from the problem less frequently than the earlier CPUs.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
TCP/IP 및 기타 네트워크 프로토콜의 엔디안성은 무엇인가요?,What is the endianness of TCP/IP and some other network protocols?,"네트워크를 통해 데이터를 전송할 때, TCP/IP 및 일부 다른 네트워크 프로토콜은 빅 엔디안 형식을 사용하기 때문에 일반적으로 빅 엔디안 형식을 사용합니다.","When transmitting data across networks, the canonical form is usually big endian because TCP/IP and some other network protocols use the big endian format.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
유니버설 시리얼 버스를 통해 데이터를 전송할 때 엔디안니스란 무엇인가요?,"When transmitting data across the Universal Serial Bus, what is the endianness?",표준 형식은 작은 엔디안 형식입니다.,The canonical format is little endian.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
빠른 정렬에서 n 로그 n 성능을 보장하는 4단계는 무엇인가요?,What are the 4 steps to ensure n log n performance on quick sort?,"- 먼저 입력을 무작위로 지정합니다
- 중앙값 3을 사용하여 피벗을 결정합니다
- 20개 미만의 요소에서 재귀를 조기에 종료하고 Insertion Sort을 수행합니다
- 작은 partition을 먼저 수행합니다","- randomize input first
- use median of three to determine pivot
- at fewer than 20 elements, end recursion early and do insertion sort
- do the smaller partition first",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
어떻게 하면 하나의 내재성에서 다른 내재성으로 전환할 수 있을까요?,How can you convert from one endianness to another?,엔디안 형식을 변환하려면 객체의 바이트를 미러-이미지 스왑해야 합니다. 미러-이미지 스왑을 수행하려면 이진수의 반대쪽 끝에서 바이트를 스왑한 다음 객체의 중간으로 이동하면서 바이트 쌍을 스왑해야 합니다.,"To convert between the endian forms, you must do a mirror-image swap of the bytes in the object. To cause a mirror-image swap, you must swap the bytes at opposite ends of the binary number, and then work your way towards the middle of the object swapping pairs of bytes as you go along.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
시스템 시계는 무엇인가요?,What is the system clock?,"시스템 클럭은 제어 버스의 전기 신호로, 주기적인 속도로 0과 1을 번갈아 가며 작동합니다. CPU 내의 모든 활동은 이 클럭 신호의 가장자리(상승 또는 하강)와 동기화됩니다.",The system clock is an electrical signal on the control bus that alternates between zero and one at a periodic rate. All activity within the CPU is synchronized with the edges (rising or falling) of this clock signal.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
시스템 클럭 주파수와 시스템 클럭 주기는 무엇인가요?,What is the system clock frequency and system clock period?,"시스템 클럭이 0과 1을 번갈아 가며 사용하는 주파수는 시스템 클럭 주파수이며, 시스템 클럭이 0에서 1로, 다시 0으로 전환하는 데 걸리는 시간을 클럭 주기라고 합니다. 한 번의 전체 주기를 클럭 주기라고도 합니다.",The frequency with which the system clock alternates between zero and one is the system clock frequency and the time it takes for the system clock to switch from zero to one and back to zero is the clock period. One full period is also called a clock cycle.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
1GHz 프로세서의 클럭 주기는 어떻게 되나요?,What is the clock period for a 1 GHz processor?,"1GHz에서 실행되는 CPU의 클럭 주기는 1나노초(ns), 즉 10억 분의 1초입니다.","A CPU running at 1 GHz would have a clock period of one nanosecond (ns), or one billionth of a second.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
시계가 CPU를 어떻게 제한하나요?,How does the clock limit a CPU?,모든 CPU 작업은 클럭과 동기화되어 있기 때문에 CPU는 클럭이 실행되는 것보다 더 빨리 작업을 수행할 수 없습니다. 그러나 CPU가 특정 클럭 주파수로 실행된다고 해서 초당 그렇게 많은 작업을 수행하는 것은 아닙니다.,"Because all CPU operations are synchronized with the clock, the CPU cannot perform tasks any faster than the clock runs. However, just because a CPU is running at some clock frequency doesn't mean that it executes that many operations each second.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메모리 액세스 시간은 어떻게 되나요?,What is the memory access time?,메모리 액세스 시간은 메모리 요청(읽기 또는 쓰기)과 메모리 작업이 완료될 때까지의 클럭 사이클 수입니다. 이는 메모리 액세스 시간이 길어질수록 성능이 저하되기 때문에 중요한 값입니다.,"The memory access time is the number of clock cycles between a memory request (read or write) and when the memory operation completes. This is an important value, because longer memory access times result in lower performance.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CPU가 메모리 접근을 위해 대기 상태를 사용하는 이유는 무엇인가요?,Why does the CPU use wait states for memory accesses?,CPU는 메모리를 기다리지 않습니다. 액세스 시간은 버스 클럭 주파수에 의해 지정됩니다. 메모리 하위 시스템이 CPU의 예상 액세스 시간을 따라잡을 만큼 빠르게 작동하지 않으면 CPU는 메모리 읽기 작업에서 가비지 데이터를 읽고 메모리 쓰기에 데이터를 제대로 저장하지 못합니다. 이렇게 하면 시스템이 확실히 실패하게 됩니다.,"The CPU doesn't wait for memory. The access time is specified by the bus clock frequency. If the memory subsystem doesn't work fast enough to keep up with the CPU's expected access time, the CPU will read garbage data on a memory read operation and will not properly store the data on a memory write. This will surely cause the system to fail.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메모리 액세스 대기는 어떻게 작동하나요?,How do memory access waits work?,존재하는 거의 모든 범용 CPU는 대기 상태를 삽입할 수 있는 핀(제어 버스에 나타나는 신호)을 제공합니다. 필요한 경우 메모리 주소 디코딩 회로는 이 신호를 주장하여 메모리에 충분한 액세스 시간을 제공합니다.,"Almost every general-purpose CPU in existence provides a pin (whose signal appears on the control bus) that allows the insertion of wait states. If necessary, the memory address decoding circuitry asserts this signal to give the memory sufficient access time.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CPU는 어떻게 과도한 대기 상태를 피할 수 있나요?,How does the CPU avoid excessive wait states?,하지만 대기 상태가 추가되었다고 해서 실행 속도가 느려지는 것은 아닙니다. 하드웨어 설계자가 대부분의 경우 대기 상태를 제로로 만들기 위해 사용할 수 있는 몇 가지 트릭이 있습니다. 이 중 가장 일반적인 트릭은 캐시 메모리를 사용하는 것입니다.,"However, we're not doomed to slow execution because of added wait states. There are several tricks hardware designers can employ to achieve zero wait states most of the time. The most common of these is the use of cache memory.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
참조의 시간적 국소성과 참조의 공간적 국소성은 무엇인가요?,What are temporal locality of reference and spatial locality of reference?,일반적인 프로그램을 살펴보면 동일한 메모리 위치에 반복적으로 액세스하는 경향이 있다는 것을 알 수 있습니다. 또한 프로그램이 인접한 메모리 위치에 자주 액세스한다는 사실도 알게 될 것입니다. 이러한 현상에 부여되는 기술적 명칭은 참조의 시간적 위치와 참조의 공간적 위치입니다. 공간적 위치를 표시할 때 프로그램은 처음 메모리에 액세스한 후 짧은 기간 내에 인접한 메모리 위치에 액세스합니다.,"If you look at a typical program, you'll discover that it tends to access the same memory locations repeatedly. Furthermore, you'll also discover that a program often accesses adjacent memory locations. The technical names given to these phenomena are temporal locality of reference and spatial locality of reference. When exhibiting spatial locality, a program accesses neighboring memory locations within a short period after the initial memory access.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
참조의 시간적 지역성이란 무엇인가요?,What is temporal locality of reference?,"참조의 시간적 위치를 표시할 때, 프로그램은 짧은 시간 동안 동일한 메모리 위치에 반복적으로 접근합니다.","When displaying temporal locality of reference, a program accesses the same memory location repeatedly during a short time.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CPU는 데이터를 캐시에 어떻게 보관할 수 있나요?,How can a CPU keep data in cache?,캐시 메모리는 주소를 동적으로 재할당할 수 있습니다. 이를 통해 시스템은 최근에 액세스한 값을 캐시에 유지할 수 있습니다. CPU가 한 번도 액세스한 적이 없거나 한동안 액세스하지 않은 주소는 메인(느린) 메모리에 남아 있습니다. 대부분의 메모리 액세스는 최근에 액세스한 변수(또는 최근에 액세스한 위치 근처의 위치)로 이루어지기 때문에 데이터는 일반적으로 캐시 메모리에 나타납니다.,"Cache memory can dynamically reassign addresses. This allows the system to keep recently accessed values in the cache. Addresses that the CPU has never accessed or hasn't accessed in some time remain in main (slow) memory. Because most memory accesses are to recently accessed variables (or to locations near a recently accessed location), the data generally appears in cache memory.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
캐시 미스가 발생했을 때 CPU는 어떻게 최적화할 수 있나요?,How can CPUs optimize when a cache miss occurs?,"캐시 미스가 발생하면 대부분의 캐싱 시스템은 여러 바이트의 메인 메모리를 연속적으로 읽습니다(엔지니어들은 이 데이터 블록을 캐시 라인이라고 부릅니다). 예를 들어, 캐시 미스 시 80x86 CPU는 16바이트에서 64바이트 사이에서 읽습니다.","When a cache miss occurs most caching systems will read several consecutive bytes of main memory (engineers call this block of data a cache line). 80x86 CPUs, for example, read between 16 and 64 bytes upon a cache miss.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
대규모 3단계 캐시의 이점은 무엇인가요?,"What is the benefit of a large, third-level cache?","상당한 데이터를 조작하면서도 참조 지역성을 보이는 프로그램의 경우, 3단계 캐싱 서브시스템이 매우 효과적일 수 있습니다.","For programs that manipulate considerable data, yet exhibit locality of reference, a third-level caching subsystem can be very effective.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
직접 주소 지정 모드란 무엇인가요?,What is direct addressing mode?,직접 주소 지정 모드는 변수에 접근하는 실제 기계 명령의 일부로 변수의 메모리 주소를 인코딩합니다.,The direct addressing mode encodes a variable's memory address as part of the actual machine instruction that accesses the variable.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
간접 주소 지정 모드란 무엇인가요?,What is indirect addressing mode?,"간접 주소 지정 모드는 일반적으로 레지스터를 사용하여 메모리 주소를 저장합니다(메모리 위치를 사용하여 간접 주소를 저장하는 CPU가 몇 개 있지만, 현대의 CPU에서는 이러한 형태의 간접 주소 지정이 드뭅니다).","The indirect addressing mode typically uses a register to hold a memory address (there are a few CPUs that use memory locations to hold the indirect address, but this form of indirect addressing is rare in modern CPUs).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인덱싱된 주소 지정 모드란 무엇인가요?,What is indexed addressing mode?,"인덱싱된 어드레싱 모드는 직접 및 간접 어드레싱 모드를 하나의 어드레싱 모드로 결합합니다. 구체적으로, 이 어드레싱 모드를 사용하는 기계 명령어는 명령어를 구성하는 비트의 오프셋(직접 주소)과 레지스터를 모두 인코딩합니다. 실행 시 CPU는 이 두 주소 구성 요소의 합을 계산하여 효과적인 주소를 만듭니다.","The indexed addressing mode combines the direct and indirect addressing modes into a single addressing mode. Specifically, the machine instructions using this addressing mode encode both an offset (direct address) and a register in the bits that make up the instruction. At run time, the CPU computes the sum of these two address components to create an effective address.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
포인터란 무엇인가요?,What is a pointer?,포인터는 다른 메모리 객체의 주소를 나타내는 메모리 변수입니다.,A pointer is a memory variable whose value is the address of some other memory object.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CPU는 배열을 어떻게 배치하나요?,How does a CPU lay out an array?,"많은 최적화 컴파일러는 배열을 2바이트, 4바이트, 8바이트와 같은 일반적인 크기의 짝수 배수인 메모리 주소로 배치하려고 시도합니다. 이렇게 하면 배열 시작 전에 패딩 바이트를 효과적으로 추가하거나, 이렇게 생각하고 싶다면 메모리 내 이전 객체의 끝에 패딩 바이트를 추가합니다.","Many optimizing compilers will attempt to place an array starting at a memory address that is an even multiple of some common size like two, four, or eight bytes. This effectively adds padding bytes before the beginning of the array or, if you prefer to think of it this way, it adds padding bytes to the end of the previous object in memory.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
컴파일러/CPU는 어떻게 A[i][j][k][m]에 접근하나요?,How does a compiler/CPU access A[i][j][k][m]?,주소 = 베이스 + (((i * bounds1 + j) * bounds2 + k) * bounds3 + m) * Element_Size,Address = Base + (((i * bounds1 + j) * bounds2 + k) * bounds3 + m) * Element_Size,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인텔 80x86 CPU 명령어의 크기는 어떻게 되나요?,What are the sizes for Intel 80x86 CPU instructions?,기계 지침의 길이는 1바이트에서 거의 15바이트에 달합니다.,With machine instructions ranging from 1 to almost 15 bytes long.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
깃발 레지스터는 무엇인가요?,What is the flags register?,"플래그 레지스터는 조건 코드 레지스터 또는 프로그램 상태 단어라고도 하며, CPU의 부울 변수 배열로, 이전 명령어가 오버플로우, 제로 결과, 부정 결과 또는 기타 이러한 조건을 생성했는지 추적합니다.","The flags register, also known as the condition-codes register or program-status word, is an array of Boolean variables in the CPU that tracks whether the previous instruction produced an overflow, a zero result, a negative result, or other such condition.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
BIU는 무엇이며 어떤 역할을 하나요?,What is the BIU and what does it do?,"실행 장치가 BIU(버스 인터페이스 유닛)를 사용하지 않을 때, BIU는 기계 명령어를 저장하는 메모리에서 추가 바이트를 가져와 프리페치 큐에 저장할 수 있습니다.","Whenever the execution unit is not using the BIU (Bus Interface Unit), the BIU can fetch additional bytes from the memory that holds the machine instructions and store them in the prefetch queue.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프리페치 대기열이 가득 차 있지 않을 때 CPU는 무엇을 최적화할 수 있나요?,What can the CPU optimize when the prefetch queue is not full?,"프리페치 큐가 가득 차 있지 않고(일반적으로 프로세서에 따라 8바이트에서 32바이트 사이를 유지할 수 있습니다) 현재 클럭 사이클에서 BIU가 유휴 상태인 경우, 클럭 사이클 시작 시 EIP 레지스터에 있는 주소에 있는 다음 더블 워드를 가져옵니다.","If the prefetch queue is not full (generally it can hold between 8 and 32 bytes, depending on the processor) and the BIU is idle on the current clock cycle, fetch the next double word located at the address found in the EIP register at the beginning of the clock cycle.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
명령 디코더가 유휴 상태일 때 CPU는 무엇을 할 수 있나요?,What can a CPU do when the instruction decoder is idle?,"명령 디코더가 유휴 상태이고 현재 명령어에 명령어 피연산자가 필요하지 않은 경우, CPU는 프리페치 큐의 앞쪽에서 연산 코드 디코딩을 시작해야 합니다. 현재 명령어에 명령어 피연산자가 필요한 경우, CPU는 프리페치 큐의 해당 피연산자 바로 너머에서 바이트 디코딩을 시작합니다.","If the instruction decoder is idle and the current instruction does not require an instruction operand, the CPU should begin decoding the opcode at the front of the prefetch queue. If the current instruction requires an instruction operand, then the CPU begins decoding the byte just beyond that operand in the prefetch queue.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
지침이 파이프라인에 연결될 때 성능을 저하시키는 것은 무엇인가요?,What hurts performance when instructions are being pipelined?,"빠른 코드를 작성하고 싶다면, 가능한 한 프로그램에서 뛰어다니지 마세요.","If you want to write fast code, avoid jumping around in your program as much as possible.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
코드에서 지점/점프를 정리하는 것이 가장 좋은가요?,How is it best to organize branches/jumps in your code?,"따라서 프로그램을 작성할 때 어떤 점프 조건이 가장 자주 발생하는지 판단할 수 있다면, 가장 일반적인 조건이 프로그램이 별도의 위치로 점프하는 대신 다음 명령을 계속 진행하도록 프로그램을 구성해야 합니다.","Therefore, if you can determine, while writing the program, which jump condition occurs most frequently, you should arrange your program so that the most common condition causes the program to continue with the next instruction rather than jump to a separate location.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메모리 액세스와 명령어 프리패치는 리소스를 어떻게 경쟁하나요?,How do memory access and instruction prefetches contend for resources?,CPU는 다른 용도로 버스를 사용해야 한다는 점을 잊지 마세요. 메모리에 액세스하는 명령어는 버스에 액세스하기 위해 프리페치 큐와 경쟁합니다.,"Don't forget, the CPU needs to use the bus for other purposes. Instructions that access memory compete with the prefetch queue for access to the bus.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
버스 경쟁은 어떻게 발생하나요?,How can bus contention occur?,버스 경합은 명령어가 메모리의 항목에 액세스해야 할 때마다 발생할 수 있습니다. CPU가 메모리에서 데이터를 가져오고 메모리에 데이터를 동시에 쓰려고 하기 때문에 주소와 데이터 버스에 대한 경합이 발생할 수 있습니다.,Bus contention can occur whenever an instruction needs to access an item in memory. Contention for the address and data bus may develop because the CPU will be trying to fetch data from memory and write data to memory simultaneously.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이프라인 스톨이란 무엇이며 무엇을 해결하는 데 도움이 되나요?,What is a pipeline stall and what does it help to solve?,버스 경합을 처리하는 한 가지 간단한 방법은 파이프라인 스톨을 통해 처리하는 것입니다. 버스에 대한 경합이 발생하면 CPU는 파이프라인에서 가장 멀리 떨어진 명령어에 우선순위를 부여합니다. 이로 인해 파이프라인의 나중 명령어가 스톨되고 해당 명령어를 실행하는 데 두 사이클이 걸립니다,"One simplistic way to handle bus contention is through a pipeline stall. The CPU, when faced with contention for the bus, gives priority to the instruction farthest along in the pipeline. This causes the later instruction in the pipeline to stall, and it takes two cycles to execute that instruction",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
점프와 관련된 파이프라인 가판대의 예는 무엇인가요?,What is an example of pipeline stalls involving a jump?,"파이프라인 스톨의 또 다른 예로, 명령어가 EIP 레지스터의 값을 수정할 때 어떤 일이 발생하는지 고려해 보세요. 예를 들어, jnz(0이 아닌 점프) 명령어는 제어를 대상 레이블에 조건부로 전송하면 EIP 레지스터의 값을 변경할 수 있습니다. 이는 물론 다음에 실행될 명령어 세트가 EIP를 수정하는 명령어를 즉시 따르지 않는다는 것을 의미합니다. 명령어 jnz가 실행을 완료할 때쯤(제로 플래그가 명확하므로 분기를 수행한다고 가정하면), 우리는 이미 다섯 개의 다른 명령어를 시작했으며, 이 중 첫 번째 명령어의 완료까지 한 클럭 사이클만 남았습니다. 물론 CPU는 이러한 명령어를 실행해서는 안 되며, 그렇지 않으면 부적절한 결과를 계산할 것입니다. 유일한 합리적인 해결책은 파이프라인 전체를 플러시하고 운영 코드를 새로 가져오기 시작하는 것입니다. 이렇게 하면 실행 시간에 심각한 불이익이 발생합니다.","As another example of a pipeline stall, consider what happens when an instruction modifies the value in the EIP register. For example, the jnz (jump if not zero) instruction might change the value in the EIP register if it conditionally transfers control to its target label. This, of course, implies that the next set of instructions to be executed does not immediately follow the instruction that modifies EIP. By the time the instruction jnz completes execution (assuming the zero flag is clear, so that the branch is taken), we've already started five other instructions and we're only one clock cycle away from the completion of the first of these. Obviously, the CPU must not execute those instructions, or it will compute improper results. The only reasonable solution is to flush the entire pipeline and begin fetching opcodes anew. Doing so causes a severe execution-time penalty.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
제어 위험은 언제 발생하나요?,When does a control hazard occur?,"CPU가 메모리의 새로운 위치로 분기할 때마다 제어 위험이 발생하며, 따라서 실행 단계에 있는 명령어를 파이프라인에서 플러시해야 합니다.",A control hazard occurs whenever the CPU branches to some new location in memory and consequently has to flush from the pipeline the instructions that are in various stages of execution.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
데이터 위험은 언제 발생하나요?,When does a data hazard occur?,데이터 위험은 한 명령어의 소스 피연산자가 이전 명령어의 목적지 피연산자일 때 발생한다는 점에 유의하세요.,Note that a data hazard occurs when the source operand of one instruction was a destination operand of a previous instruction.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
슈퍼스칼라 CPU의 특별한 점은 무엇인가요?,What is special about a superscalar CPU?,슈퍼스칼라 CPU에는 여러 실행 단위가 있습니다. 프리페치 대기열에서 독립적으로 실행할 수 있는 두 개 이상의 명령어가 발생하면 그렇게 됩니다.,"A superscalar CPU has several execution units. If it encounters in the prefetch queue two or more instructions that can execute independently, it will do so.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
고장난 실행이란 무엇인가요?,What is out-of-order execution?,CPU는 코드 스트림에 이전에 표시된 명령어가 완료되기 전에 명령어를 실행할 수 있습니다.,The CPU can execute instructions prior to the completion of instructions appearing previously in the code stream.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CPU가 가진 레지스터보다 더 많은 레지스터를 어떻게 사용할 수 있을까요?,How can a CPU use more registers than it has?,레지스터 이름 변경은 CPU에 실제보다 더 많은 레지스터를 제공하는 교활한 방법입니다. 프로그래머는 이러한 추가 레지스터에 직접 액세스할 수 없지만 CPU는 특정 경우에 위험을 방지하기 위해 레지스터를 사용할 수 있습니다.,"Register renaming is a sneaky way to give a CPU more registers than it actually has. Programmers will not have direct access to these extra registers, but the CPU can use them to prevent hazards in certain cases.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
VLIW 시스템의 특별한 점은 무엇인가요?,What is special about a VLIW system?,"VLIW 컴퓨터 시스템에서 CPU는 큰 바이트 블록(IA-64 Itanium CPU의 경우 41비트)을 가져와 이 블록을 한꺼번에 디코딩하고 실행합니다. 이 바이트 블록에는 보통 두 개 이상의 명령어(IA-64의 경우 세 개)가 포함되어 있습니다. VLIW 컴퓨팅은 프로그래머나 컴파일러가 각 블록의 명령어를 적절히 스케줄링하여 위험이나 기타 충돌이 없도록 해야 하지만, 적절하게 스케줄링하면 CPU는 클럭 사이클당 세 개 이상의 명령어를 실행할 수 있습니다.","In a VLIW computer system, the CPU fetches a large block of bytes (41 bits in the case of the IA-64 Itanium CPU) and decodes and executes this block all at once. This block of bytes usually contains two or more instructions (three in the case of the IA-64). VLIW computing requires the programmer or compiler to properly schedule the instructions in each block so that there are no hazards or other conflicts, but if properly scheduled, the CPU can execute three or more instructions per clock cycle.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
SIMD란 무엇이며 어떤 역할을 하나요?,What is SIMD and what does it do?,"SIMD(단일 명령 다중 데이터) 모델에서는 CPU가 순수 SISD 모델과 마찬가지로 단일 명령어 스트림을 실행합니다. 그러나 SIMD 모델에서는 CPU가 단일 데이터 개체가 아닌 여러 데이터 조각에서 동시에 작동합니다.

SIMD 버전의 덧셈은 여러 값의 합을 동시에 계산합니다. 펜티엄 III의 MMX 및 SIMD 명령어 확장과 PowerPC의 AltaVec 명령어는 정확히 이러한 방식으로 작동합니다. 예를 들어, paddb MMX 명령어를 사용하면 단일 명령어를 실행하여 최대 8쌍의 개별 값을 더할 수 있습니다.","In the SIMD (Single Instruction Multiple Data) model, the CPU executes a single instruction stream, just like the pure SISD model. However, in the SIMD model, the CPU operates on multiple pieces of data concurrently rather than on a single data object.

An SIMD version of add, would compute the sum of several values simultaneously. The Pentium III's MMX and SIMD instruction extensions, and the PowerPC's AltaVec instructions, operate in exactly this fashion. With the paddb MMX instruction, for example, you can add up to eight separate pairs of values with the execution of a single instruction.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
MMX 레지스터는 범용 레지스터와 어떻게 다른가요?,How are MMX registers different from a general purpose register?,MMX 레지스터(MM0 및 MM1)는 실제로 8개의 독립적인 바이트 값을 보유합니다(MMX 레지스터는 64비트 너비이지만 단일 64비트 값이 아닌 8비트 값으로 취급됩니다),MMX registers (MM0 and MM1) actually hold eight independent byte values (the MMX registers are 64 bits wide but are treated as eight 8-bit values rather than as a single 64-bit value),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
MIMD란 무엇인가요?,What is MIMD?,"다중 명령, 다중 데이터
여러 프로그램이 동시에 실행을 시도하는 멀티프로그래밍 환경이 있는 경우, MIMD 모델을 사용하면 각 프로그램이 자체 코드 스트림을 동시에 실행할 수 있습니다. 이러한 유형의 병렬 시스템을 멀티프로세서 시스템이라고 합니다.","Multiple Instruction, Multiple Data
If you have a multiprogramming environment with multiple programs attempting to execute concurrently, the MIMD model does allow each of those programs to execute their own code stream simultaneously. This type of parallel system is called a multiprocessor system.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
다중 처리(여러 프로세서에서 실행 중)가 언제 도움이 되지 않나요?,When does multiprocessing (running on multiple processors) not help you?,멀티프로세싱은 프로그램이 멀티프로세서 시스템에서 사용하도록 특별히 작성되지 않는 한 프로그램의 성능에 도움이 되지 않습니다.,Multiprocessing doesn't help a program's performance unless that program is specifically written for use on a multiprocessor system.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
캐시 일관성 문제란 무엇인가요?,What is the cache-coherency problem?,"메모리에서 동일한 객체에서 작동하는 여러 CPU. 
이 두 기능이 제대로 작동하려면 두 CPU가 공유 객체를 변경할 때마다 서로에게 통지해야 하므로 다른 CPU가 로컬 캐시된 복사본을 업데이트할 수 있습니다.","Multiple CPUs operating on the same object in memory. 
In order for these two functions to operate properly, the two CPUs must notify each other whenever they make changes to shared objects, so the other CPU can update its local, cached copy.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
하이퍼스레딩이란 무엇인가요?,What is hyper-threading?,일반적인 슈퍼스칼라 프로세서에서는 명령어 시퀀스가 각 클럭 사이클에서 CPU의 모든 기능 단위를 활용하는 경우가 드뭅니다. CPU는 이러한 기능 단위를 사용하지 않도록 하는 대신 두 개의 별도 실행 스레드를 동시에 실행하고 모든 CPU의 기능 단위를 점유 상태로 유지할 수 있습니다. 이렇게 하면 단일 CPU가 일반적인 멀티프로세서 시스템에서 1.5개의 CPU 작업을 효과적으로 수행할 수 있습니다.,"In a typical superscalar processor it is rare for an instruction sequence to utilize all the CPU's functional units on each clock cycle. Rather than allow those functional units to go unused, the CPU can run two separate threads of execution concurrently and keep all the CPU's functional units occupied. This allows a single CPU to, effectively, do the work of 1.5 CPUs in a typical multiprocessor system.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
NUMA란 무엇인가요?,What is NUMA?,"비균일 메모리 액세스의 약자인 NUMA는 약간 잘못된 이름입니다. NUMA라는 용어는 메모리 유형에 따라 액세스 시간이 다르므로 전체 메모리 계층을 설명합니다. 
NUMA 메모리의 좋은 예는 비디오 디스플레이 카드의 메모리입니다. 또 다른 예는 플래시 메모리로, 표준 반도체 RAM보다 액세스 및 전송 시간이 훨씬 느립니다.","NUMA, which stands for Non-Uniform Memory Access, is a bit of a misnomer. The term NUMA implies that different types of memory have different access times, and so it is descriptive of the entire memory hierarchy. 
A good example of NUMA memory is the memory on a video display card. Another example is flash memory, which has significantly slower access and transfer times than standard semiconductor RAM.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가상 메모리란 무엇인가요?,What is virtual memory?,대부분의 최신 컴퓨터 시스템은 대용량 저장 디스크 드라이브를 사용하여 주 메모리를 시뮬레이션하는 가상 메모리 방식을 구현합니다. 가상 메모리 하위 시스템은 프로그램에서 필요한 경우 디스크와 주 메모리 간에 데이터를 투명하게 복사하는 역할을 합니다.,Most modern computer systems implement a virtual memory scheme that simulates main memory using a mass storage disk drive. A virtual memory subsystem is responsible for transparently copying data between the disk and main memory as needed by programs.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DSM이란 무엇인가요?,What is DSM?,분산 공유 메모리(DSM)는 서로 다른 컴퓨터 시스템에서 실행되는 프로세스가 공통 메모리 블록에 저장된 데이터를 공유하고 네트워크를 통해 해당 블록에 대한 변경 사항을 전달합니다.,"Distributed shared memory (DSM), where processes running on different computer systems share data stored in a common block of memory and communicate changes to that block across the network.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
오프라인 저장의 예는 무엇인가요?,What are examples of offline storage?,"자기 테이프, 디스크 카트리지, 광학 디스크, 그리고 플로피 디스크.","Magnetic tapes, disk cartridges, optical disks, and floppy diskettes.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
주 메모리 액세스에 대한 페널티는 무엇인가요? 왜 한 사이클도 걸리지 않나요?,What is the penalty for a main memory access? Why does it never take one cycle?,"프로그램이 주 메모리에서 데이터를 가져와야 하는 경우, 999 메모리 액세스 이후에도 인텔 문서에서 한 사이클에 걸쳐 발생해야 한다고 주장하는 데이터에 액세스하는 데 평균 두 클럭 사이클의 비용을 지불해야 합니다.","If the program has to bring the data from main memory, 999 memory accesses later you're still paying an average cost of two clock cycles to access the data that Intel's documentation claims should happen in one cycle.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
L2 액세스의 클럭 타이밍 페널티는 무엇인가요?,What is the clock timing penalty of an L2 access?,"L2 캐시에서 데이터에 접근하는 것은 항상 L1 캐시에서보다 느리며, L2 캐시에서 데이터에 접근할 때는 항상 최소한 하나의 대기 상태와 최대 여덟 개의 대기 상태가 존재합니다.","Accessing data in the L2 cache is always slower than in the L1 cache, and there is always the equivalent of at least one wait state, and up to eight, when accessing data in the L2 cache.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
L2 캐시 액세스는 어떻게 비용을 지불하는 데 도움이 되나요?,How does L2 cache access help pay for itself?,"If you execute the mov(mem32,eax); instruction, and mem32's value is not in the L1 cache, the cache controller doesn't simply read mem32's 32 bits from the L2 cache, assuming that it's present there. Instead, the cache controller will actually read a whole block of bytes (generally 16, 32, or 64 bytes, depending on the particular processor) from the L2 cache.","If you execute the mov(mem32,eax); instruction, and mem32's value is not in the L1 cache, the cache controller doesn't simply read mem32's 32 bits from the L2 cache, assuming that it's present there. Instead, the cache controller will actually read a whole block of bytes (generally 16, 32, or 64 bytes, depending on the particular processor) from the L2 cache.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
캐시 라인당 바이트 수는 몇 개인가요?,How many bytes are there per cache line?,"캐시 메모리는 일반적으로 캐시 라인 블록으로 구성되며, 각 라인에는 몇 개의 바이트(일반적으로 16, 32, 64와 같은 두 개의 작은 전력)가 포함되어 있습니다","Cache memory is usually organized in blocks of cache lines, with each line containing some number of bytes (typically a small power of two like 16, 32, or 64)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
캐시 라인과 정렬의 관계는 무엇인가요?,What is the relationship to cache lines to their alignment?,"일반적으로 캐시 라인의 길이가 n바이트인 경우, 해당 캐시 라인은 n바이트 경계에 있는 메인 메모리에서 n바이트를 저장합니다.","Generally, if a cache line is n bytes long, that cache line will hold n bytes from main memory that fall on an n-byte boundary.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
512개의 캐시 라인을 사용하는 메모리 주소의 비트는 캐시 라인과 바이트에 매핑하는 데 어떻게 사용되나요?,"With 512 cache lines, how are the bits in the memory address used to map to a cache line and byte?","8 KB cache with 512 16-byte cache lines and a 32-bit main-memory address. Because there are 512 cache lines, it requires 9 bits to select one of the cache lines (29 = 512). This example uses bits 4 through 12 to determine which cache line to use (assuming we number the cache lines from 0 to 511), while bits 0 through 3 of the original memory address determine the particular byte within the 16-byte cache line.","8 KB cache with 512 16-byte cache lines and a 32-bit main-memory address. Because there are 512 cache lines, it requires 9 bits to select one of the cache lines (29 = 512). This example uses bits 4 through 12 to determine which cache line to use (assuming we number the cache lines from 0 to 511), while bits 0 through 3 of the original memory address determine the particular byte within the 16-byte cache line.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
일반적으로 완전 연상 캐시를 사용하지 않는 이유는 무엇인가요?,Why are fully associative caches generally not used?,"완전한 연관성을 달성하기 위한 추가 회로는 비용이 많이 들고, 더 나쁘게는 메모리 하위 시스템의 속도를 늦출 수 있습니다.","The extra circuitry to achieve full associativity is expensive and, worse, can slow down the memory subsystem.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"어떤 종류의 캐시가 명령어, 코드에 더 적합한가요?","Which type of caches are better for instructions, for code?","특히 직접 매핑 캐시는 무작위 방식이 아닌 순차적으로 액세스하는 데이터에 매우 유용합니다. CPU는 일반적으로 순차적으로 명령어를 실행하기 때문에 명령어 바이트를 직접 매핑 캐시에 매우 효과적으로 저장할 수 있습니다. 그러나 프로그램은 코드보다 데이터에 더 무작위로 액세스하는 경향이 있기 때문에 양방향 또는 4방향 집합 연관 캐시가 일반적으로 직접 매핑 캐시보다 데이터 액세스에 더 적합한 선택입니다.

데이터 바이트와 기계 명령 바이트는 일반적으로 서로 다른 접근 패턴을 가지고 있기 때문에, 많은 CPU 설계자들은 각각 별도의 캐시를 사용합니다.","In particular, the direct-mapped cache is very good for data that you access in a sequential rather than random fashion. Because the CPU typically executes instructions in a sequential fashion, instruction bytes can be stored very effectively in a direct-mapped cache. However, because programs tend to access data more randomly than code, a two-way or four-way set associative cache usually makes a better choice for data accesses than a direct-mapped cache.

Because data and machine instruction bytes usually have different access patterns, many CPU designers use separate caches for each.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
시간적 지역성이란 무엇인가요?,What is temporal locality?,메모리 위치에 한동안 액세스하지 않았다면 CPU가 다시 액세스하기까지 오랜 시간이 걸릴 가능성이 높습니다.,"If a memory location has not been accessed in a while, it is likely to be a long time before the CPU accesses it again.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
많은 캐싱 컨트롤러가 사용하는 좋은 대체 정책은 무엇인가요?,What is a good replacement policy that many caching controllers use?,가장 최근에 사용된 (LRU) 알고리즘.,The least recently used (LRU) algorithm.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
쓰기 정책이란 무엇인가요?,What is write-through policy?,쓰기 정책에 따르면 데이터가 캐시에 기록될 때마다 캐시는 즉시 돌아서서 해당 캐시 라인의 복사본을 메인 메모리에 기록합니다.,"The write-through policy states that any time data is written to the cache, the cache immediately turns around and writes a copy of that cache line to main memory.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
두 개의 서로 다른 CPU가 공유 메모리를 통해 통신할 때 사용할 수 있는 좋은 캐시 쓰기 정책은 무엇인가요?,What is a good cache write policy to use when two different CPUs are communicating through shared memory?,"쓰기 정책은 주 메모리를 가능한 한 빨리 새로운 값으로 업데이트하기 때문에, 두 개의 다른 CPU가 공유 메모리를 통해 통신할 때 사용하는 것이 더 나은 정책입니다.","Because the write-through policy updates main memory with the new value as rapidly as possible, it is a better policy to use when two different CPUs are communicating through shared memory.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
환급 정책이란 무엇인가요?,What is a write-back policy?,이 모드에서는 캐시에 대한 쓰기가 즉시 메인 메모리에 기록되지 않고 캐시 컨트롤러가 나중에 메인 메모리를 업데이트합니다. 이 방식은 짧은 시간 내에 동일한 캐시 라인에 여러 개의 쓰기가 메인 메모리에 여러 개의 쓰기를 생성하지 않기 때문에 성능이 더 높은 경향이 있습니다.,"In this mode, writes to the cache are not immediately written to main memory; instead, the cache controller updates main memory at a later time. This scheme tends to be higher performance because several writes to the same cache line within a short time period do not generate multiple writes to main memory.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
캐시는 메인 메모리에 다시 기록해야 하는 데이터를 어떻게 추적하나요?,How does a cache keep track of data that needs to be written back to main memory?,캐시 컨트롤러는 일반적으로 각 캐시 라인 내에 더티 비트를 유지합니다. 캐시 시스템은 캐시에 데이터를 쓸 때마다 이 비트를 설정합니다.,the cache controller usually maintains a dirty bit within each cache line. The cache system sets this bit whenever it writes data to the cache.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
캐시 컨트롤러가 캐시 라인을 메모리의 다른 데이터로 대체하기 전에 해야 할 일은 무엇인가요?,What does a cache controller have to do before it replaces a cache line with other data from memory?,"캐시 컨트롤러가 캐시 라인을 메모리의 다른 데이터로 교체할 때마다 먼저 더티 비트를 확인해야 하며, 해당 비트가 설정된 경우 캐시 라인 교체를 진행하기 전에 해당 캐시 라인을 메모리에 기록해야 합니다.","Whenever the cache controller replaces a cache line with other data from memory, it must first check the dirty bit, and if that bit is set, the controller must write that cache line to memory before going through with the cache-line replacement.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
캐시 시스템이 효과적이려면 소프트웨어에 내재된 것이 무엇인가요?,What has to be inherent in software in order for a cache system to be effective?,캐시 시스템이 효과적이려면 소프트웨어가 참조의 로컬리티(공간적 또는 시간적)를 나타내야 합니다. 다행히도 실제 프로그램은 참조의 로컬리티를 나타내는 경향이 있으므로 대부분의 프로그램은 메모리 하위 시스템에 캐시가 있는 경우 이점을 누릴 수 있습니다.,"In order for a cache system to be effective, software must exhibit locality of reference (either spatial or temporal). Fortunately, real-world programs tend to exhibit locality of reference, so most programs will benefit from the presence of a cache in the memory subsystem.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메모리 페이지란 무엇인가요?,What are memory pages?,"메모리를 페이지라고 하는 바이트 블록으로 나눕니다. 메인 메모리의 페이지는 캐시 하위 시스템의 캐시 라인과 비슷하지만 일반적으로 페이지가 캐시 라인보다 훨씬 큽니다. 예를 들어 80x86 CPU는 페이지 크기가 4,096바이트입니다.","You break up memory into blocks of bytes called pages. A page in main memory is comparable to a cache line in a cache subsystem, although pages are usually much larger than cache lines. For example, the 80x86 CPUs use a page size of 4,096 bytes.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
페이지 테이블이 캐시 공간을 차지하지 않는 방법은 무엇인가요?,How does the page table not take up cache space?,"페이지 테이블 항목으로 데이터 또는 명령 캐시를 혼란스럽게 하여 데이터 및 명령 요청에 대한 캐시 누락 수를 증가시키는 것을 방지하기 위해, 페이지 테이블은 번역 룩어사이드 버퍼(TLB)로 알려진 자체 캐시를 사용합니다.","To prevent cluttering the data or instruction cache with page-table entries, which increases the number of cache misses for data and instruction requests, the page table uses its own cache, known as the translation lookaside buffer (TLB).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
페이지 테이블 항목의 비트는 어떻게 사용되나요?,How are the bits in a page table entry used?,"페이지 테이블의 각 항목에는 32비트가 포함되어 있지만, 시스템은 실제로 각 가상 주소를 물리적 주소로 재매핑하는 데 20비트만 필요합니다. 80x86의 인텔은 나머지 12비트 중 일부를 메모리 보호 정보로 사용합니다.","Each entry in the page table contains 32 bits, even though the system really only needs 20 bits to remap each virtual address to a physical address. Intel, on the 80x86, uses some of the remaining 12 bits to provide some memory-protection information.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
소프트웨어가 페이지 테이블의 비트를 어떻게 변경할 수 있나요?,How can your software change bits in the page table?,"귀하의 애플리케이션은 페이지 테이블에 접근할 수 없으므로(페이지 테이블을 읽고 쓰는 것은 운영 체제의 책임입니다), 따라서 이러한 비트를 수정할 수 없습니다. 그러나 Windows와 같은 운영 체제에서는 페이지 테이블의 특정 비트를 변경하고자 할 때 호출할 수 있는 몇 가지 기능을 제공할 수 있습니다(예: Windows에서는 페이지를 읽기 전용으로 설정할 수 있습니다)","Note that your applications do not have access to the page table (reading and writing the page table is the operating system's responsibility), and therefore they cannot modify these bits. However, operating systems like Windows may provide some functions you can call if you want to change certain bits in the page table (for example, Windows will allow you to set a page to read-only if you want to do so)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
작업 세트란 무엇인가요?,What is a working set?,"어느 시점에서든 프로그램은 데이터와 명령어 바이트를 포함하는 메인 메모리의 페이지 중 극히 일부만 접근할 수 있으며, 이 페이지 집합을 작업 집합이라고 합니다.","At any given time, a program will only access a small percentage of the pages in main memory that contain data and instruction bytes and this set of pages is known as the working set.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메모리에서 페이지에 액세스하려고 하면 어떻게 되나요?,What happens when you attempt to access a page in memory?,메모리 페이지에 접근하려고 할 때 페이지 테이블 비트가 메모리 관리 장치(MMU)에 해당 페이지가 메인 메모리에 존재하지 않는다고 알려주면 CPU가 프로그램을 중단하고 운영 체제에 제어 권한을 넘깁니다.,"If you attempt to access a page of memory, and the page-table bit tells the memory management unit (MMU) that the page is not present in main memory, the CPU interrupts the program and passes control to the operating system.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
어떻게 메인 메모리를 생각할 수 있나요?,How can you think of main memory?,"메인 메모리는 디스크 드라이브에 저장된 데이터를 캐시하는 4,096바이트 캐시 라인을 가진 완전 연상 쓰기-백 캐시라고 생각할 수 있습니다.","You can think of main memory as a fully associative write-back cache with 4,096-byte cache lines, which caches the data that is stored on the disk drive.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
일반적인 페이지 크기는 무엇인가요?,What are typical page sizes?,페이지 크기는 CPU에 따라 약 1KB에서 64KB까지 다양한 경향이 있습니다. 4GB보다 큰 주소 공간을 지원하는 CPU의 경우 일부 CPU는 반전 페이지 테이블 또는 3단계 페이지 테이블을 사용합니다.,"Page sizes tend to vary from about 1 KB to 64 KB, depending on the CPU. For CPUs that support an address space larger than 4 GB, some CPUs use an inverted page table or a three-level page table.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
참조 지역성을 나타내지 않는 프로그램의 단점은 무엇인가요?,What is the disadvantage of a program that does not exhibit locality of reference?,메모리 계층에서 캐시 라인이나 페이지의 프로그램 작업 세트를 제대로 포함하기에는 메모리 수준이 충분하지 않습니다.,Insufficient memory at a given level in the memory hierarchy to properly contain the program working sets of cache lines or pages.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
운영 체제는 프로세스에 할당된 메모리의 가장 낮은 주소로 무엇을 하나요?,What does the operating system do with the lowest addresses in memory allocated for a process?,운영 체제는 가장 낮은 메모리 주소를 예약합니다. 일반적으로 애플리케이션은 메모리 내 가장 낮은 주소의 데이터에 액세스하거나 명령어를 실행할 수 없습니다. OS가 이 공간을 예약하는 한 가지 이유는 NULL 포인터 참조를 감지하는 데 도움이 되기 때문입니다.,"The operating system reserves the lowest memory addresses. Generally, your application cannot access data (or execute instructions) at the lowest addresses in memory. One reason the OS reserves this space is to help detect NULL pointer references.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
바인딩이란 무엇인가요?,What is binding?,바인딩은 속성을 객체와 연관시키는 과정입니다.,Binding is the process of associating an attribute with an object.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정적인 물체란 무엇인가요?,What are static objects?,"정적 객체는 애플리케이션 실행 전에 속성이 제한된 객체입니다. 상수는 정적 객체의 좋은 예이며, 애플리케이션 실행 중에 동일한 값이 제한됩니다.",Static objects are those that have an attribute bound to them prior to the execution of the application. Constants are good examples of static objects; they have the same value bound to them throughout the execution of the application.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정적 물체의 수명은 무엇인가요?,What is the lifetime of a static object?,The lifetime of a static object extends from the point at which the program first begins execution to the point when the application terminates.,The lifetime of a static object extends from the point at which the program first begins execution to the point when the application terminates.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
식별자의 범위는 무엇인가요?,What is the scope of an identifier?,식별자의 범위는 프로그램에서 식별자의 이름이 객체에 바인딩된 부분입니다. 이름은 컴파일 중에만 존재하기 때문에 컴파일된 언어에서는 범위가 확실히 정적 속성입니다. (인터프리터가 프로그램 실행 중에 식별자 이름을 유지하는 해석 언어에서는 범위가 비정적 속성일 수 있습니다.),"The scope of an identifier is that section of the program where the identifier's name is bound to the object. As names exist only during compilation, scope is definitely a static attribute in compiled languages. (In interpretive languages, where the interpreter maintains the identifier names during program execution, scope can be a non-static attribute.)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
실행 파일에서 무엇을 찾을 수 있나요?,What do you find in an executable file?,"대부분의 실행 파일에서는 코드, 읽기 전용 데이터, 상수 데이터 섹션을 결합한 단일 섹션을 찾을 수 있습니다.","In most executable files, you'll find a single section that combines the code, read-only data, and constant data sections.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
BSS 섹션이란 무엇인가요?,What is the BSS section?,"BSS 섹션은 컴파일러가 일반적으로 명시적인 값이 연관되지 않은 정적 객체를 배치하는 곳입니다. BSS는 심볼로 시작하는 블록을 의미하며, 이는 초기화되지 않은 정적 배열에 저장 공간을 할당하는 데 사용되는 의사-옵코드를 설명하는 오래된 어셈블리 언어 용어입니다. Windows와 Linux와 같은 최신 운영 체제에서는 OS가 초기화되지 않은 모든 변수를 BSS 섹션에 넣을 수 있으며, 이 섹션에는 OS에 몇 바이트를 따로 설정해야 하는지 알려주는 정보만 포함되어 있습니다.","The BSS section is where compilers typically put static objects that don't have an explicit value associated with them. BSS stands for block started by a symbol, which is an old assembly language term describing a pseudo-opcode one would use to allocate storage for an uninitialized static array. In modern OSes like Windows and Linux, the OS allows the compiler/linker to put all uninitialized variables into a BSS section that simply contains information that tells the OS how many bytes to set aside for the section.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스택이란 무엇인가요?,What it the stack?,"스택은 프로시저 호출과 호출 루틴 복귀 등에 반응하여 확장 및 축소되는 데이터 구조입니다. 실행 시 시스템은 메모리의 스택 섹션에 모든 자동 변수(비정적 로컬 변수), 서브루틴 매개변수, 임시 값 및 기타 객체를 특수 데이터 구조에서 활성화 레코드라고 부릅니다(시스템이 서브루틴이 처음 실행을 시작할 때 활성화 레코드를 생성하고 서브루틴이 호출자에게 돌아갈 때 활성화 레코드를 할당 해제하기 때문에 적절하게 명명됨).","The stack is a data structure that expands and contracts in response to procedure invocations and the return to calling routines, among other things. At run time, the system places all automatic variables (non-static local variables), subroutine parameters, temporary values, and other objects in the stack section of memory in a special data structure we call the activation record (which is aptly named because the system creates an activation record when a subroutine first begins execution, and it deallocates the activation record when the subroutine returns to its caller).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
하드웨어 스택과 소프트웨어 스택의 차이점은 무엇인가요?,What is the different between a hardware stack and a software stack?,"CPU가 명시적인 스택-포인트 레지스터(ESP)를 제공하는 경우, CPU가 하드웨어 스택을 지원한다고 말하고, 범용 레지스터만 사용할 수 있다면 CPU가 소프트웨어로 구현된 스택을 사용한다고 말합니다.","If a CPU provides an explicit stack-pointer register (ESP), we say that the CPU supports a hardware stack; if only a general-purpose register is available, then we say that the CPU uses a software-implemented stack.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
익명 변수란 무엇인가요?,What are anonymous variables?,"우리는 보통 힙 메모리의 객체를 익명 변수라고 부르는데, 이는 객체를 이름이 아닌 포인터를 통해 메모리 주소로 부르기 때문입니다.",We'll usually refer to objects in heap memory as anonymous variables because we refer to them by their memory address (via pointers) rather than by a name.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
간단한 힙 관리자 구현이란 무엇인가요?,What is a simple heap manager implementation?,"쓰레기 수거를 지원하는 힙 관리자를 쉽게 구현할 수 있습니다. 이 간단한 시스템은 (연결된) 무료 메모리 블록 목록을 유지합니다. 목록의 각 무료 메모리 블록은 두 개의 이중 단어 값을 필요로 합니다: 하나는 무료 블록의 크기를 지정하고, 다른 하나는 목록의 다음 무료 블록 링크(즉, 포인터)를 포함합니다","Easy implementation of a heap manager that supports garbage collection. This simple system maintains a (linked) list of free memory blocks. Each free memory block in the list will require two double-word values: one double-word value specifies the size of the free block, and the other double word contains a link to the next free block in the list (that is, a pointer)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
퍼스트 핏과 베스트 핏이란 무엇인가요?,What are first-fit and best-fit?,하지만 퍼스트 핏 알고리즘은 베스트 핏 알고리즘에 비해 몇 가지 장점이 있습니다. 가장 확실한 장점은 퍼스트 핏 알고리즘이 일반적으로 더 빠르다는 것입니다. 베스트 핏 알고리즘은 할당 요청을 충족할 만큼 충분히 큰 블록을 찾기 위해 무료 블록 목록의 모든 블록을 스캔해야 합니다,"The first-fit algorithm does have a couple of advantages over the best-fit algorithm, though. The most obvious advantage is that the first-fit algorithm is usually faster. The best-fit algorithm has to scan through every block in the free block list in order to find the smallest block large enough to satisfy the allocation request",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
힙 관리에서 퍼스트 핏의 장점은 무엇인가요?,What is an advantage of first-fit in heap management?,"첫 번째 맞춤 알고리즘의 또 다른 장점은 외부 단편화라는 퇴화된 상태로 인해 덜 고통받는 경향이 있다는 점입니다. 단편화는 긴 할당 및 할당 해제 요청의 연속 후에 발생합니다. 힙 관리자가 메모리 할당 요청을 충족하면 일반적으로 두 개의 메모리 블록을 생성합니다. 하나는 요청을 위한 사용 중인 블록이고, 하나는 요청이 완료된 후 원래 블록에 남은 바이트를 포함하는 무료 블록입니다(힙 관리자가 정확한 적합성을 찾지 못했다고 가정). 한동안 작동한 후, 가장 적합한 알고리즘은 평균 메모리 요청을 충족하기에는 너무 작고 남은 메모리 블록을 많이 생성할 수 있습니다(최적 적합 알고리즘도 그 동작의 결과로 가장 작은 잔여 블록을 생성하기 때문입니다).","Another advantage to the first-fit algorithm is that it tends to suffer less from a degenerate condition known as external fragmentation. Fragmentation occurs after a long sequence of allocation and deallocation requests. Remember, when the heap manager satisfies a memory allocation request, it usually creates two blocks of memory — one in-use block for the request and one free block that contains the remaining bytes in the original block after the request is filled (assuming the heap manager did not find an exact fit). After operating for a while, the best-fit algorithm may wind up producing lots of smaller, leftover blocks of memory that are too small to satisfy an average memory request (because the best-fit algorithm also produces the smallest leftover blocks as a result of its behavior).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
힙 메모리 할당은 속도에 어떻게 최적화되나요?,How does heap memory allocation optimize for speed?,"애플리케이션이 메모리 요청을 할 때마다 운영 체제에 전화를 걸면, 애플리케이션이 여러 메모리 할당 및 할당 해제 호출을 할 경우 성능이 저하될 가능성이 높습니다. OS API 호출은 일반적으로 CPU에서 커널 모드와 사용자 모드 간의 전환을 포함하기 때문에 매우 느립니다 (빠르지 않습니다).

첫 번째 메모리 할당 시 malloc 루틴은 운영 체제에서 대용량 메모리 블록을 요청하고, 애플리케이션의 malloc 및 무료 루틴은 이 메모리 블록을 직접 관리합니다.","If an application calls the operating system for every memory request it makes, the performance of the application will probably suffer if the application makes several memory allocation and deallocation calls. OS API calls are very slow, because they generally involve switching between kernel mode and user mode on the CPU (which is not fast).

On the very first memory allocation, the malloc routine will request a large block of memory from the operating system, and then the application's malloc and free routines will manage this block of memory themselves.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
할당 세분성이란 무엇인가요?,What is allocation granularity?,"대부분의 힙 관리자는 1바이트만큼 작은 블록으로 스토리지를 할당할 수 있지만, 대부분의 메모리 관리자는 실제로 1바이트보다 큰 최소 바이트 수를 할당합니다. 이 최소 금액은 메모리 관리자가 지원하는 할당 세분화입니다.","Although most heap managers will allow you to allocate storage in blocks as small as one byte, most memory managers will actually allocate some minimum number of bytes greater than one. This minimum amount is the allocation granularity the memory manager supports.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
일반적인 할당 정렬은 어떻게 되나요?,What is the usual allocation alignment?,"성능상의 이유로 많은 힙 관리자들이 일반적인 캐시 라인 경계(보통 16바이트, 32바이트 또는 64바이트)에서 각 할당을 시작합니다.","For performance reasons, many heap managers begin each allocation on a typical cache-line boundary, usually 16, 32, or 64 bytes.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
내부 분열을 어떻게 어느 정도 피할 수 있을까요?,How is internal fragmentation somewhat avoided?,"대부분의 메모리 관리자(일반적으로 16바이트 이하)에게는 세분화 크기가 상당히 작기 때문에 수천, 수천 번의 메모리 할당 후 내부 조각화로 인해 수십 킬로바이트 정도만 손실됩니다.","The granularity size is quite small for most memory managers (typically 16 bytes or fewer), so after thousands and thousands of memory allocations you'll only lose a couple dozen or so kilobytes to internal fragmentation.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
많은 작은 물체 더미에 할당할 때 어떤 문제가 있나요?,What is a problem with allocation on the heap of many small objects?,작은 객체를 많이 할당하면 내부 조각화 및 제어 정보(각 힙 블록에 저장된 메타 정보)에 의해 소비되는 메모리가 힙 영역의 상당 부분을 차지할 수 있습니다.,"If you allocate lots of small objects, the memory consumed by internal fragmentation and control information (meta information stored with each heap block) may represent a significant portion of your heap area.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
I/O 작업은 메모리 읽기 및 쓰기 작업과 어떻게 유사하나요?,How are I/O operations similar to memory read and write operations?,"I/O 작업은 메모리 읽기 및 쓰기 작업과 매우 유사하게 작동하지만, 일반적으로 I/O 작업과 관련된 대기 상태가 더 많습니다.","I/O operations behave much like memory read and write operations, except that there are usually more wait states associated with I/O operations.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
출력 포트는 일반적으로 외부로 전송할 데이터를 보관하는 데 무엇을 사용하나요?,What does an output port typically use to hold data to be sent to the outside world?,출력 포트는 일반적으로 래치 장치를 사용하여 외부로 전송할 데이터를 보관합니다.,An output port typically uses a latch device to hold data to be sent to the outside world.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
출력 포트의 읽기 또는 쓰기 기능은 무엇인가요?,What are the read or write abilities of an output port?,출력 포트는 쓰기 전용 또는 읽기/쓰기일 수 있습니다.,Output ports can be write-only or read/write.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
래치가 작동하려면 무엇이 활성화되어야 하나요?,What must be active for a latch to operate?,래치가 작동하려면 주소 디코딩 라인(En)과 쓰기 제어 라인(W)이 모두 활성화되어 있어야 합니다.,Both the address decode line (En) and the write control line (W) must be active for the latch to operate.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CPU는 읽기/쓰기 포트에서 무엇을 읽나요?,What does the CPU read from a read/write port?,CPU는 읽기/쓰기 포트에서 데이터를 읽을 때마다 마지막으로 포트에 기록된 데이터를 읽어 프로그래머가 해당 값을 검색할 수 있도록 합니다.,"Whenever the CPU reads data from a read/write port, it reads the data that was last written to the port allowing a programmer to retrieve that value.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
듀얼 I/O 포트란 무엇인가요?,What is a dual I/O port?,"듀얼 I/O 포트도 읽기/쓰기 포트이지만, 듀얼 I/O 포트를 읽을 때는 포트 주소의 출력 측에 마지막으로 작성된 데이터가 아닌 외부 입력 장치에서 데이터를 읽습니다.","A dual I/O port is also a read/write port, but when you read a dual I/O port, you read data from an external input device rather than the last data written to the output side of the port's address.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
듀얼 I/O 포트는 무엇으로 구성되어 있나요?,What is a dual I/O port composed of?,듀얼 I/O 포트는 실제로 동일한 포트 주소를 공유하는 읽기 전용 포트와 쓰기 전용 포트 두 개를 사용하여 생성됩니다.,Note that a dual I/O port is actually created using two ports — a read-only port and a write-only port — that share the same port address.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
양방향 포트란 무엇인가요?,What is a bidirectional port?,양방향 포트를 사용하면 CPU가 외부 장치에 데이터를 읽고 쓸 수 있습니다. 제대로 작동하려면 양방향 포트가 CPU의 읽기/쓰기 요청에 따라 장치가 데이터 전송 방향을 변경할 수 있도록 읽기 및 쓰기 활성화와 같은 다양한 제어 라인을 주변 장치에 전달해야 합니다. 실제로 양방향 포트는 양방향 래치 또는 버퍼를 통해 CPU 버스를 확장한 것입니다.,"A bidirectional port allows the CPU to both read and write data to an external device. To function properly, a bidirectional port must pass various control lines, such as read and write enable, to the peripheral device so that the device can change the direction of data transfer based on the CPU's read/write request. In effect, a bidirectional port is an extension of the CPU's bus through a bidirectional latch or buffer.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메모리 매핑 입출력이란 무엇인가요?,What is memory-mapped I/O?,메모리 매핑 I/O는 CPU의 메모리 주소 공간 내에서 주변 장치와 통신하기 위해 일반적인 위치를 사용합니다.,Memory-mapped I/O uses ordinary locations within the CPU's memory address space to communicate with peripheral devices.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
I/O 매핑 입출력이란 무엇인가요?,What is I/O-mapped input/output?,"I/O 매핑 입출력은 메모리와 별도의 주소 공간을 사용하며, 특수 기계 명령어를 사용하여 해당 특수 I/O 주소 공간과 외부 세계 간에 데이터를 전송합니다.","I/O-mapped input/output uses an address space separate from memory, and it uses special machine instructions to transfer data between that special I/O address space and the outside world.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DMA란 무엇인가요?,What is DMA?,DMA는 주변 장치가 CPU 개입 없이 메모리에 있는 데이터를 읽고 쓰는 특수한 형태의 메모리 매핑 I/O입니다,DMA is a special form of memory-mapped I/O where the peripheral device reads and writes data located in memory without CPU intervention,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메모리 매핑 주변 장치는 어떻게 작동하나요?,How does a memory-mapped peripheral device work?,"메모리 매핑 주변 장치는 일반 메모리와 마찬가지로 CPU의 주소와 데이터 라인에 연결되어 있으므로, CPU가 주변 장치와 연결된 주소에 글을 쓰거나 읽을 때마다 CPU는 장치와 데이터를 전송합니다.","A memory-mapped peripheral device is connected to the CPU's address and data lines exactly like regular memory, so whenever the CPU writes to or reads from the address associated with the peripheral device, the CPU transfers data to or from the device.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
일부 비디오 카드는 메모리를 어떻게 처리하나요?,How do some video cards handle their memory?,"일부 비디오 카드에는 메모리 주소 공간에 매핑되는 32MB의 온보드 메모리가 있으며, 이는 카드가 소비하는 32MB 주소 범위가 시스템에서 일반 RAM 메모리로 사용할 수 없음을 의미합니다.",Some video cards have 32 MB of on-board memory that they map into the memory address space and this means that the 32 MB address range consumed by the card is not available to the system for use as regular RAM memory.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메모리 매핑된 I/O 포트의 CPU 캐시 값이 있나요?,Does the CPU cache values for memory-mapped I/O ports?,아니요. CPU는 메모리 매핑된 I/O 포트를 위한 값을 캐시할 수 없습니다.,No. The CPU cannot cache values intended for memory-mapped I/O ports.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
프로그래머는 어떻게 I/O 주소 공간에 접근할 수 있나요?,How can a programmer get access to I/O address space?,"거의 모든 고급 언어가 메모리에 접근할 수 있는 기능을 제공하지만, 대부분은 I/O 공간에 대한 접근을 허용하지 않기 때문에 PCI 버스가 I/O 주소 공간을 메모리 주소 공간에 다시 매핑하면 이러한 고급 언어에 대한 I/O 접근이 가능합니다.","As almost all high-level languages provide the ability to access memory, but most do not allow access to the I/O space, having the PCI bus remap the I/O address space into the memory address space provides I/O access to those high-level languages.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
직접 메모리 액세스란 무엇이며 적시 처리에 대한 장점은 무엇인가요?,What is direct memory access and its advantage in timely processing?,매우 빠른 I/O 장치의 경우 CPU가 너무 느려서 한 번에 한 바이트(또는 한 단어 또는 두 단어)씩 데이터를 처리할 수 없을 수 있습니다. 이러한 장치는 일반적으로 CPU 버스에 인터페이스가 있어 CPU를 매개체로 사용하지 않고 주변 장치가 직접 메모리에 접근하기 때문에 직접 메모리를 읽고 쓸 수 있습니다.,"For very high-speed I/O devices the CPU may be too slow to process this data one byte (or one word or double word) at a time. Such devices generally have an interface to the CPU's bus so they can directly read and write memory, which is known as direct memory access because the peripheral device accesses memory directly, without using the CPU as an intermediary.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
중속 장치란 무엇인가요?,What is a medium-speed device?,CPU와 거의 동일한 속도 또는 최대 두 자릿수 느린 속도로 데이터를 전송하는 장치.,"Devices that transfer data at approximately the same rate as, or up to two orders of magnitude slower than, the CPU.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
고속 장치란 무엇인가요?,What are high-speed devices?,CPU보다 데이터를 더 빨리 전송하는 장치는 프로그래밍된 입출력을 사용하여 처리할 수 있습니다. 고속 장치는 프로그래밍된 입출력 속도가 너무 느리기 때문에 DMA를 사용해야 합니다.,Devices that transfer data faster than the CPU is capable of handling using programmed I/O. High-speed devices must use DMA because programmed I/O is too slow.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
중속 및 저속 장치는 어떤 입출력 메커니즘을 사용하나요?,What I/O mechanisms do medium and low-speed devices use?,"중속 및 저속 장치는 데이터 전송을 위해 세 가지 I/O 메커니즘 중 하나를 사용할 수 있습니다(단, 저속 장치는 추가 하드웨어 비용 때문에 DMA를 거의 사용하지 않습니다).",Medium- and low-speed devices may use any of the three I/O mechanisms for data transfer (though low-speed devices rarely use DMA because of the cost of the extra hardware involved).,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
I/O 장치는 인터럽트 컨트롤러와 어떻게 통신하나요?,How do I/O devices communicate with the interrupt controller?,대부분의 주변 버스는 I/O 장치가 주변 장치인 시스템의 인터럽트 컨트롤러와 직접 통신할 수 있도록 하는 공통 인터럽트 제어 신호 세트를 제공합니다.,"Most peripheral buses provide a common set of interrupt control signals that let I/O devices communicate directly with the system's interrupt controller, which is also a peripheral device.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CPU가 PCI 버스의 주변 장치에 액세스하려면 어떻게 해야 하나요?,What must a CPU do if it wishes to access a peripheral on the PCI bus?,CPU가 PCI 버스의 주변 장치에 액세스하고자 할 때마다 버스 사용 권한을 위해 다른 주변 장치와 협상해야 합니다. 이 협상은 PCI 컨트롤러가 CPU에게 버스에 대한 액세스 권한을 부여하기까지 여러 클럭 사이클이 소요될 수 있습니다.,"Whenever the CPU wishes to access a peripheral on the PCI bus, it must negotiate with other peripheral devices for the right to use the bus. This negotiation can take several clock cycles before the PCI controller grants the CPU access to the bus.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
CPU가 인터럽트를 받을 때 무엇을 부르나요?,What is called when the CPU receives an interrupt?,인터럽트 서비스 루틴(ISR),interrupt service routine (ISR),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
사용자 애플리케이션에서 I/O 포트에 액세스하려면 무엇을 사용할 수 있나요?,What can be used to make I/O ports accessible from user applications?,Linux ioperm 시스템 호출을 사용하여 사용자 애플리케이션에서 특정 I/O 포트에 액세스할 수 있도록 할 수 있습니다.,It is possible to use the Linux ioperm system call to make certain I/O ports accessible from user applications.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
디스크에 전체 블록을 쓸 때 OS는 읽기를 어떻게 저장하나요?,How does the OS save reads when writing full blocks to disk?,"블록 크기가 4,096바이트인데도 블록에 2,000바이트를 쓰고 그 블록 밖의 파일에서 다른 위치를 찾는 경우, OS는 실제로 디스크에서 전체 4,096바이트 블록을 읽고 2000바이트 안에 병합한 다음 최종적으로 전체 4,096바이트를 디스크에 다시 써야 합니다. 이는 OS가 전체 블록을 읽고 써야 하기 때문에 발생하며, 디스크와 메모리 간에 부분 블록을 전송할 수 없습니다. 이는 전체 4,096바이트를 쓰는 쓰기 작업과 대조적으로, 이 경우 OS는 디스크에서 데이터를 먼저 읽을 필요가 없으며 블록만 쓰기만 하면 됩니다.","If your block size is 4,096 bytes, but you just write 2,000 bytes to some block and then seek to some other position in the file outside that block, the OS will actually have to read the entire 4,096-byte block from the disk, merge in the 2000 bytes, and then finally write the entire 4,096 bytes back to the disk. This happens because the OS must read and write entire blocks; it cannot transfer partial blocks between the disk and memory. Contrast this with a write operation that writes a full 4,096 bytes — in this case, the OS wouldn't have to read the data from the disk first; it would only have to write the block.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메모리 매핑 파일이란 무엇인가요?,What are memory-mapped files?,메모리 매핑 파일은 OS의 가상 메모리 기능을 사용하여 애플리케이션 공간의 메모리 주소를 디스크의 블록에 직접 매핑합니다. 최신 OS는 고도로 최적화된 가상 메모리 하위 시스템을 가지고 있기 때문에 가상 메모리 하위 시스템 위에 파일 I/O를 올려놓으면 매우 효율적인 파일 액세스가 가능합니다.,"Memory-mapped files use the OS's virtual memory capabilities to map memory addresses in the application space directly to blocks on the disk. Because modern OSes have highly optimized virtual memory subsystems, piggy-backing file I/O on top of the virtual memory subsystem can produce very efficient file access.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
메모리 매핑 파일의 단점은 무엇인가요?,What is a drawback of memory-mapped files?,"거의 모든 운영 체제는 메모리 매핑 파일 접근 방식을 다르게 수행하며, 메모리 매핑 파일 I/O 코드가 운영 체제 간에 이식될 가능성은 거의 없습니다.","Almost every OS does memory-mapped file access differently, and there is little chance that memory-mapped file I/O code will be portable between OSes.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
LSD 래딕스는 어떤 종류인가요?,What is LSD radix sort?,최하위 숫자 첫 번째 반지름 정렬. 꼭 숫자일 필요는 없고 알파벳의 기호일 뿐입니다. 오른쪽에서 왼쪽으로 안정적으로 정렬됩니다.,"Least Significant Digit first radix sort. It doesn't have to be a digit, just a symbol in an alphabet. Sorts stably from right to left.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
MSD 래딕스는 어떤 종류인가요?,What is MSD radix sort?,"가장 중요한 숫자 첫 번째 반지름 정렬. 꼭 숫자일 필요는 없으며 알파벳의 기호일 뿐입니다. 왼쪽에서 오른쪽으로 안정적으로 정렬되며, 블록의 기호가 서로 같을 때 다시 반복됩니다.","Most Significant Digit first radix sort. It doesn't have to be a digit, just a symbol in an alphabet. Sorts stably from left to right, recursing when the symbols in a block equal each other.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
트라이를 사용하여 패턴을 저장한 다음 문자열에 대해 테스트하고 일치하는 항목을 찾는 데 걸리는 time complexity는 얼마인가요?,"What is the time complexity of using a trie to store patterns, then testing that trie against a string, looking for matches?",O(|끈| * |가장 긴 패턴의 렌|),O(|string| * |len of longest pattern|),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
접미사 트라이를 생성하는 데 걸리는 time complexity는 얼마인가요?,What is the time complexity for generating a suffix trie?,O(|텍스트|),O(|text|),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
접미사 배열을 생성하기 위해 접미사 트라이로 무엇을 할 수 있나요?,What can you do with a suffix trie to generate a suffix array?,접미사 목록을 얻기 위해 DFS를 시도합니다.,DFS the trie to get a list of suffixes.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
선형 시간에 접미사 배열을 생성하는 알고리즘은 무엇인가요?,What is the algorithm called that generates a suffix array in linear time?,맨버마이어스,Manber-Myers,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
MSD 래딕스 유형의 두 가지 단점은 무엇인가요?,What are 2 disadvantages of MSD radix sort?,"- 캐시 비효율
- 내부 루프에서 많은 작업","- cache inefficient
- lot of work in an inner loop",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
MSD radix 정렬은 어떤 유형의 입력에 가장 적합하나요?,What type of input does MSD radix sort do best on?,"정렬할 데이터가 무작위로 보일 때

데이터가 매우 유사할 때, 선형 시간 작업에 도달할 수 있으며, 이는 MSD의 속도가 느립니다","when the data to be sorted seems random

when the data is very similar, it can come to linear time work, which is slow for MSD",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
KMP의 실행 시간은 어떻게 되나요?,What is the runtime of KMP?,O(|P| + |T|),O(|P| + |T|),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
트라이는 어떤 작업에 효율적인가요?,What operations is a trie efficient on?,"- 가장 긴 접두사
- 처음에 와일드 카드
- 와일드 카드 끝","- longest prefix
- wild card at beginning
- wild card at end",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
트리 노드를 만들 때 아이들의 일반적인 구현 방식은 무엇인가요?,"When making a trie node, what is the typical implementation of the children?","크기 R(라딕스 또는 알파벳 크기)의 배열로, 계속되는 경로에 포인터가 있습니다. 계속되지 않는 경로는 해당 경로의 배열 인덱스에 널(null)이 저장되어 있습니다.",An array of size R (the radix or alphabet size) with a pointer to continuing paths. Paths that do not continue have null stored in the array indexes for those paths.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"문자열 길이가 N이고 패턴 길이가 M인 일치 항목을 검색할 때, 끝에서 너무 짧은 일치 항목을 찾지 않으려면 어디에서 멈춰야 할까요?","When searching for a match in string with length N and pattern length M, where should we stop to ensure we don't look for matches at the end that would be too short?",i <= n - m,i <= n - m,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
KMP의 전처리 단계는 무엇을 하나요?,What does the preprocessing step of KMP do?,검색할 패턴의 DFA(결정론적 유한 오토마톤)를 구축합니다.,Builds a DFA (deterministic finite automaton) of the pattern to be searched.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
KMP가 전처리 단계에서 생성한 DFA의 크기는 얼마인가요?,What is the size needed for the DFA created by KMP during its preprocessing step?,"O(R * M)
- r은 반지름입니다
- m은 패턴의 길이입니다","O(R * M)
- r is the radix
- m is the length of the pattern",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
보이어무어의 전처리 단계 실행 시간은 어떻게 되나요?,What is the runtime of the preprocessing step for Boyer-Moore?,"O(|P|)

- P는 패턴입니다","O(|P|)

- P is the pattern",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
보이어무어의 예상 실행 시간은 언제인가요?,What is the expected runtime of Boyer-Moore?,"O(n/m)

- n은 텍스트의 길이입니다
- m은 패턴의 길이입니다","O(n/m)

- n is the length of the text
- m is the length of the pattern",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
라빈-카프의 효율성을 가능하게 하는 수학적 방법은 무엇인가요?,What is the mathematical method called that allows Rabin-Karp to be efficient?,호너 방법,Horner's method,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
클린의 정리는 무엇인가요?,What is Kleene's theorem?,"FA는 모든 정규 언어(정규 표현)를 받아들이며, 반대로 FA가 받아들이는 모든 언어는 정규 언어라고 명시하고 있습니다.",It states that any regular language (regular expression) is accepted by an FA and conversely that any language accepted by an FA is regular.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DFA와 NFA의 차이점은 무엇인가요?,What is the difference between a DFA and an NFA?,"DFA는 문자당 하나의 해당 변환만 가질 수 있습니다.
NFA에는 여러 가지 적용 가능한 전환이 있을 수 있습니다.","DFA can have only one applicable transition per character.
NFA can have several applicable transitions.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
탐욕스러운 전략의 행동은 무엇인가요?,What is the behavior of a greedy strategy?,"탐욕 전략은 보통 하향식 순서로 진행되며, 하나의 탐욕스러운 선택을 차례로 하고 주어진 문제 인스턴스를 더 작은 문제 인스턴스로 줄입니다.","A greedy strategy usually progresses in a top-down order, making one greedy choice after another and reducing each given problem instance to a smaller one.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
잠재적인 동적 프로그래밍 솔루션을 사용하는 인터뷰 문제의 두 가지 속성은 무엇인가요?,What are 2 properties of an interview problem with a potential dynamic programming solution?,"면접 문제가 최적의 하위 구조와 중복되는 하위 문제를 가지고 있다면, 동적 프로그래밍을 통해 해결할 수 있을 것입니다.","If an interview problem has optimal substructure and overlapping subproblems, it might be solved by dynamic programming.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
역추적이란 무엇인가요?,What is backtracking?,"백트래킹은 사용 가능한 모든 옵션 중에서 문제의 해결책을 체계적으로 검색하는 무차별 대입 접근 방식의 개선입니다. 각 단계에서 사용할 수 있는 옵션 세트가 있는 시나리오에 적합하며, 이 중 하나를 선택해야 합니다. 선택이 완료되면 다음 단계에 대한 새로운 옵션 세트가 생깁니다. 이 절차는 최종 상태에 도달할 때까지 계속 반복됩니다.","Backtracking is a refinement of the brute-force approach, which systematically searches for a solution to a problem among all available options. It is suitable for scenarios where there is a set of options available at each step, and we must choose one from these. After a choice is made, there is a new set of options for the next step. This procedure is repeated over and over until we reach a final state.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
역추적 알고리즘은 어떻게 작동하나요?,How does a backtracking algorithm behave?,백트래킹 알고리즘은 루트부터 깊이 우선순위까지 이 트리를 재귀적으로 탐색합니다. 허용되지 않는 상태에 해당하는 리프에 도달하면 가장 최근의 선택을 취소하고 다음 옵션을 시도하여 다른 리프 검색을 계속하도록 백트래킹합니다. 옵션이 부족하면 다시 취소하고 해당 노드에서 다른 옵션을 시도합니다. 옵션이 남아 있지 않은 루트에 도달하면 허용되는 상태를 찾을 수 없습니다.,"The backtracking algorithm traverses this tree recursively, from the root down and in depth-first order. When it reaches a leaf that corresponds to a non-acceptable state, it backtracks to continue the search for another leaf by revoking the most recent choice and tries out the next option. If it runs out of options, it revokes again and tries another choice at that node. If it ends up at the root with no options left, there are no acceptable states to be found.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬의 인코딩 및 디코딩 방법은 어떻게 작동하나요?,How do Python's encode and decode methods work?,유니코드 문자를 이진 데이터로 변환하려면 인코딩 방법을 사용해야 합니다. 이진 데이터를 유니코드 문자로 변환하려면 디코딩 방법을 사용해야 합니다.,"To convert Unicode characters to binary data, you must use the encode method. To convert binary data to Unicode characters, you must use the decode method.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬의 문자열을 10이 아닌 밑이 있는 정수로 어떻게 해석할 수 있나요?,How can you interpret a string in Python as an integer with a base other than 10?,"The integer constructor, int(), by default, the string must use base 10. If conversion from a different base is desired, that
base can be indicated as a second, optional, parameter. For example, the expression int(7f, 16) evaluates to the integer 127.","The integer constructor, int(), by default, the string must use base 10. If conversion from a different base is desired, that
base can be indicated as a second, optional, parameter. For example, the expression int(7f, 16) evaluates to the integer 127.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
패트리샤 트라이의 패트리샤는 무엇을 의미하나요?,What does Patricia in a Patricia trie stand for?,패트리샤: 영숫자로 코딩된 정보를 검색하는 실용적인 알고리즘,PATRICIA: practical algorithm to retrieve information coded in alphanumeric,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 시퀀스의 순서 관계는 무엇인가요?,What is the ordering relationship in a sequence in Python?,"리스트, 튜플, str 클래스는 파이썬의 시퀀스 유형으로, 순서가 중요한 값들의 모음을 나타냅니다.","The list, tuple, and str classes are sequence types in Python, representing a collection of values in which the order is significant.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬으로 목록을 복사하려면 어떻게 해야 하나요?,How can you copy a list in Python?,기존 목록 자체가 견딜 수 있기 때문에 구문 백업 = list(데이터)를 사용하여 원본과 동일한 내용을 참조하는 새로운 목록 인스턴스를 구성할 수 있습니다.,"Because an existing list is itself iterable, the syntax backup = list(data) can be used to construct a new list instance referencing the same contents as the original.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
1요소 튜플을 어떻게 표현할 수 있나요?,How can you represent a 1-element tuple?,"(17,)은 하나의 element 튜플입니다","(17,) is a one-element tuple",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬으로 긴 다중 줄 문자열 리터럴을 만들려면 어떻게 해야 하나요?,"How can you make long, multi-line string literal in Python?","Python은 문자열 리터럴을 시작하고 종료할 때 구분자 또는 """"""를 사용하는 것을 지원합니다.","Python supports using the delimiter or """""" to begin and end a string literal.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬 세트에는 어떤 종류의 객체를 추가할 수 있나요?,What types of objects can be added to a Python set?,파이썬 집합에는 해시 키로 사용되므로 불변 유형의 인스턴스만 추가할 수 있습니다.,"Only instances of immutable types can be added to a Python set, since they are used as hash keys.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 빈 집합을 어떻게 표현할 수 있나요?,How can you represent an empty set in Python?,생성자 구문 집합()은 빈 집합을 생성합니다.,The constructor syntax set() produces an empty set.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이미 다른 곳에 선언된 값으로 파이썬 사전을 초기화하려면 어떻게 해야 하나요?,How can you initialize a Python dictionary with values already declared elsewhere?,"생성자는 dict(pairs)에서와 같이 일련의 키-값 쌍을 매개변수로 받아들입니다:
쌍 = [('가', '아일랜드어'), ('데', '독일어')].","The constructor accepts a sequence of key-value pairs as a parameter, as in dict(pairs) with:
pairs = [('ga', 'Irish'), ('de', 'German')].",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
두 파이썬 객체가 같은 객체인지 어떻게 알 수 있나요?,How can you tell that two Python objects are the same object?,a와 b라는 표현은 식별자 a와 b가 동일한 객체에 대한 별칭일 때 정확히 True로 평가됩니다.,"The expression a is b evaluates to True, precisely when identifiers a and b are aliases for the same object.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 나눗셈 규칙은 무엇인가요?,What is the division rule in Python?,"파이썬은 q*d + r이 n이 되도록 보장합니다.
d = 분모
q = 몫
r = 나머지
n = 분자","Python guarantees that q*d + r will equal n.
d = denominator
q = quotient
r = remainder
n = numerator",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 집합 교차점을 어떻게 표현하나요?,How do you express a set intersection in Python?,s1과 s2의 교차점,s1 & s2 the intersection of s1 and s2,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 집합 합집합을 어떻게 나타내나요?,How do you represent a set union in Python?,s1 | s2 the union of s1 and s2,s1 | s2 the union of s1 and s2,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 s1에서는 요소 집합을 얻을 수 있지만 s2에서는 구할 수 없는 방법은 무엇인가요?,"In Python, how can you get the set of elements in s1 but not s2?",s1 - s2,s1 − s2,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 s1 또는 s2 중 정확히 하나의 원소 집합을 얻으려면 어떻게 해야 하나요?,"In Python, how can you get the set of elements in precisely one of s1 or s2?",s1 ˆ s2,s1 ˆ s2,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
두 사전에 동일한 키-값 쌍이 포함되어 있는지 어떻게 테스트할 수 있나요?,How can you test that two dictionaries contain the same set of key-value pairs?,사전은 두 사전에 동일한 키-값 쌍이 포함된 경우 d1 == d2로 동등성 개념을 지원합니다.,"Dictionaries support the notion of equivalence, with d1 == d2 if the two dictionaries contain the same set of key-value pairs.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 두 개의 요소가 더 있는 목록을 확장하려면 어떻게 해야 하나요? (새로 만들지 않고 원래 목록에 추가),"In Python, how can you extend a list with two more elements? (adding to the original list, not making a new one)","베타 += [4, 5]","beta += [4, 5]",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"파이썬에서 목록 베타를 새 목록 [1, 2, 3, 4, 5, 6, 7]에 재할당하려면 어떻게 해야 하나요? (원본에 추가하는 대신 새 개체 만들기)","In Python, how do you reassign a list beta to a new list [1, 2, 3, 4, 5, 6, 7]? (making a new object instead of adding to the original)","베타 = 베타 + [6, 7]","beta = beta + [6, 7]",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
1 <= x + y <= 10과 같은 표현은 계산을 어떻게 저장하나요?,How does an expression like 1 <= x + y <= 10 save computation?,"표현식 1 <= x + y <= 10>은 (1 <= x + y)와 (x + y <= 10)로 평가되지만, 중간값 x + y를 두 번 계산하지는 않습니다.","The expression 1 <= x + y <= 10 is evaluated as the compound (1 <= x + y) and (x + y <= 10), but without computing the intermediate value x + y twice.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬 함수를 호출하면 어떻게 되나요?,What happens when you call a Python function?,함수가 호출될 때마다 파이썬은 현재 호출과 관련된 정보를 저장하는 전용 활성화 레코드를 생성합니다. 이 활성화 레코드에는 현재 호출 내에 로컬 범위를 가진 모든 식별자를 관리하는 네임스페이스가 포함됩니다.,"Each time a function is called, Python creates a dedicated activation record that stores information relevant to the current call. This activation record includes what is known as a namespace to manage all identifiers that have local scope within the current call.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"파이썬은 어떻게 다형성, 메서드 오버로드를 지원하나요?","How does Python support polymorphism, method overloading?",파이썬은 기본 매개변수 값을 사용하여 함수가 둘 이상의 가능한 호출 서명을 지원할 수 있는 수단을 제공합니다. 이러한 함수는 다형성 함수라고 합니다.,Python provides means for functions to support more than one possible calling signature using default parameter values. Such a function is said to be polymorphic.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 기본 매개변수에 대한 규칙은 무엇인가요?,What is the rule for default parameters in Python?,"bar(a, b=15, c)와 같은 서명을 가진 함수를 정의하는 것은 불법이며, b는 기본값을 가지지만 이후의 c는 정의하지 않습니다. 만약 하나의 매개변수에 대해 기본 매개변수 값이 존재한다면, 이는 모든 추가 매개변수에 대해 존재해야 합니다.","It is illegal to define a function with a signature such as bar(a, b=15, c) with b having a default value, yet not the subsequent c; if a default parameter value is present for one parameter, it must be present for all further parameters.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
집합이나 사전에서 존재하지 않는 요소에 접근하려는 시도에서 제기되는 예외는 무엇인가요?,What kind of exception is raised in an attempt to access a nonexistent element from a set or dictionary?,키오류,KeyError,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
주어진 수열에 대해 유효한 인덱스가 아닌 정수 k로 데이터[k]와 같은 구문을 사용할 때 수열에 대해 어떤 예외가 발생하나요?,What kind of exception is raised on a sequence when syntax such as data[k] is used with an integer k that is not a valid index for the given sequence?,인덱스 오류,IndexError,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you test that a function parameter x is of type int or float?,How can you test that a function parameter x is of type int or float?,"그렇지 않으면 인스턴스(x, (int, float)):","if not isinstance(x, (int, float)):",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
언제 시도/제외를 사용해야 하나요?,When should you use try/except?,"예외 조항은 예외적인 경우가 상대적으로 가능성이 낮다고 믿을 만한 이유가 있거나, 예외를 피하기 위해 조건을 사전에 평가하는 데 엄청난 비용이 드는 경우에 가장 잘 사용됩니다.","The try-except clause is best used when there is reason to believe that the exceptional case is relatively unlikely, or when it is prohibitively expensive to proactively evaluate a condition to avoid the exception.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
여러 유형의 예외를 어떻게 잡을 수 있나요?,How can you catch an exception of more than one type?,"단, (ValueError, EOFEerror):","except (ValueError, EOFError):",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬 예외를 잡고 처리한 다음 예외를 다시 올릴 수 있는 방법은 무엇인가요?,"How can you catch a Python exception, handle it, and then re-raise the exception?","EOFerror를 제외하고: 
    print( 입력을 읽는 동안 예기치 않은 오류가 발생했습니다. ) 
    올리다","except EOFError: 
    print( There was an unexpected error reading input. ) 
    raise",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
수익률과 수익률을 함께 사용할 수 있나요?,Can you use return and yield together?,동일한 구현에서 수익률과 수익률 문을 결합하여 생성기가 실행을 종료하도록 하는 것은 불법입니다.,"It is illegal to combine yield and return statements in the same implementation, other than a zero-argument return statement to cause a generator to end its execution.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
괄호 없이 튜플을 정의할 수 있나요?,Can you define a tuple without parentheses?,"네:
data = 2, 4, 6, 8","Yes:
data = 2, 4, 6, 8",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
로컬 네임스페이스에서 변수 목록을 어떻게 얻을 수 있나요?,How can you get a list of variables in the local namespace?,dir() 및 vars()에 대한 호출은 실행되는 가장 로컬하게 둘러싸인 네임스페이스에 대해 보고합니다,Calls to dir() and vars() report on the most locally enclosing namespace in which they are executed,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
일등석 물건이란 무엇인가요?,What are first-class objects?,퍼스트 클래스 객체는 식별자에 할당되거나 매개변수로 전달되거나 함수에 의해 반환될 수 있는 유형의 인스턴스입니다.,"First-class objects are instances of a type that can be assigned to an identifier, passed as a parameter, or returned by a function.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬의 시스템 모듈은 무엇을 하나요?,What does Python's sys module do?,파이썬 인터프리터와의 추가적인 상호작용 수준을 제공합니다.,Provides additional level of interaction with the Python interpreter.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬의 OS 모듈은 무엇을 하나요?,What does Python's os module do?,운영 체제와의 상호 작용을 지원합니다.,Provides support for interactions with the operating system.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
시드 값을 사용하는 것의 의미는 무엇인가요?,What is the significance of using a seed value?,주어진 시드에 대해 생성된 숫자의 순서는 항상 동일합니다.,The sequence of numbers generated for a given seed will always be the same.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
물체란 무엇인가요?,What is an object?,수업의 예.,An instance of a class.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 비공개 데이터 멤버와 멤버 함수에 대한 관례는 무엇인가요?,What is the convention for non-public data members and member functions in Python?,"By convention, names of members of a class (both data members and member functions) that start with a single underscore character (e.g., _secret) are assumed to be nonpublic and should not be relied upon.","By convention, names of members of a class (both data members and member functions) that start with a single underscore character (e.g., _secret) are assumed to be nonpublic and should not be relied upon.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬은 어떤 두 가지 메서드를 구현하는 모든 클래스에 대해 자동 반복기 구현을 제공하나요?,Python provides an automatic iterator implementation for any class that implements what two methods?,__len__ 및 __getitem__,__len__ and __getitem__,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
범위()가 사용하는 평가 유형은 무엇인가요?,What is the type of evaluation that range() uses?,그것은 게으른 평가로 알려진 전략을 사용합니다.,It uses a strategy known as lazy evaluation.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
범위 내 원소 수에 대한 공식은 무엇인가요?,What is the formula for the number of elements in the range?,"max(0, (정지 - 시작 + 단계 - 1) // 단계)","max(0, (stop − start + step − 1) // step)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
컨스트럭터에서 슈퍼를 어떻게 부를 수 있나요?,How can you call super in a constructor?,"super().__init__(arg1, arg2)","super().__init__(arg1, arg2)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
템플릿 메서드 패턴은 무엇인가요?,What is the template method pattern?,"템플릿 메서드 패턴은 추상적인 기본 클래스가 다른 추상적인 동작에 대한 호출에 의존하는 구체적인 동작을 제공하는 경우입니다.

템플릿 메서드 패턴은 특정 단계를 재정의하여 특정 애플리케이션에 특화할 수 있는 일반적인 계산 메커니즘을 설명합니다. 사용자 지정을 허용하기 위해 기본 알고리즘은 프로세스의 지정된 단계에서 후크라고 하는 보조 함수를 호출합니다.","The template method pattern is when an abstract base class provides concrete behaviors that rely upon calls to other abstract behaviors.

The template method pattern describes a generic computation mechanism that can be specialized for a particular application by redefining certain steps. To allow customization, the primary algorithm calls auxiliary functions known as hooks at designated steps of the process.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 클래스 상수를 어떻게 정의할 수 있나요?,How can you define a class constant in Python?,"class PredatoryCreditCard(CreditCard): 
    OVERLIMIT FEE = 5","class PredatoryCreditCard(CreditCard): 
    OVERLIMIT FEE = 5",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
상속 계층에서 __slots__의 중요한 주의 사항은 무엇인가요?,What is an important caveat of __slots__ in an inheritance hierarchy?,"When inheritance is used, if the base class declares __slots__, a subclass must also declare __slots__ to avoid creation of instance dictionaries. The declaration in the subclass should only include names of supplemental methods that are newly introduced.","When inheritance is used, if the base class declares __slots__, a subclass must also declare __slots__ to avoid creation of instance dictionaries. The declaration in the subclass should only include names of supplemental methods that are newly introduced.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동적 디스패치란 무엇인가요?,What is dynamic dispatch?,Python은 동적 디스패치(또는 동적 바인딩)로 알려진 기능을 사용하여 실행 시 호출할 객체의 유형에 따라 함수의 구현을 결정합니다.,"Python uses what is known as dynamic dispatch (or dynamic binding) to determine, at run-time, which implementation of a function to call based upon the type of the object upon which it is invoked.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정적 디스패치란 무엇인가요?,What is static dispatching?,선언된 변수 유형에 따라 호출할 함수의 버전을 컴파일 타임으로 결정합니다.,"Making a compile-time decision as to which version of a function to call, based upon the declared type of a variable.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
합계(1 + 2 + 4 + 8 + · · · + 2^(n-1))의 합계는 얼마입니까?,What is the total of sum(1 + 2 + 4 + 8 + · · · + 2^(n−1)) ?,2^n - 1,2^n − 1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
빅오(상한선)의 정의는 무엇인가요?,What is the definition of Big-O (upper bound)?,"실수 상수 c > 0이고 정수 상수 n0 ≥ 1이 f(n) ≤ cg(n)인 경우, n ≥ n0에 대해 f(n)이 O(g(n))라고 합니다.","We say that f(n) is O(g(n)) if there is a real constant c > 0 and an integer constant n0 ≥ 1 such that f(n) ≤ cg(n), for n ≥ n0.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
영숫자(한 줄)만 사용하여 다른 문자열에서 문자 문자열을 얻으려면 어떻게 해야 하나요?,"How can you get a string of letters from another string, using only the alphanumeric (one-liner)?",letters = ''.join(c for c in document if c.isalpha()),letters = ''.join(c for c in document if c.isalpha()),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"파이썬에서 ""새""로부터 ['b', 'i', 'r', 'd']를 어떻게 얻을 수 있을까요?","In Python, how can you get ['b', 'i', 'r', 'd'] from ""bird""?",목록(새),list(bird),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인덱스 i를 오른쪽으로 회전시킨 길이 26의 목록에서 값을 얻으려면 어떻게 해야 하나요?,"How can you get a value in a list of length 26, with index i rotated r positions to the right?",(i + r) 모드 26,(i + r) mod 26,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
문자 c의 A에서 ASCII 거리를 어떻게 구할 수 있나요?,How can you get the ASCII distance from A of a character c?,j = ord(c) − ord('A'),j = ord(c) − ord('A'),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
어댑터 디자인 패턴을 설명하세요.,Describe the adapter design pattern.,어댑터 디자인 패턴은 기존 클래스를 효과적으로 수정하여 관련된 클래스나 인터페이스의 메서드와 일치하도록 하고자 하는 모든 컨텍스트에 적용됩니다.,"The adapter design pattern applies to any context where we effectively want to modify an existing class so that its methods match those of a related, but different, class or interface.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
시퀀스를 반전시키는 데 사용할 수 있는 데이터 구조는 무엇인가요?,What data structure can be used to reverse a sequence?,LIFO 프로토콜의 결과로 스택은 데이터 시퀀스를 되돌리는 일반적인 도구로 사용할 수 있습니다.,"As a consequence of the LIFO protocol, a stack can be used as a general tool to reverse a data sequence.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"원형 배열 큐를 사용할 때 요소를 디큐하고 앞 인덱스를 ""진전""하고자 할 때, 큐 f의 앞을 계산하기 위한 산술은 무엇인가요?","When using a circular array queue, when we dequeue an element and want to ""advance"" the front index, what is the arithmetic for computing the front of the queue f?",f = (f + 1) % N,f = (f + 1) % N,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
상각 한도의 단점은 무엇인가요?,What is the drawback of amortized bounds?,운영에 대한 상각 한도는 실시간 시스템에서 허용되지 않을 수 있습니다.,Amortized bounds for operations may be unacceptable in real-time systems.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
구성 패턴을 간단히 설명해 주시겠어요?,Describe briefly the composition pattern?,우리는 두 개 이상의 다른 객체로 구성된 단일 객체를 정의합니다.,We define a single object that is composed of two or more other objects.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
휴리스틱의 다른 이름은 무엇인가요?,What is another name for a heuristic?,경험 법칙.,A rule of thumb.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
배열에 대한 데이터 액세스의 이점은 무엇인가요?,What is a benefit of data accesses for arrays?,배열은 정수 인덱스를 기반으로 요소에 O(1) 시간 접근을 제공합니다.,Arrays provide O(1)-time access to an element based on an integer index.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
동등한 asymptotic 경계를 가진 연산은 일반적으로 ____ 기반 구조와 ____ 구조를 사용하여 상수 계수를 더 효율적으로 실행합니다.,Operations with equivalent asymptotic bounds typically run a constant factor more efficiently with an _____-based structure versus a _____ structure.,"배열
연결된","array
linked",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
______-기반 표현은 일반적으로 ______ 구조보다 메모리 사용량이 비례적으로 적습니다.,______-based representations typically use proportionally less memory than _______ structures.,"배열
연결된","array
linked",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
______-기반 구조는 운영에 최악의 경우 시간 제한을 제공합니다.,______-based structures provide worst-case time bounds for their operations.,링크,link,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
_______-기반 구조는 임의의 위치에서 O(1)-타임 삽입 및 삭제를 지원합니다.,_______-based structures support O(1)-time insertions and deletions at arbitrary positions.,링크,link,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
어떻게 v의 조상이 될 수 있나요?,How can u be an ancestor of v?,노드 u는 u = v 또는 u가 v의 부모의 조상인 경우 노드 v의 조상입니다.,A node u is an ancestor of a node v if u = v or u is an ancestor of the parent of v.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정렬된 트리는 무엇을 의미하나요?,What does an ordered tree mean?,각 노드의 자식들 사이에 의미 있는 선형 순서가 있는 경우 트리가 정렬됩니다.,A tree is ordered if there is a meaningful linear order among the children of each node.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
적절한 이진 트리란 무엇인가요?,What is a proper binary tree?,각 노드에 자식이 0개 또는 2개인 경우 이진 트리가 적절합니다.,A binary tree is proper if each node has either zero or two children.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
높이 d의 나무에는 몇 개의 노드가 있나요?,How many nodes are in a tree of height d?,"이진 트리에서 레벨 0에는 최대 하나의 노드(루트)가 있고, 레벨 1에는 최대 두 개의 노드(루트의 자식)가 있으며, 레벨 2에는 최대 네 개의 노드가 있습니다. 일반적으로 레벨 d에는 최대 2^d개의 노드가 있습니다.","In a binary tree, level 0 has at most one node (the root), level 1 has at most two nodes (the children of the root), level 2 has at most four nodes, and so on. In general, level d has at most 2^d nodes.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
트리 배열 표현의 단점은 무엇인가요?,What is a drawback of an array representation of trees?,트리에 대한 일부 업데이트 작업은 효율적으로 지원할 수 없습니다. 예를 들어 노드를 삭제하고 자식을 승격하는 데는 자식이 배열 내에서 위치를 이동하는 것뿐만 아니라 해당 자식의 모든 자손이기 때문에 O(n) 시간이 걸립니다.,"Some update operations for trees cannot be efficiently supported. For example, deleting a node and promoting its child takes O(n) time because it is not just the child that moves locations within the array, but all descendants of that child.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n개의 노드로 이루어진 이진 트리의 높이에 대한 경계는 무엇인가요?,What is the bounds on the height of a binary tree of n nodes?,"log(n + 1) - 1만큼 작습니다
n - 1만큼 큰","as small as log(n + 1) − 1
as large as n − 1",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
배열 표현이나 트리 표현에서 최소분을 추가하거나 제거하는 데 필요한 힙의 마지막 위치를 찾는 데 걸리는 time complexity는 얼마인가요?,"What are the time complexities of locating the last position of a heap, as required for add and remove min, in an array representation or tree representation?","힙의 마지막 위치를 찾는 것은 추가 및 제거 최소화에 필요한 경우, 배열 기반 표현의 경우 O(1) 시간 내에 수행할 수 있으며, 연결 트리 표현의 경우 O(log n) 시간 내에 수행할 수 있습니다.","Locating the last position of a heap, as required for add and remove min, can be performed in O(1) time for an array-based representation, or O(log n) time for a linked-tree representation.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
힙은 모든 레벨이 가득 찬 완전 이진 트리입니다. 힙의 높이는 얼마인가요?,A heap is a complete binary tree with every level being full. What is it's height?,h = log(n + 1) − 1,h = log(n + 1) − 1,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
힙을 사용하여 반복 가능한 값에서 k개의 최대값 목록을 생성하는 데 걸리는 time complexity는 얼마인가요?,"What is the time complexity to produce a list of the k largest values from an iterable, using a heap?","O(n + k log n)
n: 힙피
k: 액세스
log n: 접근당 비용","O(n + k log n)
n: heapify
k: accesses
log n: cost per access",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
엄격한 약한 질서란 무엇인가요?,What is a strict weak order?,그것은 키를 서로 동등하게 간주할 수 있게 해줍니다.,It allows for keys to be considered equal to each other.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파일을 읽고 파일에서 고유 단어를 얻는 방법은 무엇인가요?,How you can read a file and get the unique words from a file?,piece in open(filename).read ().lower ().split():,for piece in open(filename).read().lower().split():,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
좋은 해시를 만들기 위해 영어 단어인 문자열로 해시하기 좋은 숫자에는 어떤 것이 있나요?,"What are some good numbers to hash with character strings that are English words, to create a good hash?","33, 37, 39, 41","33, 37, 39, and 41",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 해시 코드를 계산하는 표준 메커니즘은 무엇인가요?,What is the standard mechanism for computing hash codes in Python?,객체 x의 해시 코드 역할을 하는 정수 값을 반환하는 서명 해시(x)가 포함된 내장 함수입니다.,A built-in function with signature hash(x) that returns an integer value that serves as the hash code for object x.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬에서 사용자 정의 클래스에 해시를 구현하려면 어떻게 해야 하나요?,How can you implement a hash for your user-defined class in Python?,"def __hash__(self):
    return hash( (self. red, self. green, self. blue) ) # hash combined tuple","def __hash__(self):
    return hash( (self. red, self. green, self. blue) ) # hash combined tuple",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
해시를 저장 공간에 맞추는 전체 해시 함수의 일부로 수행되는 두 번째 작업은 무엇인가요?,What is the second action performed as part of an overall hash function called that fits the hash into the storage space?,압축 함수,compression function,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
해시 테이블 크기에 맞는 N의 소수를 선택할 때 주의해야 할 점은 무엇인가요?,What is the caveat for choosing a prime for N for your hash table size?,소수가 되기 위해 N을 선택하는 것만으로는 항상 충분하지 않습니다. 왜냐하면 여러 다른 p에 대해 p*N + q 형태의 해시 코드 패턴이 반복된다면 충돌이 계속 발생하기 때문입니다.,"Choosing N to be a prime number is not always enough, for if there is a repeated pattern of hash codes of the form p*N + q for several different p's, then there will still be collisions.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
MAD란 무엇이며 그 공식은 무엇인가요?,What is MAD and what is its formula?,"곱셈 더하기 나누기
[(a*i + b) mod p] mod N","Multiply-Add-and-Divide
[(a*i + b) mod p] mod N",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
올바른 하중 계수를 생각할 때 경험 법칙은 무엇인가요?,What is the rule of thumb when coming up with the right load factor?,"해시 테이블의 로드 팩터라고 하는 비율 λ  = n/N은 작은 상수, 바람직하게는 1 이하로 제한되어야 합니다. λ가 O(1)인 한 해시 테이블의 핵심 연산은 O(1) 예상 시간 내에 실행됩니다.","The ratio λ = n/N, called the load factor of the hash table, should be bounded by a small constant, preferably below 1. As long as λ is O(1), the core operations on the hash table run in O(1) expected time.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
오픈 어드레싱은 무엇을 필요로 하나요?,What does open addressing require?,"오픈 어드레싱은 로드 팩터가 항상 최대 1이어야 하며, 항목들이 버킷 배열 자체의 셀에 직접 저장되어야 합니다.",Open addressing requires that the load factor is always at most 1 and that items are stored directly in the cells of the bucket array itself.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이차 탐사란 무엇인가요?,What is quadratic probing?,"빈 버킷을 찾을 때까지 i = 0,1,2, ...에 대해 버킷 A[(h(k) + f(i) mod N]을 반복적으로 시도하는 또 다른 오픈 어드레싱 전략입니다. 여기서 f(i) = i^2입니다.","Another open addressing strategy that iteratively tries the buckets A[(h(k) + f (i)) mod N], for i = 0,1,2, . . ., where f(i) = i^2, until finding an empty bucket.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이차 탐사는 어떤 문제를 겪나요?,What does quadratic probing suffer from?,"원래 해시 코드가 균일하게 분포되어 있다고 가정하더라도 채워진 배열 셀 집합이 여전히 비균일한 패턴을 갖는 자체 클러스터링, 즉 2차 클러스터링을 생성합니다.","It creates its own kind of clustering, called secondary clustering, where the set of filled array cells still has a non-uniform pattern, even if we assume that the original hash codes are distributed uniformly.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
이중 해싱 전략이란 무엇인가요?,What is the double hashing strategy?,"In this approach, we choose a secondary hash function, h', and if h maps some key k to a bucket A[h(k)] that is already occupied, then we iteratively try the buckets A[(h(k) + f(i)) mod N] next, for i = 1,2,3, . . where f(i) = i * h'(k).
In this scheme, the secondary hash function is not allowed to evaluate to zero; a common choice is h(k) = q−(k mod q), for some prime number q < N. Also, N should be a prime.","In this approach, we choose a secondary hash function, h', and if h maps some key k to a bucket A[h(k)] that is already occupied, then we iteratively try the buckets A[(h(k) + f(i)) mod N] next, for i = 1,2,3, . . where f(i) = i * h'(k).
In this scheme, the secondary hash function is not allowed to evaluate to zero; a common choice is h(k) = q−(k mod q), for some prime number q < N. Also, N should be a prime.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
별도의 체인을 사용하여 해싱할 때 최적의 하중 계수는 무엇인가요?,What is the optimal load factor for hashing using separate chaining?,λ < 0.9,λ < 0.9,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
선형 프로빙을 사용한 해싱의 최적 하중 계수는 무엇인가요?,What is the optimal load factor for hashing using linear probing?,λ < 0.5,λ < 0.5,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬의 해시 테이블 구현에 따른 부하 요인은 무엇인가요?,What is the load factor of Python's implementation of hash tables?,λ < 2/3,λ < 2/3,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
해시 테이블의 정렬된 테이블 구현은 무엇에 가장 적합하나요?,What is a sorted table implementation of a hash table best suited for?,정렬된 표는 주로 검색은 많지만 업데이트는 상대적으로 적은 상황에서 사용됩니다.,Sorted tables are primarily used in situations where we expect many searches but relatively few updates.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스킵 리스트의 O(log n) 시간 경계는 정렬된 리스트에 대한 어떤 연산으로 확장되나요?,The O(log n) time bounds for skip lists extend to what operations over a sorted list?,"스킵 리스트는 이진 검색 알고리즘이 달성하는 것과 동일한 로그 시간 제한을 가지지만, 항목을 삽입하거나 삭제할 때 메서드를 업데이트하는 데까지 성능을 확장합니다. 그럼에도 불구하고 스킵 리스트에 대한 제한이 예상되는 반면, 이진 검색은 정렬된 테이블과 최악의 경우 제한이 있습니다.","The skip list has the same logarithmic time bounds for searching as is achieved by the binary search algorithm, yet it extends that performance to update methods when inserting or deleting items. Nevertheless, the bounds are expected for the skip list, while binary search has a worst-case bound with a sorted table.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
건너뛰기 목록은 AVL Tree나 다른 균형 잡힌 검색 트리와 어떻게 비교되나요?,How does a skip list compare to an AVL tree or other balanced search trees?,최적화된 스킵 목록은 AVL Tree 및 기타 균형 잡힌 검색 트리보다 실제로 더 빠릅니다.,Optimized skip lists are faster in practice than AVL trees and other balanced search trees.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
스킵 리스트는 어떤 간단한 구현인가요?,What are skip lists a simple implementation of?,건너뛰기 목록은 정렬된 지도의 간단한 구현을 제공합니다.,Skip lists provide a simple implementation of a sorted map.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"항목이 n개이고 높이가 h인 스킵 리스트 S에서 __getitem__, __setitem_, __delitem__ 맵 작업을 수행하는 최악의 실행 시간은 얼마인가요?","What is the worst-case running time for performing the __getitem__, __setitem__, and __delitem__ map operations in a skip list S with n entries and height h?",O(n + h),O(n + h),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
확률이 높은 n개의 항목이 있는 건너뛰기 목록 S의 높이는 얼마인가요?,What is the height of a skip list S with n items with high probability?,O(로그 n),O(log n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가방이란 무엇인가요?,What is a bag?,멀티셋(또는 가방이라고도 함)은 복제를 가능하게 하는 세트와 같은 용기입니다.,A multiset (also known as a bag) is a set-like container that allows duplicates.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
멀티셋이란 무엇인가요?,What is a multiset?,멀티셋(또는 가방이라고도 함)은 복제를 가능하게 하는 세트와 같은 용기입니다.,A multiset (also known as a bag) is a set-like container that allows duplicates.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
멀티맵이란 무엇인가요?,What is a multimap?,"멀티맵은 값을 키와 연결한다는 점에서 전통적인 맵과 유사하지만, 멀티맵에서는 동일한 키를 여러 값에 매핑할 수 있습니다. 예를 들어, 이 책의 인덱스는 주어진 용어를 책의 다른 곳에서 해당 용어가 발생하는 하나 이상의 위치에 매핑합니다.","A multimap is similar to a traditional map, in that it associates values with keys; however, in a multimap the same key can be mapped to multiple values. For example, the index of this book maps a given term to one or more locations at which the term occurs elsewhere in the book.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
당신이 속한 수업의 인스턴스를 어떻게 만들 수 있나요?,How can you create an instance of the class you're in?,thing = type(self)(),thing = type(self)(),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
멀티셋을 구현하는 방법은 무엇인가요?,What is a way to implement a multiset?,"멀티셋을 구현하는 방법은 맵 키가 멀티셋의 (별명한) 요소이고, 연관된 값은 멀티셋 내에서 해당 요소의 발생 횟수의 카운트인 맵을 사용하는 것입니다.","A way to implement a multiset is by using a map in which the map key is a (distinct) element of the multiset, and the associated value is a count of the number of occurrences of that element within the multiset.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
전임자란 무엇인가요?,What is a predecessor?,"위치 p보다 작은 키가 포함된 위치(즉, 순서대로 이동할 때 p 직전에 방문할 위치)를 반환합니다","Return the position containing the greatest key that is less than that of position p (i.e., the position that would be visited immediately before p in an inorder traversal)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
후계자란 무엇인가요?,What is a successor?,"위치 p보다 큰 최소 키를 포함하는 위치(즉, 순서대로 이동할 때 p 직후에 방문할 위치)","The position containing the least key that is greater than that of position p (i.e., the position that would be visited immediately after p in an inorder traversal)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
공장 방식 설계 패턴의 예는 무엇인가요?,What is an example of the factory method design pattern?,부모 클래스의 메서드 내에서 생성되는 노드 유형을 상속하고 보강하여 제어할 수 있는 수단을 하위 클래스에 제공합니다.,"We provide a subclass the means to control the type of node that is created within methods of the parent class, by inheriting and augmenting.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
AVL Tree의 특별한 속성은 무엇인가요?,What is the special property of AVL trees?,높이 균형 속성: T의 모든 위치 p에 대해 p의 자녀의 높이는 최대 1만큼 다릅니다.,"Height-Balance Property: For every position p of T, the heights of the children of p differ by at most 1.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
AVL은 무엇을 의미하나요?,What does AVL stand for?,아델손-벨스키와 랜디스,Adel'son-Vel'skii and Landis,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n개의 항목을 저장하는 AVL Tree의 최대 높이는 얼마인가요?,What is the maximum height of an AVL tree storing n entries?,최대 2 로그 n + 2,At most 2 log n + 2,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
플레이 트리의 셀프 밸런싱 속성의 특별한 점은 무엇인가요?,What is special about the self-balancing property of a splay tree?,"플레이 트리는 트리 높이에 대한 로그 상한을 엄격하게 적용하지 않습니다. 실제로 이 트리의 노드와 관련된 추가 높이, 균형 또는 기타 보조 데이터는 없습니다.","A splay tree does not strictly enforce a logarithmic upper bound on the height of the tree. In fact, there are no additional height, balance, or other auxiliary data associated with the nodes of this tree.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
플레이 트리의 셀프 밸런싱 속성에 플레이가 중요한 이유는 무엇인가요?,Why is splaying vital to the self-balancing property of a splay tree?,"재생을 통해 삽입, 삭제 및 검색에 대한 로그 상각 실행 시간을 보장할 수 있습니다.","Splaying allows us to guarantee a logarithmic amortized running time, for insertions, deletions, and searches.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"빨강-검정색 나무는 (2,4) 나무와 어떻게 관련이 있나요?","How does a red-black tree relate to a (2,4) tree?","적색-검은색 트리가 주어졌을 때, 우리는 모든 적색 노드 w를 부모로 병합하고, w의 항목을 부모에 저장하며, w의 자식들이 부모의 자식이 되는 것을 통해 해당 (2,4) 트리를 구성할 수 있습니다.","Given a red-black tree, we can construct a corresponding (2,4) tree by merging every red node w into its parent, storing the entry from w at its parent, and with the children of w becoming ordered children of the parent.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Red-Black Tree의 time complexity 이점은 무엇인가요?,What is the time complexity advantage of a red-black tree?,Red-Black Tree의 주요 장점은 삽입 또는 삭제 작업이 일정한 횟수만큼만 필요하다는 점입니다.,The primary advantage of a red-black tree is that an insertion or deletion requires only a constant number of restructuring operations.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
층이 어디인가요?,What is the floor?,"x의 바닥, 즉 k ≤ x인 가장 큰 정수 k의 바닥","the floor of x, that is, the largest integer k, such that k ≤ x",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
천장이란 무엇인가요?,What is the ceiling?,"x의 천장, 즉 x ≤ m이 되도록 하는 가장 작은 정수 m","the ceiling of x, that is, the smallest integer m, such that x ≤ m",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
병합 실행 시간은 어떻게 되나요?,What is the running time of merge?,O(len(n1) + len(n2)),O(len(n1) + len(n2)),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
상향식 Merge Sort이란 무엇인가요?,What is bottom-up merge sort?,"주요 아이디어는 Merge Sort을 수행하는 것으로, Merge Sort 트리를 올라갈 때 레벨별로 병합 레벨을 수행하는 것입니다. 입력된 요소 배열이 주어지면, 우리는 모든 연속적인 요소 쌍을 길이 2의 정렬된 실행으로 병합하는 것으로 시작합니다. 우리는 이 실행들을 길이 4의 실행으로 병합하고, 새로운 실행들을 길이 8의 실행으로 병합한 후, 배열이 정렬될 때까지 계속합니다.","The main idea is to perform merge-sort bottom-up, performing the merges level by level going up the merge-sort tree. Given an input array of elements, we begin by merging every successive pair of elements into sorted runs of length two. We merge these runs into runs of length four, merge these new runs into runs of length eight, and so on, until the array is sorted.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
비교 기반 정렬의 최악의 하한선은 무엇인가요?,What is the worst-case lower bound on comparison-based sorting?,비교 기반 정렬에는 실행 시간에 ω(n log n) 최악의 경우 하한이 있습니다.,Comparison-based sorting has an Ω(n log n) worst-case lower bound on its running time.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
버킷 정렬에서 키의 범위 N과 시퀀스 크기 n의 최적 관계는 무엇인가요?,What is the optimal relationship of range N of keys to sequence size n in bucket sort?,버킷 정렬은 키의 값 범위 N이 시퀀스 크기 n에 비해 작을 때 효율적입니다(예: N = O(n) 또는 N = O(n log n). 하지만 N이 증가함에 따라 성능이 저하됩니다.,"Bucket-sort is efficient when the range N of values for the keys is small compared to the sequence size n, say N = O(n) or N = O(n log n). Still, its performance deteriorates as N grows compared to n.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
안정적인 정렬에서 두 개 이상의 열을 정렬할 때 경험 법칙은 무엇인가요?,What is the rule of thumb in sorting on 2 or more columns across a stable sort?,"먼저 두 번째 구성 요소로 안정적으로 정렬한 다음 첫 번째 구성 요소로 다시 정렬함으로써, 두 번째 정렬(첫 번째 구성 요소로 정렬)에서 두 항목이 같으면 시작 순서(두 번째 구성 요소로 정렬)에서의 상대적 순서가 유지된다는 것을 보장합니다.","By first stably sorting by the second component and then again by the first component, we guarantee that if two entries are equal in the second sort (by the first component), then their relative order in the starting sequence (which is sorted by the second component) is preserved.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
크기 N의 d 키를 가로지르는 래딕스 정렬의 time complexity는 얼마인가요?,What is the time complexity of radix sort across d keys of size N?,"S를 n개의 키-값 쌍으로 이루어진 시퀀스라고 하자. 여기서 ki는 [0, N - 1] 범위의 정수로, 어떤 정수 N ≥ 2에 대해 [k1, k2, ... , kd]라고 하자. 우리는 radix-sort를 사용하여 S를 시간 O(d(n + N)) 내에 사전적으로 정렬할 수 있다.","Let S be a sequence of n key-value pairs, each of which has a key (k1,k2, . . . ,kd), where ki is an integer in the range [0,N − 1] for some integer N ≥ 2. We can sort S lexicographically in time O(d(n + N)) using radix-sort.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n개의 항목에 대한 삽입 정렬 실행 시간(m은 반전 횟수(요소 쌍의 순서가 맞지 않는 횟수)은 얼마인가요?,What is the running time of insertion-sort  on n items where m is the number of inversions (the number of pairs of elements out of order)?,O(n + m),O(n + m),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Insertion Sort은 어떤 경우에 빠른 정렬 또는 Merge Sort을 의미하나요?,In what case does insertion sort beat quicksort or merge sort?,"이미 ""거의"" 정렬된 시퀀스를 정렬하는 경우.",For sorting sequences that are already “almost” sorted.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Heap Sort은 안정적인가요?,Is heap sort stable?,아니요. 표준 힙-소트는 요소의 교환 때문에 안정적인 정렬을 제공하지 않습니다.,"No. A standard heap-sort does not provide a stable sort, because of the swapping of elements.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"비록 O(n^2)-시간 최악의 성능으로 인해 실시간 애플리케이션에서 퀵숏이 취약해지더라도, 그 성능에 대해 무엇을 기대할 수 있을까요?","Even though it's O(n^2)-time worst-case performance makes quicksort susceptible in real-time applications, what can we expect of its performance?","우리는 그것의 성능이 O(n log n)-시간일 것으로 예상하며, 실험 연구에 따르면 많은 테스트에서 힙 정렬과 병합 정렬 모두에서 우수한 성능을 보였습니다.","We expect its performance to be O(n log n)-time, and experimental studies have shown that it outperforms both heap-sort and merge-sort on many tests.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
병합 유형의 빛나는 사용 사례는 무엇인가요?,What is the shining using case of merge sort?,"병합 정렬은 입력이 컴퓨터 메모리 계층의 다양한 수준(예: 캐시, 메인 메모리, 외부 메모리)에 걸쳐 계층화되는 상황에 적합한 알고리즘입니다. 이러한 상황에서 병합 정렬이 긴 병합 스트림에서 데이터를 처리하는 방식은 메모리 수준으로 블록으로 가져온 모든 데이터를 최대한 활용하여 총 메모리 전송 수를 줄입니다.","Merge-sort is an excellent algorithm for situations where the input is stratified across various levels of the computer's memory hierarchy (e.g., cache, main memory, external memory). In these contexts, the way that merge-sort processes runs of data in long merge streams makes the best use of all the data brought as a block into a level of memory, thereby reducing the total number of memory transfers.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
Timsort란 무엇이며 왜 훌륭한 정렬 알고리즘인가요?,What is Timsort and why is it a great sorting algorithm?,팀-소트(Tim Peters가 설계)는 기본적으로 데이터의 일부 초기 실행을 활용하면서 삽입-소트를 사용하여 추가 실행을 구축하는 상향식 병합-소트입니다.,"Tim-sort (designed by Tim Peters), which is essentially a bottom-up merge-sort that takes advantage of some initial runs in the data while using insertion-sort to build additional runs.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
문자열의 길이에 따라 문자열 시퀀스를 어떻게 정렬할 수 있나요?,How can you sort a sequence of strings by their length?,"foo.sort(key=len)
또는
정렬됨(foo, key=len)","foo.sort(key=len)
or
sorted(foo, key=len)",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
파이썬은 정렬할 때 키 매개변수와 함께 어떤 디자인 패턴을 사용하나요?,What design pattern does Python use with the key parameter when sorting?,장식-sort-undec레이트,decorate-sort-undecorate,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
주문 통계란 무엇인가요?,What are order statistics?,주어진 순위를 가진 요소를 요청하는 쿼리입니다.,Queries that ask for an element with a given rank.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가지치기와 탐색 또는 감소와 정복이란 무엇인가요?,What is prune-and-search or decrease-and-conquer?,우리는 n개의 객체 집합에 정의된 주어진 문제를 해결하기 위해 n개의 객체 중 일부를 가지치기하고 더 작은 문제를 재귀적으로 해결합니다.,We solve a given problem that is defined on a collection of n objects by pruning away a fraction of the n objects and recursively solving the smaller problem.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
허프만 코드를 생성할 때 각 요소의 인코딩에 중요한 제한 사항은 무엇인가요?,"When generating a Huffman code, what is an important restriction on the encoding for each element?","모호성을 피하기 위해 인코딩의 어떤 코드워드도 인코딩의 다른 코드워드의 접두사가 아니라고 주장합니다. 이러한 코드를 접두사 코드라고 하며, Y의 디코딩을 간소화하여 X를 검색합니다.","In order to avoid ambiguities, we insist that no code-word in our encoding be a prefix of another code-word in our encoding. Such a code is called a prefix code, and it simplifies the decoding of Y to retrieve X.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
허프만 알고리즘이 d개의 서로 다른 문자를 가진 길이 n의 문자열에 대해 최적의 접두사 코드를 구성할 때의 time complexity는 얼마인가요?,What is the time complexity when Huffman’s algorithm constructs an optimal prefix code for a string of length n with d distinct characters?,O(n + d log d),O(n + d log d),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
탐욕스러운 선택 속성이란 무엇인가요?,What is the greedy-choice property?,"이것은 잘 정의된 시작 조건에서 시작하여 일련의 국소 최적 선택(즉, 당시 이용 가능한 가능성 중에서 각각 현재 가장 좋은 선택)에 의해 전역 최적 조건에 도달할 수 있는 속성입니다.","This is the property that a global optimal condition can be reached by a series of locally optimal choices (that is, choices that are each the current best from among the possibilities available at the time), starting from a well-defined starting condition.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
텍스트를 전처리할 가치가 있을 때 사용하는 경우는 무엇인가요?,What is the use case when preprocessing a text is worth it?,고정된 텍스트에 대해 일련의 쿼리가 수행되어 텍스트 전처리의 초기 비용이 각 후속 쿼리의 속도 향상으로 보상되는 경우.,"Where a series of queries is performed on a fixed text, so that the initial cost of preprocessing the text is compensated by a speedup in each subsequent query.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
시도의 주요 애플리케이션은 무엇인가요?,What is the main application for tries?,정보 검색,information retrieval,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
지원을 시도하는 주요 쿼리 작업은 무엇인가요?,What are the primary query operations that tries support?,패턴 매칭 및 접두사 매칭,pattern matching and prefix matching,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
표준 트라이의 공간 비효율성을 해결하는 것은 무엇인가요?,What solves the space inefficiency in the standard trie?,압축 트리는 (역사적인 이유로) 패트리샤 트리라고도 불립니다.,"Compressed trie, which is also known (for historical reasons) as the Patricia trie.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
표준 트라이에 비해 압축 트라이의 장점은 무엇인가요?,What is the advantage of a compressed trie over a standard trie?,압축 트리의 노드 수는 문자열의 총 길이가 아니라 문자열의 수에 비례합니다.,The number of nodes of the compressed trie is proportional to the number of strings and not to their total length.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
문자열 X의 접미사 트리(접미사 트리 또는 위치 트리라고도 함)는 무엇인가요?,What is a suffix trie (also known as a suffix tree or position tree) of string X?,컬렉션 S의 문자열이 모두 문자열 X의 접미사인 경우.,The case when the strings in the collection S are all the suffixes of a string X.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
접미사 트라이는 모든 접미사 목록에 공백을 어떻게 저장하나요?,How does a suffix trie save space over a list of all suffixes?,X의 모든 접미사를 명시적으로 저장하면 O(n^2) 공간이 됩니다. 그럼에도 불구하고 접미사 트라이는 이러한 문자열을 O(n) 공간에 암묵적으로 나타냅니다.,"Storing all the suffixes of X explicitly would take O(n^2) space. Even so, the suffix trie represents these strings implicitly in O(n) space.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
보이어 무어의 캐릭터 비교 상한선은 무엇인가요?,What is the upper bound on character comparisons in Boyer-Moore?,"최악의 경우 최대 3n개의 문자 비교가 가능하며, 이 경계는 엄격합니다.","At most 3n character comparisons in the worst case, and this bound is tight.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
혼합 그래프란 무엇인가요?,What is a mixed graph?,방향성 가장자리와 방향성이 없는 가장자리를 모두 가진 그래프.,A graph that has both directed and undirected edges.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
강하게 연결된 그래프란 무엇인가요?,What is a strongly connected graph?,방향 그래프 G는 G의 두 정점 u와 v에 대해 u가 v에 도달하고 v가 u에 도달하면 강하게 연결됩니다.,"A directed graph G is strongly connected if for any two vertices u and v of G, u reaches v and v reaches u.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 지도란 무엇인가요?,What is an adjacency map?,"인접 맵은 인접 목록과 매우 유사하지만, 정점에 입사하는 모든 간선의 보조 컨테이너는 목록이 아닌 지도로 구성되며 인접한 정점이 키 역할을 합니다. 이를 통해 O(1) 예상 시간 내에 특정 간선(u, v)에 액세스할 수 있습니다.","An adjacency map is very similar to an adjacency list, but the secondary container of all edges incident to a vertex is organized as a map, rather than as a list, with the adjacent vertex serving as a key. This allows for access to a specific edge (u, v) in O(1) expected time.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 지도의 성능에 대해 무엇을 주장할 수 있을까요?,What can we claim of the performance of adjacency map?,"우리는 그것이 본질적으로 모든 방법에서 최적의 실행 시간을 달성한다는 것을 발견했으며, 이는 그래프 표현으로서 탁월한 다목적 선택임을 보여줍니다.","We find that it essentially achieves optimal running times for all methods, making it an excellent all-purpose choice as a graph representation.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프에서 간선 수에 대한 상한은 무엇인가요?,What is the upper bound on the number of edges in a graph?,n^2,n^2,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
인접 행렬을 공간 효율적으로 만들려면 어떻게 해야 하나요?,How can an adjacency matrix be made space efficient?,"엣지에 보조 데이터가 없는 경우, 부울 인접 행렬은 엣지 슬롯당 하나의 비트를 사용할 수 있으며, 이는 A[i, j] = True가 되는 경우에만 해당합니다 (u, v).","If edges do not have auxiliary data, a Boolean adjacency matrix can use one bit per edge slot, such that A[i, j] = True if and only if associated (u, v) is an edge.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
그래프의 속성을 테스트하기 위해 DFS를 사용하는 방법에는 어떤 것이 있나요?,What are some uses of DFS for testing of properties of graphs?,"- 한 정점에서 다른 정점으로 가는 경로가 있는지 여부(전이적 폐쇄)
- 그래프가 연결되었는지 여부","- whether there is a path from one vertex to another (transitive closure)
- whether or not a graph is connected",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DFS에서 트리 엣지란 무엇이고 트리 엣지가 아닌 엣지란 무엇인가요?,What is a tree edge and what is a non-tree edge in DFS?,"Whenever an edge e = (u,v) is used to discover a new vertex v during the DFS algorithm, that edge is known as a discovery edge or tree edge, as oriented from u to v. All other edges that are considered during the execution of DFS are known as non-tree edges, which take us to a previously visited vertex.","Whenever an edge e = (u,v) is used to discover a new vertex v during the DFS algorithm, that edge is known as a discovery edge or tree edge, as oriented from u to v. All other edges that are considered during the execution of DFS are known as non-tree edges, which take us to a previously visited vertex.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
DFS에서 발견 엣지의 특별한 점은 무엇인가요?,What is special about discovery edges in DFS?,방문하지 않은 정점으로 갈 때만 발견 에지를 따르기 때문에 이러한 에지와 사이클을 형성하지 않습니다. 따라서 발견 에지는 사이클 없이 연결된 하위 그래프를 형성하므로 트리가 됩니다. 또한 방금 살펴본 것처럼 깊이 우선 검색이 s의 연결된 구성 요소의 각 정점을 방문하기 때문에 스패닝 트리입니다.,"Since we only follow a discovery edge when we go to an unvisited vertex, we will never form a cycle with such edges. Therefore, the discovery edges form a connected subgraph without cycles, hence a tree. Moreover, this is a spanning tree because, as we have just seen, the depth-first search visits each vertex in the connected component of s.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
정점 s에서 시작하는 DFS의 실행 시간은 얼마인가요? 여기서 ns는 s에서 도달할 수 있는 정점의 수입니다. ms는 해당 정점에 입사하는 간선의 수입니다?,"What is the runtime of DFS starting at vertex s, where ns is the number of vertices reachable from s, and ms is the number of incident edges to those vertices?",O(ns + ms),O(ns + ms),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
ns가 정점 s에서 도달할 수 있는 정점의 수이고 ms ≤ m이 정점에 입사하는 간선의 수인 경우 BFS의 실행 시간은 얼마입니까?,"What is the running time of BFS if ns is the number of vertices reachable from vertex s, and ms ≤ m is the number of incident edges to those vertices?","DFS와 유사하게 알고리즘은 O(n + m) 시간, 더 구체적으로는 O(ns + ms) 시간에 실행됩니다.","Similar to the one of DFS, with the algorithm running in O(n + m) time, or more specifically, in O(ns + ms) time.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
방향 그래프에서 DFS가 BFS보다 더 나은 상황은 무엇인가요?,Under what circumstances does DFS do better than BFS in directed graphs?,"- 그래프에서 방향성 있는 주기 찾기
- 강하게 연결된 구성 요소 식별","- finding a directed cycle in the graph
- identifying the strongly connected components",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
방향 그래프의 전이 폐색이란 무엇인가요?,What is the transitive closure of a directed graph?,"그것은 G와 정점이 동일하지만, G의 정점들 사이에 경로가 존재할 때 정점들이 직접 연결되는 방향 그래프입니다.","It's a directed graph where the vertices are the same as G, but vertices are connected directly when a path exists between those vertices in G.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
방향 그래프의 전이 닫힘을 생성하는 런타임은 무엇이며 어떤 방법을 사용할 수 있나요?,What is the runtime of generating the transitive closure of a directed graph and what method can be used?,"플로이드 워샬을 사용할 수 있지만, O(n^3)이고 최소 경로 가중치가 필요하지 않을 수도 있습니다.
DFS에 반복적으로 호출하면 그래프가 희소하고 인접 목록이나 인접 맵을 사용하여 표현될 때 더 나은 점근 성능을 얻을 수 있습니다. 이 경우 단일 DFS는 O(n + m) 시간 내에 실행되므로 전이 폐쇄를 O(n^2 + nm) 시간 내에 계산할 수 있으며, 이는 O(n^3)보다 바람직합니다.","Could use Floyd-Warshall, but it is O(n^3), and you may not need the minimum path weight.
Repeated calls to DFS results in better asymptotic performance when the graph is sparse and represented using an adjacency list or adjacency map. In that case, a single DFS runs in O(n + m) time, and so the transitive closure can be computed in O(n^2 + nm) time, which is preferable to O(n^3).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
위상학적 유형의 시간과 공간 복잡성은 무엇인가요?,What is the time and space complexity of topological sort?,"인접 목록 표현을 사용하여 G를 n개의 꼭짓점과 m개의 간선을 가진 방향 그래프라고 합시다. 위상 정렬 알고리즘은 O(n) 보조 공간을 사용하여 O(n + m) 시간 내에 실행되며, G의 위상 순서를 계산하거나 일부 꼭짓점을 포함하지 않아 G가 방향성 사이클을 가지고 있음을 나타냅니다.","Let G be a directed graph with n vertices and m edges, using an adjacency list representation. The topological sorting algorithm runs in O(n + m) time using O(n) auxiliary space, and either computes a topological ordering of G or fails to include some vertices, which indicates that G has a directed cycle.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
다이크스트라 알고리즘의 실행 시간은 어떻게 되나요?,What is the running time for Dijkstra's algorithm?,O((n + m)log n),O((n + m)log n),2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
크루스칼 알고리즘의 실행 시간은 어떻게 되나요?,What is the running time of Kruskal's algorithm?,"O(m log n)

연결된 그래프의 경우, m ≥ n - 1이며, 따라서 간선을 정렬하는 O(m log n) 시간의 경계가 클러스터를 관리하는 시간(log*n)을 지배합니다.","O(m log n)

For a connected graph, m ≥ n − 1, and therefore, the bound of O(m log n) time for ordering the edges dominates the time for managing the clusters (which is log*n).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
로그 스타 함수의 다른 이름은 무엇인가요?,What is another name of the log-star function?,타워 오브 투 함수의 역함수.,The inverse of the tower-of-twos function.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
로그 ∗ n은 무엇을 의미하나요?,What does log∗ n mean?,로그 ∗ n은 2보다 작은 숫자를 얻기 전에 숫자의 로그(기본값 2)를 반복적으로 취할 수 있는 횟수입니다.,log∗ n is the number of times that one can iteratively take the logarithm (base 2) of a number before getting a number smaller than 2.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
내부 분열이란 무엇인가요?,What is internal fragmentation?,할당된 메모리 블록의 일부가 사용되지 않을 때 내부 분열이 발생합니다.,Internal fragmentation occurs when a portion of an allocated memory block is unused.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
가장 적합하지 않은 알고리즘은 무엇인가요?,What is the worst-fit algorithm?,최악의 알고리즘은 사용 가능한 메모리의 가장 큰 구멍을 찾기 위해 무료 목록을 검색합니다.,The worst-fit algorithm searches the free list to find the largest hole of available memory.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최악의 알고리즘이 내부 분열을 피하는 데 가장 적합한 이유는 무엇인가요?,Why is the worst-fit algorithm the best for avoiding internal fragmentation?,최악의 알고리즘은 빈 메모리의 연속적인 부분을 가능한 한 크게 유지하려고 시도합니다.,The worst-fit algorithm attempts to keep contiguous sections of free memory as large as possible.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
제자리 DFS는 어떻게 작동하며 쓰레기 수거 시 귀중한 공간을 절약하는 방법은 무엇인가요?,How does in-place DFS work and how does it save precious space when performing garbage collection?,"DFS를 제자리에서 수행하기 위한 주요 아이디어는 그래프의 엣지(가비지 컬렉션의 경우 객체 참조에 해당)를 사용하여 재귀 스택을 시뮬레이션하는 것입니다. 방문한 정점 v에서 새로운 정점 w로 엣지를 이동할 때, 우리는 v의 인접 목록에 저장된 엣지(v, w)를 변경하여 DFS 트리에서 v의 부모를 다시 가리키도록 합니다. v로 돌아갈 때(w에서 ""재귀"" 호출의 반환을 시뮬레이션할 때), 우리가 수정한 엣지를 다시 w로 가리키도록 전환할 수 있으며, 이는 어떤 엣지를 다시 변경해야 하는지 식별할 수 있는 방법이 있다고 가정합니다.","The main idea for performing DFS in-place is to simulate the recursion stack using the edges of the graph (which in the case of garbage collection correspond to object references). When we traverse an edge from a visited vertex v to a new vertex w, we change the edge (v, w) stored in v's adjacency list to point back to v's parent in the DFS tree. When we return back to v (simulating the return from the ""recursive"" call at w), we can then switch the edge we modified to point back to w, assuming we have some way to identify which edge we need to change back.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
내부 기억이란 무엇인가요?,What is internal memory?,메인 메모리 또는 코어 메모리.,Main memory or core memory.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
외부 기억이란 무엇인가요?,What is external memory?,"일반적으로 디스크, CD 드라이브, DVD 드라이브 및/또는 테이프로 구성됩니다.","Usually consists of disks, CD drives, DVD drives, and/or tapes.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
컴퓨터 건축가들 사이에서 흔히 사용되는 격언은 무엇인가요?,What is a common adage among computer architects?,프로그램은 코드의 10%에 90%의 시간을 보냅니다.,A program spends 90 percent of its time in 10 percent of its code.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
최고에서 최악의 캐싱 전략은 무엇인가요?,What are the best to worst caching strategies?,LRU 전략은 일반적으로 무작위 전략보다 더 나은 FIFO 전략보다 우수한 것으로 나타났습니다.,"The LRU strategy has been shown to be usually superior to the FIFO strategy, which is usually better than the random strategy.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
I/O 복잡성이란 무엇인가요?,What is I/O complexity?,쿼리나 업데이트를 수행하는 데 필요한 디스크 전송 횟수를 최소화하세요.,Minimize the number of disk transfers needed to perform a query or update.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"(2, 4) 트리의 각 노드에는 몇 개의 자식이 있나요?","How many children does each node of a (2, 4) tree have?",2-4,2-4,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"(a, b) 트리의 각 노드에는 몇 개의 자식이 있나요?","How many children does each node of a (a, b) tree have?",a-b,a-b,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"(a, b) 트리란 무엇인가요?","What is an (a, b) tree?","(a, b) 트리는 각 노드가 a와 b 자식 사이에 있고 a - 1과 b - 1 항목 사이에 저장되는 다중 검색 트리입니다. (a, b) 트리의 항목을 검색, 삽입 및 제거하는 알고리즘은 (2, 4) 트리에 해당하는 항목을 간단하게 일반화한 것입니다.","An (a, b) tree is a multiway search tree such that each node has between a and b children and stores between a − 1 and b − 1 entries. The algorithms for searching, inserting, and removing entries in an (a, b) tree are straightforward generalizations of the corresponding ones for (2, 4) trees.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"n개의 항목을 저장하는 (a, b) 트리의 높이에 대한 경계는 무엇인가요?","What are the bounds on the height of an (a, b) tree storing n entries?","n개의 항목을 저장하는 (a,b) 트리의 높이는 ω(log n/log b)와 O(log n/log a)입니다.","The height of an (a,b) tree storing n entries is Ω(log n/log b) and O(log n/log a).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"(a, b) 트리의 a와 b는 어떻게 선택하나요?","How do we select the a and b of an (a, b) tree?","To minimize disk accesses, we select the parameters a and b so that each tree node occupies a single disk block (so that f (b) = 1 if we wish to simply count block transfers).","To minimize disk accesses, we select the parameters a and b so that each tree node occupies a single disk block (so that f (b) = 1 if we wish to simply count block transfers).",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"(a, b) 트리의 주요 용도는 무엇인가요?","What is the main application of (a, b) trees?",외부 메모리에 저장된 지도,maps stored in external memory,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"(a, b) 트리와 관련된 B-트리란 무엇인가요?","What is a B-tree in relation to an (a, b) tree?","A B-tree of order d is an (a, b) tree with a = ceiling(d/2) and b = d.

We specifically choose d = (M/B) − 1 so that we can afford to keep one block from each input sequence in main memory at any given time, and to have one additional block to use as a buffer for the merged sequence.","A B-tree of order d is an (a, b) tree with a = ceiling(d/2) and b = d.

We specifically choose d = (M/B) − 1 so that we can afford to keep one block from each input sequence in main memory at any given time, and to have one additional block to use as a buffer for the merged sequence.",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
n개의 항목이 있는 B-트리는 어떤 I/O 복잡도를 가지며 몇 개의 블록을 사용하나요?,A B-tree with n entries has what I/O complexity and uses how many blocks?,"- 검색 또는 업데이트 작업을 위한 O(log(베이스 B) n)
- O(n/B) 블록을 사용합니다. 여기서 B는 블록의 크기입니다","- O(log(base B) n) for search or update operation
- uses O(n/B) blocks, where B is the size of a block",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"주 메모리의 크기가 M이고 각 블록의 크기가 B인 경우, 주어진 시간에 주 메모리 내에 몇 개의 블록을 저장할 수 있나요?",if main memory has size M and each block has size B how many blocks can we store within main memory at any given time?,최대 M/B 블록까지.,Up to M/B blocks.,2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01
"외부 메모리에 압축적으로 저장된 n개의 요소로 이루어진 배열 기반 시퀀스 S가 주어졌을 때, 정렬 S의 I/O 복잡도는 얼마인가요?","What is the I/O complexity, given an array-based sequence S of n elements stored compactly in external memory, of sorting S?","- O(((n/B)log(n/B)/log(M/B)) 블록 전송: 여기서 M은 내부 메모리의 크기이고 B는 블록의 크기입니다.
- O(n 로그 n) 내부 계산","- O((n/B)log(n/B)/log(M/B)) block transfers where M is the size of the internal memory and B is the size of a block.
- O(n log n) internal computations",2.5,1,2026-02-02 13:11:01,2026-02-02 13:11:01

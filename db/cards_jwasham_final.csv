question_en,question_ko,answer_en,answer_ko,category,ef_factor,created_at,modified_at
What is Hamming Code?,해밍 코드란 무엇인가요?,"In telecommunication, Hamming codes are a family of linear error-correcting codes that generalize the Hamming(7,4)-code, and were invented by Richard Hamming in 1950. Hamming codes can detect up to two-bit errors or correct one-bit errors without detection of uncorrected errors.","통신에서 해밍 코드는 해밍(7,4) 코드를 일반화한 선형 오류 수정 코드 계열로, 1950년 리처드 해밍에 의해 발명되었습니다. 해밍 코드는 수정되지 않은 오류를 감지하지 않고도 최대 2비트 오류를 감지하거나 1비트 오류를 수정할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the square root of 256?,256의 제곱근은 무엇인가요?,16,16,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
2^16,2^16,"65,536","65,536",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Using bitwise operations, how would you test that a number is a power of 2?",비트 단위 연산을 사용하여 숫자가 2의 거듭제곱인지 어떻게 테스트하시겠습니까?,bool isPowerOfTwo = (x & (x - 1);,bool isPowerOfTwo = (x & (x - 1);,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does ELF stand for?,ELF는 무엇을 의미하나요?,"Executable and Linkable Format.
It's a common standard file format for executables, object code, shared libraries, and core dumps.","실행 가능하고 연결 가능한 형식.
실행 파일, 객체 코드, 공유 라이브러리, 코어 덤프를 위한 일반적인 표준 파일 형식입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
example of a latency device,지연 장치의 예,CPU core,CPU 코어,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
example of a throughput device,처리량 장치의 예,GPU core,GPU 코어,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Hamming Distance?,해밍 거리란 무엇인가요?,A number used to denote the number of differences between two binary strings of the same length.,같은 길이의 두 이진 문자열 간의 차이 수를 나타내는 데 사용되는 숫자입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the 5 steps of the compiling process?,컴파일 과정의 5단계는 무엇인가요?,"Lexical Analysis
Parsing
Semantic Analysis
Optimization
Code Generation","어휘 분석
구문 분석
의미 분석
최적화
코드 생성",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is parsing?,파싱이란 무엇인가요?,Combining tokens and groups of tokens into a tree structure (a parse tree).,토큰과 토큰 그룹을 트리 구조(파싱 트리)로 결합합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is lexical analysis?,어휘 분석이란 무엇인가요?,The process of dividing program text into words or tokens.,프로그램 텍스트를 단어나 토큰으로 나누는 과정.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is code generation?,코드 생성이란 무엇인가요?,Producing a translation from a high-level program to assembly code. (Linker and Archiver taker over from here to produce machine code),고급 프로그램에서 어셈블리 코드로의 번역을 생성합니다. (Linker와 Archiver가 여기서 기계 코드를 생성합니다.),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
4 * 16,4 * 16,64,64,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
2 ^ 4,2 ^ 4,16,16,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
2^3,2^3,8,8,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
2^5,2^5,32,32,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
2^6,2^6,64,64,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
2^7,2^7,128,128,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
2^8,2^8,256,256,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
2^9,2^9,512,512,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
2^10,2^10,1024,1024,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
2^11,2^11,2048,2048,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
2^12,2^12,4096,4096,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
2^13,2^13,8192,8192,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
2^14,2^14,"16,384","16,384",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
2^15,2^15,"32,768","32,768",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
2^32,2^32,4.294 Billion,"42억 9,400만",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of char in bits,비트 단위의 char 크기,8 bits,8비트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of char in bytes,문자 크기(바이트 단위),1 byte,1바이트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of bool in bits,비트 단위의 bool 크기,8 bits,8비트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of short in bits,비트 단위의 short 크기,"16 bits (at least), and 16 commonly","16비트(최소), 일반적으로 16비트",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of short in bytes,바이트 단위의 short 크기,"2 bytes, and 2 bytes commonly","2바이트, 일반적으로 2바이트",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of int in bits,size of int in bits,"32 bits commonly, at least 16 bits","일반적으로 32비트, 최소 16비트",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of int in bytes,size of int in bytes,"4 bytes commonly, at least 2 bytes","일반적으로 4바이트, 최소 2바이트",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of long in bits,비트 단위의 long 크기,"32 (at least, 32 commonly), 64 on LP64","32(최소, 일반적으로 32), 64(LP64)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of long in bytes,바이트 단위의 long 크기,"4 bytes, (at least 4, and commonly 4), 8 on LP64","4바이트, (최소 4바이트, 일반적으로 4바이트), LP64에서 8바이트",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of long long in bits,비트 단위로 long long의 크기,64 bits,64비트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of long long in bytes,바이트 단위로 long 크기,8 bytes,8바이트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of float in bits,비트 단위 플로트 크기,32 bits,32비트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of float in bytes,플로트 크기(바이트),4 bytes,4바이트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of double in bits,비트 단위의 두 배 크기,64 bits,64비트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of double in bytes,바이트 단위의 두 배 크기,8 bytes,8바이트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of wchar_t in bits,비트 단위 wchar_t 크기,16 bits,16비트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
size of wchar_t in bytes,바이트 단위의 wchar_t 크기,2 bytes,2바이트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Write a function that reverses a linked list, with this argument: pointer to pointer to the head node.",연결된 목록을 뒤집는 함수를 작성하세요. 이 인수는 다음과 같습니다: 포인터에서 포인터로 헤드 노드로.,"void reverse(node_t **head) {
  node_t *prev = NULL;
  node_t *current = *head;
  node_t *next = *head;

  while (current) {
    next = current->next;
    current->next = prev;
    prev = current;
    current = next;
  }

  *head = prev;
}","void reverse(node_t **head) {
  node_t *prev = NULL;
  node_t *current = *head;
  node_t *next = *head;

  while (current) {
    next = current->next;
    current->next = prev;
    prev = current;
    current = next;
  }

  *head = prev;
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Delete a given value from a BST rooted at given node. Returns a pointer to node.,주어진 노드에 루트를 둔 BST에서 주어진 값을 삭제합니다. 노드에 포인터를 반환합니다.,"bst_node* delete_value(bst_node* node, int value) {
  if (node == NULL)
    return node;

  if (value < node->value) {
    node->left = delete_value(node->left, value);
  } else if (value > node->value) {
    node->right = delete_value(node->right, value);
  } else { // found value

    if (node->left == NULL && node->right == NULL) {
      free(node);
      node = NULL;
    } else if (node->left == NULL) {
      bst_node* temp = node;
      node = node->right;
      free(temp);
    } else if (node->right == NULL) {
      bst_node* temp = node;
      node = node->left;
      free(temp);
    } else {
      // 2 children - get min node of right subtree
      int right_min = get_min(node->right);
      node->value = right_min;
      node->right = delete_value(node->right, right_min);
    }
  }

  return node;
}","bst_node* delete_value(bst_node* node, int value) {
  if (node == NULL)
    return node;

  if (value < node->value) {
    node->left = delete_value(node->left, value);
  } else if (value > node->value) {
    node->right = delete_value(node->right, value);
  } else { // found value

    if (node->left == NULL && node->right == NULL) {
      free(node);
      node = NULL;
    } else if (node->left == NULL) {
      bst_node* temp = node;
      node = node->right;
      free(temp);
    } else if (node->right == NULL) {
      bst_node* temp = node;
      node = node->left;
      free(temp);
    } else {
      // 2 children - get min node of right subtree
      int right_min = get_min(node->right);
      node->value = right_min;
      node->right = delete_value(node->right, right_min);
    }
  }

  return node;
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Get the successor of a value in a BST rooted by given node. Returns int.,주어진 노드에 루트를 둔 BST 값의 후속 값을 가져옵니다. int를 반환합니다.,"int get_successor(bst_node* node, int value) {
  if (node == NULL)
    return -1;

  bst_node* target = node;

  while (target->value != value) {
    if (value < target->value) {
      target = target->left;
    } else if (value > target->value) {
      target = target->right;
    }
  }

  // arrived at target node
  if (target->right != NULL) {
    // get min value of right subtree
    return get_min(target->right);
  } else {
    // get lowest ancestor that is a left child in the path to target value
    bst_node* successor = NULL;
    bst_node* ancestor = node;
    while (ancestor != NULL) {
      if (value < ancestor->value) {
        successor = ancestor;
        ancestor = ancestor->left;
      } else {
        ancestor = ancestor->right;
      }
    }

    return successor->value;
  }

}","int get_successor(bst_node* node, int value) {
  if (node == NULL)
    return -1;

  bst_node* target = node;

  while (target->value != value) {
    if (value < target->value) {
      target = target->left;
    } else if (value > target->value) {
      target = target->right;
    }
  }

  // arrived at target node
  if (target->right != NULL) {
    // get min value of right subtree
    return get_min(target->right);
  } else {
    // get lowest ancestor that is a left child in the path to target value
    bst_node* successor = NULL;
    bst_node* ancestor = node;
    while (ancestor != NULL) {
      if (value < ancestor->value) {
        successor = ancestor;
        ancestor = ancestor->left;
      } else {
        ancestor = ancestor->right;
      }
    }

    return successor->value;
  }

}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Using recursion, insert a value into a tree: root = insert(node*, int)","재귀를 사용하여 값을 트리에 삽입합니다: 루트 = 삽입(노드*, int)","bst_node* insert(bst_node* node, const int value) {
  if (node == 0) {
    bst_node* new_node = malloc(sizeof(bst_node));
    if (new_node == NULL) {
      printf(""Unable to allocate memory."");
      exit(0);
    }

    new_node->value = value;
    new_node->left = 0;
    new_node->right = 0;

    node = new_node;

    return node;
  }

  if (value < node->value) {
    node->left = insert(node->left, value);
  } else if (value > node->value) {
    node->right = insert(node->right, value);
  }

  return node;
}","bst_node* insert(bst_node* node, const int value) {
  if (node == 0) {
    bst_node* new_node = malloc(sizeof(bst_node));
    if (new_node == NULL) {
      printf(""Unable to allocate memory."");
      exit(0);
    }

    new_node->value = value;
    new_node->left = 0;
    new_node->right = 0;

    node = new_node;

    return node;
  }

  if (value < node->value) {
    node->left = insert(node->left, value);
  } else if (value > node->value) {
    node->right = insert(node->right, value);
  }

  return node;
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Using an iterative approach, insert a value into a BST: insert(node*, int)","반복 접근 방식을 사용하여 BST에 값을 삽입합니다: insert(노드*, int)","void treeInsert(bst_node* node, int key) {
  bst_node* new_node;
  new_node = malloc(sizeof(*new_node));
  assert(new_node);

  new_node->key = key;
  new_node->left = 0;
  new_node->right = 0;

  while (1) {
    if (node->key > key) {
      if (node->left) {
        node = node->left;
      } else {
        node->left = new_node;
        return;
      }
    } else {
      if (node->right) {
        node = node->right;
      } else {
        node->right = new_node;
        return;
      }
    }
  }
}","void treeInsert(bst_node* node, int key) {
  bst_node* new_node;
  new_node = malloc(sizeof(*new_node));
  assert(new_node);

  new_node->key = key;
  new_node->left = 0;
  new_node->right = 0;

  while (1) {
    if (node->key > key) {
      if (node->left) {
        node = node->left;
      } else {
        node->left = new_node;
        return;
      }
    } else {
      if (node->right) {
        node = node->right;
      } else {
        node->right = new_node;
        return;
      }
    }
  }
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Write a method is_binary_search_tree that returns true if a given tree is a BST (use helper function).,주어진 트리가 BST(도움 함수 사용)인 경우 참을 반환하는 메서드 is_binary_search_tree를 작성합니다.,"bool is_binary_search_tree(bst_node* node) {
  if (node == NULL) return true;

  return is_between(node, INT_MIN, INT_MAX);
}

bool is_between(bst_node* node, int min, int max) {
  if (node == NULL) return true;

  // ensure subtrees are not hiding a value lower or higher than the subtree
  // allows
  return node->value > min && node->value < max &&
         is_between(node->left, min, node->value) &&
         is_between(node->right, node->value, max);
}","bool is_binary_search_tree(bst_node* node) {
  if (node == NULL) return true;

  return is_between(node, INT_MIN, INT_MAX);
}

bool is_between(bst_node* node, int min, int max) {
  if (node == NULL) return true;

  // ensure subtrees are not hiding a value lower or higher than the subtree
  // allows
  return node->value > min && node->value < max &&
         is_between(node->left, min, node->value) &&
         is_between(node->right, node->value, max);
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Using an iterative approach, write a function find_node(bst_node* root, int target) that returns the node with the given target value in a BST.","Using an iterative approach, write a function find_node(bst_node* root, int target) that returns the node with the given target value in a BST.","bst_node* find_node(bst_node* root, int target) {
  while (root != NULL && root->key != target) {
    if (root->key > target) {
      root = root->left;
    } else {
      root = root->right;
    }
  }
  return root;
}","bst_node* find_node(bst_node* root, int target) {
  while (root != NULL && root->key != target) {
    if (root->key > target) {
      root = root->left;
    } else {
      root = root->right;
    }
  }
  return root;
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Using an recursive approach, write a function: find_node(bst_node* node, int value) that returns the node with the given target value in a BST.","재귀적 접근 방식을 사용하여 주어진 목표 값을 가진 노드를 BST에서 반환하는 함수 find_node(bst_node* 노드, int 값)를 작성합니다.","bst_node* find_node(bst_node* node, int value) {
  if (node == NULL)
    return false;

  if (value < node->value) {
    return find_node(node->left, value);
  } else if (value > node->value) {
    return find_node(node->right, value);
  } else {
    return node;
  }
}","bst_node* find_node(bst_node* node, int value) {
  if (node == NULL)
    return false;

  if (value < node->value) {
    return find_node(node->left, value);
  } else if (value > node->value) {
    return find_node(node->right, value);
  } else {
    return node;
  }
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Function that returns the height (in nodes) of a BST: int get_height(bst_node* node),BST의 높이(노드 단위)를 반환하는 함수: int get_high(bst_node* 노드),"int get_height(bst_node* node) {
  if (node == NULL) {
    return 0;
  }

  return 1 + max_num(get_height(node->left), get_height(node->right));
}","int get_height(bst_node* node) {
  if (node == NULL) {
    return 0;
  }

  return 1 + max_num(get_height(node->left), get_height(node->right));
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many levels in a complete binary tree of size n?,크기가 n인 완전 이진 트리의 레벨은 몇 개인가요?,floor(1 + log(base2)(n)),바닥(1 + log(base2)(n)),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can build heap be done in linear time?,힙을 선형 시간 내에 빌드하려면 어떻게 해야 하나요?,"A tree of size n nodes, will have floor(n/2^h) nodes with height >= h.
The last half of nodes will be leaves, so they already satisfy the heap property. No work needs to be done on them.
going bottom-up (ignoring the last n/2 items) and satisfying the heap property one level at a time, each level going up the tree has to do at most 1 operation more than the level below it. But as you go up the tree, higher levels have fewer nodes, so you may be doing more operations, but it happens on fewer number of times.
This resembles a series:

n/2 - height 1: 1 operations
n/4 - height 2: 2 operation
n/8 - height 3: 3 operations
...
going to floor(n/2^h) - height h: h operations

n * (1/2 + 2/4 + 3/8 + 4/16 ....) = n * 1 = n","크기 n개의 노드를 가진 트리는 높이가 >= h인 바닥(n/2^h)개의 노드를 가질 것입니다.
노드의 마지막 절반은 리프가 되므로 이미 힙 속성을 만족합니다. 노드에 대한 작업을 수행할 필요가 없습니다.
상향식으로 올라가며(마지막 n/2 항목은 무시하고) 힙 속성을 한 번에 한 단계씩 만족시킵니다. 트리 위로 올라가는 각 레벨은 트리 아래 레벨보다 최대 1개 이상의 연산을 수행해야 합니다. 하지만 트리 위로 올라갈수록 더 높은 레벨의 노드 수가 줄어들어 더 많은 연산을 수행할 수 있지만, 이는 더 적은 횟수에 발생합니다.
이것은 시리즈와 비슷합니다:

n/2 - 높이 1: 작업 1
n/4 - 높이 2: 2 작동
n/8 - 높이 3: 3단계 작업
...
바닥으로 가기(n/2^h) - 높이 h: h 작업

n * (1/2 + 2/4 + 3/8 + 4/16 ....) = n * 1 = n",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
C or Python: Sort an array of numbers using heap sort.,C 또는 Python: Heap Sort을 사용하여 숫자 배열을 정렬합니다.,"void heap_sort(int* numbers, int count) {
  int temp;
  for (int i = count - 1; i > 0; --i) {
    temp = numbers[i];
    numbers[i] = numbers[0];
    numbers[0] = temp;

    percolate_down(numbers, i, 0);
  }
}

void heapify(int* numbers, int count) {
  for (int i = count / 2 - 1; i >= 0; --i) {
    percolate_down(numbers, count, i);
  }
}

void percolate_down(int* numbers, int count, int index) {
  while (index * 2 + 1 < count) {
    int swap_index = index;
    int left_child_index = index * 2 + 1;
    int right_child_index = index * 2 + 2;
    bool has_left_child = left_child_index < count;
    bool has_right_child = right_child_index < count;

    if (has_left_child && has_right_child) {
      if (numbers[left_child_index] > numbers[right_child_index]) {
        swap_index = left_child_index;
      } else {
        swap_index = right_child_index;
      }
    } else if (has_left_child) {
      swap_index = left_child_index;
    } else if (has_right_child) {
      swap_index = right_child_index;
    } else {
      break;
    }

    if (numbers[swap_index] > numbers[index]) {
      int temp = numbers[index];
      numbers[index] = numbers[swap_index];
      numbers[swap_index] = temp;

      index = swap_index;
    } else {
      break;
    }
  }
}","void heap_sort(int* numbers, int count) {
  int temp;
  for (int i = count - 1; i > 0; --i) {
    temp = numbers[i];
    numbers[i] = numbers[0];
    numbers[0] = temp;

    percolate_down(numbers, i, 0);
  }
}

void heapify(int* numbers, int count) {
  for (int i = count / 2 - 1; i >= 0; --i) {
    percolate_down(numbers, count, i);
  }
}

void percolate_down(int* numbers, int count, int index) {
  while (index * 2 + 1 < count) {
    int swap_index = index;
    int left_child_index = index * 2 + 1;
    int right_child_index = index * 2 + 2;
    bool has_left_child = left_child_index < count;
    bool has_right_child = right_child_index < count;

    if (has_left_child && has_right_child) {
      if (numbers[left_child_index] > numbers[right_child_index]) {
        swap_index = left_child_index;
      } else {
        swap_index = right_child_index;
      }
    } else if (has_left_child) {
      swap_index = left_child_index;
    } else if (has_right_child) {
      swap_index = right_child_index;
    } else {
      break;
    }

    if (numbers[swap_index] > numbers[index]) {
      int temp = numbers[index];
      numbers[index] = numbers[swap_index];
      numbers[swap_index] = temp;

      index = swap_index;
    } else {
      break;
    }
  }
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How are queues usually implemented?,대기열은 보통 어떻게 구현되나요?,Using a Circular Array or Singly Linked List.,원형 배열 또는 단일 링크 목록 사용.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How is a deque usually implemented?,데크는 보통 어떻게 구현되나요?,Using a Circular Array or Doubly Linked List.,원형 배열 또는 이중 링크 목록 사용하기.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How would you swap 2 integers using only bitwise operations?,비트 단위 연산만을 사용하여 2개의 정수를 어떻게 교환하시겠습니까?,"a ^= b
b ^= a
a ^= b","a ^ = b
b ^ = a
a ^ = b",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How would you turn ON the 3rd bit from the end in a bitstring?,비트 문자열에서 끝에서 세 번째 비트를 어떻게 켜시겠습니까?,x |= (1 << 2),x |= (1 < < 2),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How would you turn OFF the 3rd bit from the end in a bitstring?,비트 문자열에서 끝에서 세 번째 비트를 어떻게 끄시겠습니까?,x &= ~(1 << 2);,x &= ~(1 << 2);,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Write a function that calculates the Hamming distance.,해밍 거리를 계산하는 함수를 작성하세요.,"def hamming_distance(x, y):  
    difference = x ^ y
    count = 0
    while difference != 0:
        count += 1
        difference &= difference - 1
    return count","def hamming_distance(x, y):  
    difference = x ^ y
    count = 0
    while difference != 0:
        count += 1
        difference &= difference - 1
    return count",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Write a function to calculate the Hamming weight of an integer. (Kernighan method),정수의 해밍 가중치를 계산하는 함수를 작성하세요. (커니건 방법),"int countSetBits(int n) {
  int count = 0;

  while (n) {
    n = n & (n - 1);
    ++count;
  }

  return count;
}","int countSetBits(int n) {
  int count = 0;

  while (n) {
    n = n & (n - 1);
    ++count;
  }

  return count;
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Write a function that calculates the Hamming weight in constant time. Divide and Conquer strategy.,일정한 시간 내에 해밍 가중치를 계산하는 함수를 작성합니다. 나누기 및 정복 전략.,"int countSetBits(unsigned int n) {
  n = n - ((n >> 1) & 0x55555555);
  n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
  n = (n + (n >> 4)) & 0x0F0F0F0F;
  n = n + (n >> 8);
  n = n + (n >> 16);

  return n & 0x0000003F;
}","int countSetBits(unsigned int n) {
  n = n - ((n >> 1) & 0x55555555);
  n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
  n = (n + (n >> 4)) & 0x0F0F0F0F;
  n = n + (n >> 8);
  n = n + (n >> 16);

  return n & 0x0000003F;
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Write a function that tells you if a number is even, using bitwise operation.",비트 단위 연산을 사용하여 숫자가 짝수인지 알려주는 함수를 작성하세요.,"def is_even(x):
    return x & 1 == 0","def is_even(x):
    return x & 1 == 0",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Write a function to add 2 integers using bitwise operations.,비트 단위 연산을 사용하여 정수 2개를 추가하는 함수를 작성하세요.,"def add(a, b):
    while a:
        c = b & a
        b ^= a
        c <<= 1
        a = c
    return b","def add(a, b):
    while a:
        c = b & a
        b ^= a
        c <<= 1
        a = c
    return b",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Write a function to get the sign of an integer.,정수의 부호를 구하는 함수를 작성하세요.,"def get_sign(x):
    return -(x < 0)","def get_sign(x):
    return -(x < 0)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Write a function to calculate the absolute value of a 32-bit integer.,32비트 정수의 절대값을 계산하는 함수를 작성하세요.,"def myabs(x):
    high_bit_mask = x >> 31
    return (x ^ high_bit_mask) - high_bit_mask","def myabs(x):
    high_bit_mask = x >> 31
    return (x ^ high_bit_mask) - high_bit_mask",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Write a binary search function that works iteratively, taking a target int, array of ints, and size of the array, returning the index of the found item, or -1.","반복적으로 작동하는 이진 검색 함수를 작성하여 목표 인트, 인트 배열, 배열 크기를 가져와서 찾은 항목의 인덱스를 반환하거나 -1을 반환합니다.","int binary_search(int target, int numbers[], int size) {
  int low = 0;
  int high = size - 1;
  int mid = 0;
  while (low <= high) {
    mid = (high + low) / 2;

    if (target > numbers[mid]) {
      low = mid + 1;
    } else if (target < numbers[mid]) {
      high = mid - 1;
    } else {
      return mid;
    }
  }

  return -1;
}","int binary_search(int target, int numbers[], int size) {
  int low = 0;
  int high = size - 1;
  int mid = 0;
  while (low <= high) {
    mid = (high + low) / 2;

    if (target > numbers[mid]) {
      low = mid + 1;
    } else if (target < numbers[mid]) {
      high = mid - 1;
    } else {
      return mid;
    }
  }

  return -1;
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Write a binary search function that works recursively, returning the index of the found item, or -1.",발견된 항목의 인덱스를 반환하는 이진 검색 함수를 재귀적으로 사용하거나 -1로 작성하세요.,"int binary_search_recur(int target, int numbers[], int low, int high) {
  if (low > high) {
    return -1;
  }

  int mid = (high + low) / 2;

  if (target > numbers[mid]) {
    return binary_search_recur(target, numbers, mid + 1, high);
  } else if (target < numbers[mid]) {
    return binary_search_recur(target, numbers, low, mid - 1);
  } else {
    return mid;
  }
}","int binary_search_recur(int target, int numbers[], int low, int high) {
  if (low > high) {
    return -1;
  }

  int mid = (high + low) / 2;

  if (target > numbers[mid]) {
    return binary_search_recur(target, numbers, mid + 1, high);
  } else if (target < numbers[mid]) {
    return binary_search_recur(target, numbers, low, mid - 1);
  } else {
    return mid;
  }
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In C or Python, Write a universal hashing function for a string, taking as arguments a string and the capacity of the hashtable.",C 또는 Python에서 문자열에 대한 범용 해싱 함수를 작성하고 문자열과 해시 테이블의 용량을 인수로 사용합니다.,"int hash(const char* key, const int m) {
  int hash = 0;

  for (int i = 0; i < key[i] != '\0'; ++i) {
    hash = hash * 31 + key[i];
  }

  return abs(hash % m);
}","int hash(const char* key, const int m) {
  int hash = 0;

  for (int i = 0; i < key[i] != '\0'; ++i) {
    hash = hash * 31 + key[i];
  }

  return abs(hash % m);
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Describe the universal hashing function for an integer. What arguments would it need? What would it look like?,정수에 대한 보편 해싱 함수를 설명하세요. 어떤 인수가 필요할까요? 어떤 모습일까요?,"/*
  key = the Key 
  a = random number from 1 to p-1
  b = random number from 0 to p-1
  p = a prime number >=m
  m = the size of the array
*/
int hash(int key, int a, int b, int p, int m) {
  return ((a * x + b) % p) % m;
}","/*
  key = the Key 
  a = random number from 1 to p-1
  b = random number from 0 to p-1
  p = a prime number >=m
  m = the size of the array
*/
int hash(int key, int a, int b, int p, int m) {
  return ((a * x + b) % p) % m;
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a Binary Search Tree?,Binary Search Tree란 무엇인가요?,A binary tree is a data structure where each node has a comparable key and satisfies the restriction that the key in any node is larger than the keys in all nodes in that node's left subtree and smaller than the keys in all nodes in that node's right subtree.,"이진 트리는 각 노드가 비교 가능한 키를 가지고 있으며, 해당 노드의 키가 해당 노드의 왼쪽 하위 트리에 있는 모든 노드의 키보다 크고 해당 노드의 오른쪽 하위 트리에 있는 모든 노드의 키보다 작다는 제한을 만족하는 데이터 구조입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an AVL tree?,AVL Tree란 무엇인가요?,A BST where the height of every node and that of its sibling differ by at most 1.,각 노드의 높이와 형제 노드의 높이가 최대 1씩 다른 BST입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a red-black tree?,Red-Black Tree란 무엇인가요?,"BSTs having red and black links satisfying:
- Red links lean left
- No node has two links connected to it
- The tree has perfect black balance: every path from the root to a null link has the same number of blacks","빨간색과 검은색 링크가 만족하는 BST:
- 빨간색 링크가 왼쪽으로 기울어져 있습니다
- 두 개의 링크가 연결된 노드는 없습니다
- 나무는 완벽한 블랙 밸런스를 가지고 있습니다. 루트에서 널 링크까지의 모든 경로는 동일한 수의 블랙을 가지고 있습니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a splay tree?,플레이 트리란 무엇인가요?,A self-adjusting binary search tree where recently accessed elements are moved to the root so they are quick to access again.,최근에 접근한 요소들이 다시 빠르게 접근할 수 있도록 루트로 이동하는 자동 조정 Binary Search Tree입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a treap?,트랩이란 무엇인가요?,"A random priority is assigned to every key and must maintain two properties:
-They are in order with respect to their keys, as in a typical binary search tree
-They are in heap order with respect to their priorities, that is, no key has a key of lower priority as an ancestor
O(log N) expected time for all operations, O(N) worst case.","모든 키에 무작위 우선순위가 할당되며 두 가지 속성을 유지해야 합니다:
-그들은 일반적인 Binary Search Tree에서처럼 키에 대해 순서대로 배열되어 있습니다
-우선순위에 따라 힙 순서대로 정렬됩니다. 즉, 어떤 키도 우선순위가 낮은 키를 조상으로 사용하지 않습니다
O(로그 N) 모든 작업에 대한 예상 시간, O(N) 최악의 경우.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is typical cache line size?,일반적인 캐시 라인 크기는 무엇인가요?,"64 bytes.

-- extra below --

To know the sizes, you need to look it up using the documentation for the processor, afaik there is no programatic way to do it. On the plus side however, most cache lines are of a standard size, based on intels standards. On x86 cache lines are 64 bytes, however, to prevent false sharing, you need to follow the guidelines of the processor you are targeting (intel has some special notes on its netburst based processors), generally you need to align to 64 bytes for this (intel states that you should also avoid crossing 16 byte boundries).

To do this in C or C++ requires that you use aligned_malloc or one of the compiler specific specifiers such as __attribute__((align(64))) or __declspec(align(64)). To pad between members in a struct to split them onto different cache lines, you need on insert a member big enough to align it to the next 64 byte boundery","64바이트.

-- 아래 추가 --

크기를 알기 위해서는 프로세서에 대한 설명서를 사용하여 이를 확인해야 합니다. 프로그램적인 방법이 없기 때문입니다. 그러나 긍정적인 측면에서는 대부분의 캐시 라인이 인텔 표준에 기반한 표준 크기입니다. 그러나 x86 캐시 라인은 64바이트이지만, 잘못된 공유를 방지하기 위해 목표로 하는 프로세서의 지침을 따라야 합니다(인텔은 넷버스트 기반 프로세서에 몇 가지 특별한 메모를 가지고 있습니다). 일반적으로 이를 위해 64바이트에 맞춰야 합니다(인텔은 16바이트 경계를 넘지 않아야 한다고 명시하고 있습니다).

C 또는 C++에서 이 작업을 수행하려면 aligned_malloc 또는 __attribute_(((align(64)) 또는 __declspec(align(64))과 같은 컴파일러 특정 지정자 중 하나를 사용해야 합니다. 구조 내의 구성원들 사이를 다른 캐시 라인으로 분할하기 위해 패드를 사용하려면, 다음 64바이트 바운더리에 정렬할 수 있을 만큼 큰 구성원을 삽입해야 합니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is latency?,지연 시간이란 무엇인가요?,Latency is the delay from input into a system to desired outcome. The time interval between between a stimulus and response.,지연 시간은 시스템 입력에서 원하는 결과로 지연되는 시간을 말합니다. 자극과 반응 사이의 시간 간격입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a y-fast trie?,Y-패스트 트라이란 무엇인가요?,"A y-fast trie is a data structure for storing integers from a bounded domain. It supports exact and predecessor or successor queries in time O(log log M), using O(n) space, where n is the number of stored values and M is the maximum value in the domain. The structure was proposed by Dan Willard in 1982 to decrease the O(n log M) space used by an x-fast trie.","y-패스트 트라이는 유한한 도메인에서 정수를 저장하기 위한 데이터 구조입니다. 이 구조는 O(log log M) 시간 내에 정확한 쿼리와 이전 쿼리 또는 후속 쿼리를 지원하며, 여기서 n은 저장된 값의 수이고 M은 도메인의 최대값입니다. 이 구조는 1982년 댄 윌라드에 의해 x-패스트 트라이가 사용하는 O(n log M) 공간을 줄이기 위해 제안되었습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an x-fast trie?,엑스패스트 트라이란 무엇인가요?,"An x-fast trie is a data structure for storing integers from a bounded domain. It supports exact and predecessor or successor queries in time O(log log M), using O(n log M) space, where n is the number of stored values and M is the maximum value in the domain. The structure was proposed by Dan Willard in 1982, along with the more complicated y-fast trie, as a way to improve the space usage of van Emde Boas trees, while retaining the O(log log M) query time.","x-패스트 트라이(x-fast trie)는 유한한 도메인에서 정수를 저장하기 위한 데이터 구조입니다. 이 구조는 O(n log M) 공간을 사용하여 O(log log M) 시간 내에 정확한 쿼리와 이전 쿼리 또는 후속 쿼리를 지원합니다. 여기서 n은 저장된 값의 수이고 M은 도메인의 최대값입니다. 이 구조는 1982년 댄 윌라드(Dan Willard)에 의해 제안되었으며, 더 복잡한 y-패스트 트라이와 함께 반 엠데 보아스 트리의 공간 사용을 개선하면서 O(log log M) 쿼리 시간을 유지하기 위한 방법입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a van Emde Boas tree?,반 엠데 보아스 나무란 무엇인가요?,"The van Emde Boas tree supports insertions, deletions, lookups, successor queries, and predecessor queries in time O(log log U), where U is the universe of items to store. Items are stored in clusters of size sqrt(U). 

The van Emde Boas data structure divides the range {0,...,n−1} into blocks of size sqrt(n), which we call clusters. Each cluster is itself a vEB structure of size sqrt(n). In addition, there is a “summary” structure that keeps track of which clusters are nonempty.

More detail:
A van Emde Boas tree (or van Emde Boas priority queue), also known as a vEB tree, is a tree data structure which implements an associative array with m-bit integer keys. It performs all operations in O(log m) time, or equivalently in O(log log M) time, where M = 2m is the maximum number of elements that can be stored in the tree. The M is not to be confused with the actual number of elements stored in the tree, by which the performance of other tree data-structures is often measured. The vEB tree has good space efficiency when it contains a large number of elements, as discussed below. It was invented by a team led by Dutch computer scientist Peter van Emde Boas in 1975.","The van Emde Boas tree supports insertions, deletions, lookups, successor queries, and predecessor queries in time O(log log U), where U is the universe of items to store. Items are stored in clusters of size sqrt(U). 

The van Emde Boas data structure divides the range {0,...,n−1} into blocks of size sqrt(n), which we call clusters. Each cluster is itself a vEB structure of size sqrt(n). In addition, there is a “summary” structure that keeps track of which clusters are nonempty.

More detail:
A van Emde Boas tree (or van Emde Boas priority queue), also known as a vEB tree, is a tree data structure which implements an associative array with m-bit integer keys. It performs all operations in O(log m) time, or equivalently in O(log log M) time, where M = 2m is the maximum number of elements that can be stored in the tree. The M is not to be confused with the actual number of elements stored in the tree, by which the performance of other tree data-structures is often measured. The vEB tree has good space efficiency when it contains a large number of elements, as discussed below. It was invented by a team led by Dutch computer scientist Peter van Emde Boas in 1975.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a compressed trie?,압축 트라이란 무엇인가요?,It's a trie where the non-branching paths are compacted into a single edge.,비가지 경로가 하나의 가장자리로 압축된 트라이입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What relationship of the keys do you lose with a hash table?,해시 테이블에서는 어떤 키의 관계를 잃나요?,The ordering of the keys.,열쇠의 순서.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Sed command to take a file separated by spaces, turn spaces into newlines, and then sort it alphabetically.",공백으로 구분된 파일을 새 줄로 변환한 다음 알파벳순으로 정렬하라는 명령입니다.,sed 's/ /\n/g' words.txt | sort,sed's/ /\n/g'words.txt | 정렬,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Print columns 2, 3, and 6 from the date command.","Print columns 2, 3, and 6 from the date command.","date | awk '{print $2, $3, $6}'","date | awk '{print $2, $3, $6}'",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Take a file delimited by : and make it tab-delimited.,파일을 :로 구분하여 탭 구분으로 만듭니다.,cat /etc/passwd | sed 's/:/\t/g',고양이 /etc/passwd | sed 's/:/\\t/g',CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Output a file with line numbers.,줄 번호가 있는 파일을 출력합니다.,cat -n somefile,고양이 -n 썸파일,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is quicksort stable?,퀵소트는 안정적인가요?,No.,아니요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Can quicksort be done in-place?,퀵소트를 제자리에서 할 수 있나요?,Yes.,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Can merge sort be done in-place?,Merge Sort을 제자리에서 수행할 수 있나요?,No. It requires O(n) space. There is an in-place version?,아니요. O(n) 공간이 필요합니다. 제자리 버전이 있나요?,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is merge sort stable?,Merge Sort이 안정적인가요?,Yes.,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is insertion sort stable?,Insertion Sort이 안정적인가요?,Yes.,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Can insertion sort be done in-place?,Insertion Sort을 제자리에서 할 수 있나요?,Yes.,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Can selection sort be done in-place?,Selection Sort을 제자리에서 할 수 있나요?,Yes.,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is selection sort stable?,선택 항목이 안정적인가요?,No.,아니요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is heap sort stable?,Heap Sort은 안정적인가요?,No.,아니요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Can heap sort be done in-place?,Heap Sort을 제자리에서 할 수 있나요?,Yes.,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Write merge sort in C (check answer carefully),Merge Sort을 C로 작성합니다(답변을 주의 깊게 확인하세요),"void merge(int numbers[], int low, int mid, int high) {
  // temp array for holding sorted items
  int b[high - low - 1];
  int i = low;
  int j = mid + 1;
  int k = 0;

  // merge items from list in order
  while (i <= mid && j <= high) {
    if (numbers[i] <= numbers[j]) {
      b[k++] = numbers[i++];
    } else {
      b[k++] = numbers[j++];
    }
  }

  // copy the remaining items to tmp array
  while (i <= mid) b[k++] = numbers[i++];
  while (j <= high) b[k++] = numbers[j++];

  --k;
  while (k >= 0) {
    numbers[low + k] = b[k];
    --k;
  }
}

void merge_sort(int numbers[], int low, int high) {
  if (low < high) {
    int mid = (low + high) / 2;

    merge_sort(numbers, low, mid);
    merge_sort(numbers, mid + 1, high);
    merge(numbers, low, mid, high);
  }
}","void merge(int numbers[], int low, int mid, int high) {
  // temp array for holding sorted items
  int b[high - low - 1];
  int i = low;
  int j = mid + 1;
  int k = 0;

  // merge items from list in order
  while (i <= mid && j <= high) {
    if (numbers[i] <= numbers[j]) {
      b[k++] = numbers[i++];
    } else {
      b[k++] = numbers[j++];
    }
  }

  // copy the remaining items to tmp array
  while (i <= mid) b[k++] = numbers[i++];
  while (j <= high) b[k++] = numbers[j++];

  --k;
  while (k >= 0) {
    numbers[low + k] = b[k];
    --k;
  }
}

void merge_sort(int numbers[], int low, int high) {
  if (low < high) {
    int mid = (low + high) / 2;

    merge_sort(numbers, low, mid);
    merge_sort(numbers, mid + 1, high);
    merge(numbers, low, mid, high);
  }
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Write a MergeSort class in Python (check answer carefully),Python으로 MergeSort 클래스 작성하기(답변을 주의 깊게 확인하세요),"class MergeSort(object):
    def __init__(self, numbers):
        self.values = numbers
        self.count = len(numbers)

    def sort(self):
        self.merge_sort(0, self.count - 1)
        return self.values

    def merge_sort(self, low, high):
        if low < high:
            mid = (low + high) // 2

            self.merge_sort(low, mid)
            self.merge_sort(mid + 1, high)
            self.merge(low, mid, high)

    def merge(self, low, mid, high):
        b = []
        i = low
        j = mid + 1

        while i <= mid and j <= high:
            if self.values[i] <= self.values[j]:
                b.append(self.values[i])
                i += 1
            else:
                b.append(self.values[j])
                j += 1

        while i <= mid:
            b.append(self.values[i])
            i += 1

        while j <= high:
            b.append(self.values[j])
            j += 1

        for index, val in enumerate(b):
            self.values[low + index] = val","class MergeSort(object):
    def __init__(self, numbers):
        self.values = numbers
        self.count = len(numbers)

    def sort(self):
        self.merge_sort(0, self.count - 1)
        return self.values

    def merge_sort(self, low, high):
        if low < high:
            mid = (low + high) // 2

            self.merge_sort(low, mid)
            self.merge_sort(mid + 1, high)
            self.merge(low, mid, high)

    def merge(self, low, mid, high):
        b = []
        i = low
        j = mid + 1

        while i <= mid and j <= high:
            if self.values[i] <= self.values[j]:
                b.append(self.values[i])
                i += 1
            else:
                b.append(self.values[j])
                j += 1

        while i <= mid:
            b.append(self.values[i])
            i += 1

        while j <= high:
            b.append(self.values[j])
            j += 1

        for index, val in enumerate(b):
            self.values[low + index] = val",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Write quick sort in C with only one method and random pivot (check answer carefully),하나의 메서드와 무작위 피벗만으로 C로 빠른 정렬을 작성하세요(답변을 주의 깊게 확인하세요),"void quick_sort(int numbers[], int left, int right) {

  if (left == right)
    return;

  int i = left;
  int j = right;
  int temp = 0;

  int count = right - left;
  int pivot_mod = rand() % count;

  int pivot = numbers[left + pivot_mod];

  while (i <= j) {
    while (numbers[i] < pivot) ++i;
    while (numbers[j] > pivot) --j;

    if (i <= j) {
      temp = numbers[i];
      numbers[i] = numbers[j];
      numbers[j] = temp;
      ++i;
      --j;
    }
  }

  if (left < j) {
    quick_sort(numbers, left, j);
  }

  if (right > i) {
    quick_sort(numbers, i, right);
  }
}","void quick_sort(int numbers[], int left, int right) {

  if (left == right)
    return;

  int i = left;
  int j = right;
  int temp = 0;

  int count = right - left;
  int pivot_mod = rand() % count;

  int pivot = numbers[left + pivot_mod];

  while (i <= j) {
    while (numbers[i] < pivot) ++i;
    while (numbers[j] > pivot) --j;

    if (i <= j) {
      temp = numbers[i];
      numbers[i] = numbers[j];
      numbers[j] = temp;
      ++i;
      --j;
    }
  }

  if (left < j) {
    quick_sort(numbers, left, j);
  }

  if (right > i) {
    quick_sort(numbers, i, right);
  }
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Write a QuickSort class in Python (check answer carefully),QuickSort 클래스를 Python으로 작성합니다(답변을 주의 깊게 확인하세요),"import random

class QuickSort(object):

    def __init__(self, numbers):
        self.values = numbers
        self.count = len(self.values)

    def sort(self):
        self.quick_sort(0, self.count - 1)
        return self.values

    def quick_sort(self, left, right):
        if left == right:
            return

        i = left
        j = right

        pivot_index = random.randint(left, right)

        pivot = self.values[pivot_index]

        while i <= j:
            while self.values[i] < pivot:
                i += 1
            while self.values[j] > pivot:
                j -= 1
            if i <= j:
                if i < j:
                    temp = self.values[i]
                    self.values[i] = self.values[j]
                    self.values[j] = temp
                i += 1
                j -= 1

        if left < j:
            self.quick_sort(left, j)
        if right > i:
            self.quick_sort(i, right)","import random

class QuickSort(object):

    def __init__(self, numbers):
        self.values = numbers
        self.count = len(self.values)

    def sort(self):
        self.quick_sort(0, self.count - 1)
        return self.values

    def quick_sort(self, left, right):
        if left == right:
            return

        i = left
        j = right

        pivot_index = random.randint(left, right)

        pivot = self.values[pivot_index]

        while i <= j:
            while self.values[i] < pivot:
                i += 1
            while self.values[j] > pivot:
                j -= 1
            if i <= j:
                if i < j:
                    temp = self.values[i]
                    self.values[i] = self.values[j]
                    self.values[j] = temp
                i += 1
                j -= 1

        if left < j:
            self.quick_sort(left, j)
        if right > i:
            self.quick_sort(i, right)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
In what case would perfect hashing be practical?,어떤 경우에 완벽한 해싱이 실용적일까요?,When you don't need to support inserts or deletes. The data is static.,삽입이나 삭제를 지원할 필요가 없을 때. 데이터는 정적입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does perfect hashing handle collisions?,완벽한 해싱은 충돌을 어떻게 처리하나요?,"It creates a second hash table in the buckets where there are multiple items (k), using a second hash function, and k^2 space. The hash table has two hashing levels. k^2 is chosen because the Markov inequality (birthday paradox) ensures we will not have collisions in bucket.",두 번째 해시 함수와 k^2 공간을 사용하여 여러 항목(k)이 있는 버킷에 두 번째 해시 테이블을 생성합니다. 해시 테이블에는 두 가지 해시 레벨이 있습니다. k^2는 마르코프 부등식(생일 역설)이 버킷에서 충돌이 발생하지 않도록 보장하기 때문에 선택됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the optimal load factor for a hash table?,해시 테이블의 최적 부하 계수는 무엇인가요?,O(sqrt(n)),O(sqrt(n)),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the expected load factor for a hash table?,해시 테이블의 예상 부하 계수는 얼마인가요?,"n/m,  where n = items, m = buckets) n/m is also called alpha.","n/m, 여기서 n = 항목, m = 버킷) n/m은 알파라고도 불립니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the technical running time for operations on a hash table?,해시 테이블에서 작업의 기술적 실행 시간은 어떻게 되나요?,"O(1 + alpha), where alpha is the load factor (n/m). Table doubling operations are amortized.","O(1 + alpha), 여기서 alpha는 하중 계수(n/m)입니다. 테이블 더블링 연산은 상각됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the worst-case search time of perfect hashing?,완벽한 해싱의 최악의 검색 시간은 언제인가요?,O(1),O(1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the worst-case space required for perfect hashing?,완벽한 해싱을 위해 필요한 최악의 공간은 무엇인가요?,O(n),O(n),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the best-case running time of binary search?,이진 검색의 가장 좋은 실행 시간은 언제인가요?,O(1) - we get lucky and find the element right at the midpoint.,O(1) - 운이 좋게도 중간 지점에서 요소를 찾습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the worst-case running time of binary search?,이진 검색의 최악의 실행 시간은 언제인가요?,O(log n),O(로그 n),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the downsides of using an adjacency matrix to represent a graph?,인접 행렬을 사용하여 그래프를 표현하는 것의 단점은 무엇인가요?,"Finding all the outgoing edges from a vertex takes O(n) time even if there aren't very many, and the O(n^2) space cost is high for ""sparse graphs,"" those with much fewer than n^2 edges.","정점에서 나가는 모든 간선을 찾는 데는 O(n) 시간이 걸리고, n^2보다 훨씬 적은 간선을 가진 ""희소 그래프""의 경우 O(n^2) 공간 비용이 높습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
When is using an adjacency list expensive?,인접 목록을 사용하는 것은 언제 비용이 많이 드나요?,"Finding predecessors of a node u is extremely expensive, requiring looking through every list of every node in time O(n + e), where e is the total number of edges, although if this is something we actually need to do often we can store a second copy of the graph with the edges reversed.","노드 u의 이전 노드를 찾는 것은 매우 비용이 많이 들기 때문에 O(n + e) 시간 내에 모든 노드 목록을 살펴봐야 합니다. 여기서 e는 총 엣지 수를 의미하지만, 실제로 자주 해야 하는 작업이라면 엣지가 반전된 두 번째 그래프 사본을 저장할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
When are adjacency lists most useful?,인접 목록은 언제 가장 유용하나요?,"Adjacency lists are most useful when we mostly want to enumerate outgoing edges of each node. This is common in search tasks, where we want to find a path from one node to another or compute the distances between pairs of nodes. If other operations are important, we can optimize them by augmenting the adjacency list representation; for example, using sorted arrays for the adjacency lists reduces the cost of edge existence testing to O(log(d+ (u))), and adding a second copy of the graph with reversed edges lets us find all predecessors of u in O(d− (u)) time, where d− (u) is u's in-degree.","인접 목록은 주로 각 노드의 나가는 간선을 열거하고자 할 때 가장 유용합니다. 이는 한 노드에서 다른 노드로 가는 경로를 찾거나 노드 쌍 간의 거리를 계산하는 검색 작업에서 흔히 볼 수 있습니다. 다른 작업이 중요한 경우 인접 목록 표현을 보강하여 최적화할 수 있습니다. 예를 들어, 인접 목록에 정렬된 배열을 사용하면 간선 존재 테스트 비용을 O(log(d+(u))로 줄이고, 간선이 반대인 그래프의 두 번째 복사본을 추가하면 O(d-(u)) 시간 내에 u의 모든 선행 변수를 찾을 수 있습니다. 여기서 d-(u)는 u의 차수입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the space required for a graph using an adjacency list?,인접 목록을 사용하는 그래프에 필요한 공간은 무엇인가요?,O(n + e),O(n + e),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the maximum unsigned number you can represent with 4 bits?,4비트로 표현할 수 있는 최대 부호 없는 숫자는 얼마인가요?,15,15,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the maximum unsigned number you can represent with 8 bits?,8비트로 표현할 수 있는 최대 부호 없는 숫자는 얼마인가요?,255,255,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the maximum unsigned number you can represent with 16 bits?,16비트로 표현할 수 있는 최대 부호 없는 숫자는 얼마인가요?,"65,535","65,535",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the maximum unsigned number you can represent with 6 bits?,6비트로 표현할 수 있는 최대 부호 없는 숫자는 얼마인가요?,63,63,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the maximum unsigned number you can represent with 15 bits?,15비트로 표현할 수 있는 최대 부호 없는 숫자는 얼마인가요?,"32,767","32,767",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the maximum signed number you can represent with 4 bits?,4비트로 표현할 수 있는 최대 부호 수는 얼마인가요?,7,7,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the maximum signed number you can represent with 16 bits?,16비트로 표현할 수 있는 최대 부호 수는 얼마인가요?,"32,767","32,767",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the maximum signed number you can represent with 8 bits?,8비트로 표현할 수 있는 최대 부호 수는 얼마인가요?,127,127,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the maximum signed number you can represent with 9 bits?,9비트로 표현할 수 있는 최대 부호 수는 얼마인가요?,255,255,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the maximum unsigned number you can represent with 32 bits?,32비트로 표현할 수 있는 최대 부호 없는 숫자는 얼마인가요?,4.294 Billion,"42억 9,400만",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the maximum signed number you can represent with 32 bits?,32비트로 표현할 수 있는 최대 부호 수는 얼마인가요?,2.147 Billion,"21억 4,700만",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How do you get the logarithm of a number n given a base b?,밑 b가 주어졌을 때 숫자 n의 로그는 어떻게 구할 수 있나요?,Keep dividing n by b until you get to a number <= 1.,숫자 <= 1이 될 때까지 n을 b로 계속 나눕니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you write log(base b)(ac)?,log(base b)(ac)는 어떻게 쓸 수 있나요?,log(base b)a + log(base b)c,log(base b)a + log(base b)c,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you write log(base b)(a/c)?,log(base b)(a/c)를 어떻게 쓸 수 있나요?,log(base b)a - log(base b)c,log(base b)a - log(base b)c,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How else can you write log(base b)(a^c)?,다른 방법으로 log(base b)(a^c)를 쓸 수 있나요?,c * log(base b)a,c * log(base b)a,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How you can express log(base b)a as another base?,log(base b)a를 다른 베이스로 어떻게 표현할 수 있나요?,log(base d)a / log(base d)b,log(base d)a / log(base d)b,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Why is log(base2)(2^n) == n?,Why is log(base2)(2^n) == n?,log(base2)(2^n) = n * log(base 2)2 = n * 1 = n,log(base2)(2^n) = n * log(base 2)2 = n * 1 = n,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the arithmetic series: 1 + 2 + 3 + 4 + ... (n - 1) + n?,산술 급수란 무엇인가요? 1 + 2 + 3 + 4 + ... (n - 1) + n?,(n(n+1)) / 2,(n(n+1)) / 2,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the value of the geometric (exponential) series when x != 1: 1 + x + x^2 + x^3 + ... x^n ?,x!= 1: 1 + x + x^2 + x^3 + ... x^n일 때 기하급수의 값은 얼마입니까?,(x^(n + 1) - 1) / (x - 1),(x^(n + 1) - 1) / (x - 1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the sum of this series when it's infinite and x < 1? 1 + x + x^2 + x^3 + ... x^n ?,이 급수가 무한이고 x < 1일 때의 합은 얼마인가요? 1 + x + x^2 + x^3 + ... x^n?,1 / (1 - x),1 / (1 - x),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the sum of the harmonic series for the nth harmonic number: 1 + 1/2 + 1/3 + 1/4 .. + 1/n,n번째 조화수에 대한 조화급수의 합은 얼마입니까? 1 + 1/2 + 1/3 + 1/4 .... + 1/n,"No closed form, only good approximations:

≈ 0.57721
the Euler-Mascheroni constant.","닫힌 형식은 없고, 좋은 근사치만 있습니다:

≈ 0.57721
오일러-마스케로니 상수.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the maximum unsigned integer you can represent with n bits?,n비트로 표현할 수 있는 최대 부호 없는 정수는 얼마인가요?,2^n - 1,2^n - 1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Given a fully balanced binary tree with x nodes, what is the height of the tree in nodes?","x개의 노드가 있는 완전히 균형 잡힌 이진 트리가 주어졌을 때, 노드에서 트리의 높이는 얼마인가요?",log(base2) x + 1,log(base2) x + 1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Given a fully balanced k-ary tree with x nodes, what is the height of the tree in nodes?","x개의 노드가 있는 완전히 균형 잡힌 k-진 트리가 주어졌을 때, 노드에서 트리의 높이는 얼마인가요?",log(basek) x + 1,log(basek) x + 1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
A binary tree with height h can contain at most how many nodes?,높이가 h인 이진 트리는 최대 몇 개의 노드를 포함할 수 있나요?,2^(h+1) − 1 nodes,2^(h+1) − 1 nodes,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"For a k-ary tree with height h, the upper bound for the maximum number of leaves is:",높이가 h인 k-ary 트리의 경우 최대 잎 수에 대한 상한은 다음과 같습니다:,k^h,k^h,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the complexity of Dijkstra's shortest-path algorithm?,다이크스트라의 최단 경로 알고리즘의 복잡성은 무엇인가요?,"O(e log v), where e is the number of edges. 
It must scan each edge, and gets and updates values on the heap.","O(e 로그 v), 여기서 e는 간선의 수입니다. 
각 가장자리를 스캔하고 힙의 값을 가져와 업데이트해야 합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a drawback of using an adjacency matrix for an undirected graph?,무방향 그래프에 인접 행렬을 사용하는 것의 단점은 무엇인가요?,Half of the entries in the matrix are duplicates.,행렬의 항목 중 절반이 중복됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the memory needed to store an adjacency list?,인접 목록을 저장하는 데 필요한 메모리는 무엇인가요?,Theta( |V| + |E| ),세타( |V| + |E| ),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the memory needed to store an adjacency matrix?,인접 행렬을 저장하는 데 필요한 메모리는 무엇인가요?,Theta(|V|^2),세타(|V|^2),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How would you implement a queue with a linked list?,링크된 목록으로 대기열을 어떻게 구현하시겠습니까?,"Use a tail pointer. Push new items at the tail, pop items at the head. Both operations are constant-time.",꼬리 포인터를 사용합니다. 꼬리에서 새 항목을 밀고 머리에서 항목을 터뜨립니다. 두 작업 모두 일정한 시간 동안 진행됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How would you implement a stack with a linked list?,링크된 목록이 있는 스택을 어떻게 구현하시겠습니까?,Push and pop items at the head. Both operations are constant-time.,머리에 물건을 밀고 터뜨립니다. 두 작업 모두 일정한 시간 동안 진행됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What preference of nodes vs leaves does preorder traversal give on a tree?,사전 주문 트래버스가 트리에 제공하는 노드와 잎의 선호도는 무엇인가요?,"Nodes first, leaves later.","노드가 먼저 있고, 나중에 떠납니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What preference of nodes vs leaves does postorder traversal give on a tree?,포스트오더 트래버스가 트리에 주는 노드와 잎의 선호도는 무엇인가요?,"Leaves first, internal nodes later.","먼저 떠나고, 내부 노드는 나중에 떠납니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What could you use in DFS to turn a recursive algorithm into an interative one?,DFS에서 재귀 알고리즘을 상호작용 알고리즘으로 변환하는 데 무엇을 사용할 수 있나요?,A stack.,스택.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What do you use to keep track of nodes to visit in BFS?,BFS에서 방문할 노드를 추적하려면 무엇을 사용하나요?,A queue.,대기열.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Using a stack to keep track of unvisited nodes gives what kind of traversal?,스택을 사용하여 방문하지 않은 노드를 추적하면 어떤 종류의 탐색이 가능할까요?,DFS,DFS,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Using a queue to keep track of unvisited nodes gives what kind of traversal?,방문하지 않은 노드를 추적하기 위해 대기열을 사용하면 어떤 종류의 이동 경로가 제공되나요?,BFS,BFS,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In a highly connected graph of n vertices, how many cycles can there be?",n개의 정점으로 이루어진 고도로 연결된 그래프에서 사이클은 몇 개일 수 있나요?,"(n - 1)! - enumerating is possible (using backtracking), but there will be a lot.","(n - 1)! - 역추적을 사용하여 열거하는 것은 가능하지만, 많을 것입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What can use to find if a graph is bipartite?,그래프가 이분형인 경우 무엇을 사용하여 찾을 수 있나요?,"BFS. Using only 2 colors. When you encounter a new vertex, if it has no color, give it the opposite color of its parent vertex. If it is already colored the same, the graph is not bipartite.",BFS. 두 가지 색상만 사용합니다. 새 정점을 만나면 색상이 없는 경우 부모 정점의 반대 색상을 지정합니다. 이미 동일한 색상으로 표시되어 있다면 그래프는 이분법적이지 않습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you find a cycle in a graph?,그래프에서 주기를 어떻게 찾을 수 있나요?,"DFS. If you discover an edge that connects to an ancestor (previously discovered vertex), you have a cycle.",DFS. 이전에 발견된 정점(이전에 발견된 정점)에 연결된 간선을 발견하면 주기가 생깁니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an articulation vertex?,관절 정점이란 무엇인가요?,A vertex of a graph whose deletion disconnects the graph.,삭제가 그래프를 분리하는 그래프의 정점입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you find an articulation vertex?,관절 정점을 어떻게 찾을 수 있나요?,"DFS multiple times. Remove each edge one at a time, doing a DFS after each, so see if you end up with > 1 connected components. If you remove a node and then DFS and find you have fewer than m - 1 edges, you've deleted an articulation vertex. O(n(n+m))

A faster way, with a little more bookkeeping, can be done in O(n+m) time, if you do DFS and keep track of parents and make a note when you reach a back edge, which connects to an ancestor.","DFS를 여러 번 반복합니다. 각 엣지를 하나씩 제거하고, 각 엣지마다 DFS를 수행하여 1개 이상의 연결된 구성 요소가 있는지 확인합니다. 노드를 제거한 다음 DFS를 사용하여 m - 1개 미만의 엣지를 발견하면, 아티큘레이션 버텍스를 삭제한 것입니다. O(n(n+m))

DFS를 수행하고 부모를 추적하며 조상과 연결되는 백 엣지에 도달하면 메모를 작성하면 조금 더 많은 부기를 통해 O(n+m) 시간 내에 더 빠른 방법을 사용할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"How could you identify errors in a DNA fragment assembly given many pairs of sequences, where item A must appear before B in the larger sequence?","더 큰 서열에서 항목 A가 B 앞에 나타나야 하는 많은 서열 쌍이 주어졌을 때, DNA 단편 어셈블리의 오류를 어떻게 식별할 수 있을까요?","Build a DAG representing all the left-right constraints. Any topological sort of the DAG is a consistent ordering. If there are cycles, there must be errors.",모든 좌우 제약 조건을 나타내는 DAG를 구축합니다. 모든 토폴로지 유형의 DAG는 일관된 순서입니다. 주기가 있는 경우 오류가 있어야 합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What path does BFS find in a graph?,BFS는 그래프에서 어떤 경로를 찾나요?,The shortest path tree from start to all nodes (unweighted),시작부터 모든 노드까지의 최단 경로 트리(가중치 없음),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What's the upper bound on the number of edges in a graph G(V, E)?","그래프 G(V, E)의 간선 수에 대한 상한은 얼마인가요?",|V|^2,|V|^2,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In Python, initialize a list of lists called x with 100 elements.",파이썬에서 100개의 원소로 구성된 x라는 목록을 초기화합니다.,x = [[] for i in range(100)],x = [[] for i in range(100)],CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In Python, declare a named tuple called Edge, with attributes vertex and weight.",Python에서 정점과 가중치 속성을 가진 이름 있는 튜플인 Edge를 선언합니다.,"from collections import namedtuple

Edge = namedtuple('Edge', ['vertex', 'weight'])","from collections import namedtuple

Edge = namedtuple('Edge', ['vertex', 'weight'])",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the optimal substructure property tell us about shortest paths?,최단 경로에 대해 알려주는 최적의 하부 구조 속성은 무엇인가요?,That a subpath of a shortest path is also a shortest path.,가장 짧은 경로의 하위 경로도 가장 짧은 경로입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
C++: How would you initialize a vector of 25 integers to all zeroes?,C++: 25개의 정수 벡터를 모든 0으로 어떻게 초기화하시겠습니까?,std::vector<int> mynums(25);,std::vector<int> mynums(25);,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
C++: How could you make a string called thing2 have the first 5 characters of thing1?,C++: thing2라는 문자열에 처음 5자의 thing1을 어떻게 만들 수 있나요?,"thing2.assign(thing1, 0, 5);","thing2.assign(thing1, 0, 5);",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"C++: We want to call parent constructor in our MyClass constructor, with an arg int called foo. What does this look like in .h and .cc? Parent is ParentClass.",C++: 우리는 MyClass 생성자에서 부모 생성자를 호출하고 싶습니다. argint는 foo라고 합니다. .h와 .cc에서는 이것이 어떻게 보이나요? 부모는 부모 클래스입니다.,".h:
MyClass(const int foo);

.cc:
MyClass::MyClass(const int foo) : ParentClass(foo) {
    // stuff
}",".h:
MyClass(const int foo);

.cc:
MyClass::MyClass(const int foo) : ParentClass(foo) {
    // stuff
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a Dunder method?,던더 방식이란 무엇인가요?,"A magic method in Python, such as __getitem__ and __len__.","파이썬의 마법 방법, 예를 들어 __getitem__ 및 __len__.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the sum of numbers from 1 to 2^n?,1에서 2^n까지의 숫자의 합은 무엇인가요?,"2^(n+1) - 1
The sum of a sequence of powers is roughly equal to the next value in the sequence.","2^(n+1) - 1
일련의 거듭제곱의 합은 대략 그 수열의 다음 값과 같습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many ways can you rearrange a string of n unique characters?,n개의 고유 문자 문자열을 몇 가지 방법으로 재배열할 수 있나요?,"n!
Permutations.","n!
순열.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many ways can you arrange k characters from n unique characters?,n개의 고유 문자 중 k개의 문자를 배열하는 방법은 몇 가지가 있나요?,"n! / (n - k)!
Permutation of n elements of size k.","n! / (n - k)!
크기 k의 n개 원소의 순열.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many subsets (ordering doesn't matter) of size k are there in n unique characters?,n개의 고유 문자에 크기 k의 하위 집합(순서는 상관없습니다)이 몇 개 있나요?,"n! / k!(n - k)!
This is n choose k.","n! / k!(n - k)!
이것은 n 선택 k입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Python: Write a class function to tell if the graph is bipartite. Start with vertex 0. You can access the adjacency list for a vertex v with: self.adjacency_list[v],Python: Write a class function to tell if the graph is bipartite. Start with vertex 0. You can access the adjacency list for a vertex v with: self.adjacency_list[v],"def is_bipartite(self):
        """"""
        Returns true if graph is bipartite
        :rtype: bool
        """"""
        colorings = {}
        to_visit = queue.Queue()
        to_visit.put(0)
        colorings[0] = 0

        while not to_visit.empty():
            v = to_visit.get()

            for u in self.adjacency_list[v]:
                if u not in colorings:
                    colorings[u] = 1 - colorings[v]
                    to_visit.put(u)
                elif colorings[u] == colorings[v]:
                    return False

        return True","def is_bipartite(자체):
        """"""
        그래프가 이분형인 경우 참을 반환합니다
        :rtype: bool
        """"""
        색칠하기 = {}
        to_visit = 큐.큐()
        to_visit.put(0)
        색칠하기[0] = 0

        visit.empty ():
            v = to_visit.get ()

            당신을 위해: self.adjacency_list[v]:
                색칠이 아니라면:
                    색칠하기[u] = 1 - 색칠하기[v]
                    to_visit.put(u)
                엘프 색칠하기 == 색칠하기 [v]:
                    거짓 반환

        참으로 반환",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What should you avoid in your base case in recursion?,재귀 시 기본 케이스에서 피해야 할 것은 무엇인가요?,"Too many base case scenarios. Just have one base case so you can return as quickly as possible. Avoid ""arm's length"" recursion.","Too many base case scenarios. Just have one base case so you can return as quickly as possible. Avoid ""arm's length"" recursion.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the bandwidth of a graph?,그래프의 대역폭은 얼마인가요?,The longest edge in the permutation that gives you the shortest edges.,가장 짧은 간선을 제공하는 순열에서 가장 긴 변입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"When talking dynamic programming, what is feasibility?",동적 프로그래밍에 대해 이야기할 때 실현 가능성이란 무엇인가요?,The rules the algorithm must adhere to in reaching its solution.,알고리즘이 해결책에 도달하기 위해 준수해야 하는 규칙.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"When talking dynamic programming, what is optimality?",동적 프로그래밍에 대해 이야기할 때 최적성이란 무엇인가요?,An algorithm has optimality if the subsolutions of an optimal solution of the problem are themsleves optimal solutions for their subproblems.,알고리즘은 문제의 최적 해의 부분 해가 그들의 부분 문제에 대한 최적 해일 때 최적성을 갖습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is dynamic programming?,동적 프로그래밍이란 무엇인가요?,"Dynamic programming is a general-purpose algorithm design technique that is most often used to solve combinatorial optimization problems, where we are looking for the best possible input to some function chosen from an exponentially large search space.

There are two parts to dynamic programming. The first part is a programming technique: dynamic programming is essentially divide and conquer run in reverse: we solve a big instance of a problem by breaking it up recursively into smaller instances; but instead of carrying out the computation recursively from the top down, we start from the bottom with the smallest instances of the problem, solving each increasingly large instance in turn and storing the result in a table. The second part is a design principle: in building up our table, we are careful always to preserve alternative solutions we may need later, by delaying commitment to particular choices to the extent that we can.

The bottom-up aspect of dynamic programming is most useful when a straightforward recursion would produce many duplicate subproblems. It is most efficient when we can enumerate a class of subproblems that doesn't include too many extraneous cases that we don't need for our original problem.","동적 프로그래밍은 조합 최적화 문제를 해결하는 데 가장 자주 사용되는 범용 알고리즘 설계 기법으로, 기하급수적으로 큰 검색 공간에서 선택한 함수에 최적의 입력을 찾습니다.

동적 프로그래밍에는 두 가지 부분이 있습니다. 첫 번째 부분은 프로그래밍 기법입니다: 동적 프로그래밍은 본질적으로 역방향으로 실행되는 분할 및 정복입니다: 우리는 문제의 큰 인스턴스를 작은 인스턴스로 재귀적으로 분해하여 해결하지만, 계산을 위에서 아래로 재귀적으로 수행하는 대신, 문제의 가장 작은 인스턴스부터 시작하여 점점 더 큰 인스턴스를 차례로 해결하고 결과를 표에 저장합니다. 두 번째 부분은 설계 원칙입니다: 테이블을 구축할 때, 우리는 가능한 한 특정 선택에 대한 약속을 지연시킴으로써 나중에 필요할 수 있는 대체 솔루션을 항상 보존하도록 주의합니다.

동적 프로그래밍의 상향식 측면은 간단한 재귀를 통해 많은 중복 하위 문제를 생성할 때 가장 유용합니다. 원래 문제에 필요하지 않은 불필요한 경우가 너무 많지 않은 하위 문제 클래스를 열거할 수 있을 때 가장 효율적입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the complexity for a naive recursive Fibonacci function?,순진한 재귀 피보나치 함수의 복잡도는 무엇인가요?,"Θ(φ^n), where phi(φ) is the golden ratio (1 + sqrt(5)) / 2. 
approx: 1.618","θ(φ^n), 여기서 phi(φ)는 황금 비율 (1 + sqrt(5)) / 2입니다. 
약: 1.618",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Write a dynamic programming version of computing Fibonacci for n.,n에 대한 피보나치 계산의 동적 프로그래밍 버전을 작성하세요.,"def fib(n):
   fibValues = [0,1]
   for i in range(2, n+1):
      fibValues.append(fibValues[i-1] + fibValues[i-2])

   return fibValues[n]","def fib(n):
   fibValues = [0,1]
   for i in range(2, n+1):
      fibValues.append(fibValues[i-1] + fibValues[i-2])

   return fibValues[n]",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Write a dynamic programming implementation of longest common subsequence of 2 strings.,2개의 문자열로 구성된 가장 긴 공통 서브시퀀스의 동적 프로그래밍 구현을 작성합니다.,"def longest_common_subsequence(sequence1, sequence2):
    cols = len(sequence1) + 1   # Add 1 to represent 0 valued column for DP
    rows = len(sequence2) + 1   # Add 1 to represent 0 valued row for DP

    T = [[0 for _ in range(cols)] for _ in range(rows)]

    max_length = 0

    for i in range(1, rows):
        for j in range(1, cols):
            if sequence2[i - 1] == sequence1[j - 1]:
                T[i][j] = 1 + T[i - 1][j - 1]
            else:
                T[i][j] = max(T[i - 1][j], T[i][j - 1])

            max_length = max(max_length, T[i][j])

    return max_length","def longest_common_subsequence(sequence1, sequence2):
    cols = len(sequence1) + 1   # Add 1 to represent 0 valued column for DP
    rows = len(sequence2) + 1   # Add 1 to represent 0 valued row for DP

    T = [[0 for _ in range(cols)] for _ in range(rows)]

    max_length = 0

    for i in range(1, rows):
        for j in range(1, cols):
            if sequence2[i - 1] == sequence1[j - 1]:
                T[i][j] = 1 + T[i - 1][j - 1]
            else:
                T[i][j] = max(T[i - 1][j], T[i][j - 1])

            max_length = max(max_length, T[i][j])

    return max_length",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Python: Implement the Floyd-Warshall algorithm (all pairs shortest paths).,Python: Floyd-Warshall 알고리즘을 구현합니다(모든 최단 경로 쌍).,"# Python Program for Floyd Warshall Algorithm
 
# Number of vertices in the graph
V = 4
 
# Define infinity as the large enough value. This value will be
# used for vertices not connected to each other
INF  = 99999
 
# Solves all pair shortest path via Floyd Warshall Algrorithm
def floydWarshall(graph):
 
    """""" dist[][] will be the output matrix that will finally
        have the shortest distances between every pair of vertices """"""
    """""" initializing the solution matrix same as input graph matrix
    OR we can say that the initial values of shortest distances
    are based on shortest paths considerting no 
    intermedidate vertices """"""
    dist = map(lambda i : map(lambda j : j , i) , graph)
     
    """""" Add all vertices one by one to the set of intermediate
     vertices.
     ---> Before start of a iteration, we have shortest distances
     between all pairs of vertices such that the shortest
     distances consider only the vertices in set 
    {0, 1, 2, .. k-1} as intermediate vertices.
      ----> After the end of a iteration, vertex no. k is
     added to the set of intermediate vertices and the 
    set becomes {0, 1, 2, .. k}
    """"""
    for k in range(V):
 
        # pick all vertices as source one by one
        for i in range(V):
 
            # Pick all vertices as destination for the
            # above picked source
            for j in range(V):
 
                # If vertex k is on the shortest path from 
                # i to j, then update the value of dist[i][j]
                dist[i][j] = min(dist[i][j] ,
                                  dist[i][k]+ dist[k][j]
                                )
    printSolution(dist)
 
 
# A utility function to print the solution
def printSolution(dist):
    print ""Following matrix shows the shortest distances\
 between every pair of vertices""
    for i in range(V):
        for j in range(V):
            if(dist[i][j] == INF):
                print ""%7s"" %(""INF""),
            else:
                print ""%7d\t"" %(dist[i][j]),
            if j == V-1:
                print """"
 
 
 
# Driver program to test the above program
# Let us create the following weighted graph
""""""
            10
       (0)------->(3)
        |         /|\
      5 |          |
        |          | 1
       \|/         |
       (1)------->(2)
            3           """"""
graph = [[0,5,INF,10],
             [INF,0,3,INF],
             [INF, INF, 0,   1],
             [INF, INF, INF, 0]
        ]
# Print the solution
floydWarshall(graph);
# This code is contributed by Nikhil Kumar Singh(nickzuck_007)","# Python Program for Floyd Warshall Algorithm
 
# Number of vertices in the graph
V = 4
 
# Define infinity as the large enough value. This value will be
# used for vertices not connected to each other
INF  = 99999
 
# Solves all pair shortest path via Floyd Warshall Algrorithm
def floydWarshall(graph):
 
    """""" dist[][] will be the output matrix that will finally
        have the shortest distances between every pair of vertices """"""
    """""" initializing the solution matrix same as input graph matrix
    OR we can say that the initial values of shortest distances
    are based on shortest paths considerting no 
    intermedidate vertices """"""
    dist = map(lambda i : map(lambda j : j , i) , graph)
     
    """""" Add all vertices one by one to the set of intermediate
     vertices.
     ---> Before start of a iteration, we have shortest distances
     between all pairs of vertices such that the shortest
     distances consider only the vertices in set 
    {0, 1, 2, .. k-1} as intermediate vertices.
      ----> After the end of a iteration, vertex no. k is
     added to the set of intermediate vertices and the 
    set becomes {0, 1, 2, .. k}
    """"""
    for k in range(V):
 
        # pick all vertices as source one by one
        for i in range(V):
 
            # Pick all vertices as destination for the
            # above picked source
            for j in range(V):
 
                # If vertex k is on the shortest path from 
                # i to j, then update the value of dist[i][j]
                dist[i][j] = min(dist[i][j] ,
                                  dist[i][k]+ dist[k][j]
                                )
    printSolution(dist)
 
 
# A utility function to print the solution
def printSolution(dist):
    print ""Following matrix shows the shortest distances\
 between every pair of vertices""
    for i in range(V):
        for j in range(V):
            if(dist[i][j] == INF):
                print ""%7s"" %(""INF""),
            else:
                print ""%7d\t"" %(dist[i][j]),
            if j == V-1:
                print """"
 
 
 
# Driver program to test the above program
# Let us create the following weighted graph
""""""
            10
       (0)------->(3)
        |         /|\
      5 |          |
        |          | 1
       \|/         |
       (1)------->(2)
            3           """"""
graph = [[0,5,INF,10],
             [INF,0,3,INF],
             [INF, INF, 0,   1],
             [INF, INF, INF, 0]
        ]
# Print the solution
floydWarshall(graph);
# This code is contributed by Nikhil Kumar Singh(nickzuck_007)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does __getitem__ in a class allow us to use?,수업에서 __getitem__는 무엇을 사용할 수 있게 하나요?,"- iteration
- slicing
- reverse iteration
- random.choice","- 반복
- 슬라이싱
- 역반복
- 무작위 선택",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the difference between __str__ and __repr__?,__str__와 __repr__의 차이점은 무엇인가요?,"def __str__(self): - meant to be human readable
def __repr__(self): - mean to represent the object and be unambiguous, usually as the constructor: for a Vector class, would be:
   
def __repr__(self):
    return ""Vector({!r}, {!r})"".format(self.x, self.y)
    OR
    return ""Vector(%r, %r)"" % (self.x, self.y)


Containers use __repr__ of elements when __str__ is called on container.","def __str__(자체): - 사람이 읽을 수 있도록 설계되었습니다
def __repr__(self): - 객체를 표현하고 명확하게 표현하는 것을 의미하며, 일반적으로 벡터 클래스의 경우 다음과 같습니다:
   
def __repr__(자체):
    ""Vector({!r}, {!r})""""format(self.x, self.y)을 반환합니다
    또는
    ""Vector(%r, %r)"" % (self.x, self.y)를 반환합니다


컨테이너는 __str__가 컨테이너에 호출될 때 __repr__ 요소를 사용합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"C: Method to find a given item x in a linked list. Head is a List *, x's data type is item_type","C: 링크된 목록에서 주어진 항목 x를 찾는 방법. 머리는 목록 *이고, x의 데이터 유형은 항목_type입니다","List *search_list(List *l, item_type x)
{
  if (l == NULL) return(NULL);

  if (l->item == x)
    return(l);
  else
    return search_list(l->next, x);
}","List *search_list(List *l, item_type x)
{
  if (l == NULL) return(NULL);

  if (l->item == x)
    return(l);
  else
    return search_list(l->next, x);
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"C: Method to insert a given item x into a linked list. Head is a List *, x's data type is item_type","C: 주어진 항목 x를 연결된 목록에 삽입하는 방법. 머리는 목록 *이고, x의 데이터 유형은 항목_type입니다","void insert_list(List **l, item_type x) {
  List *p;

  p = malloc(sizeof(List));
  p->item = x;
  p->next = *l;
  *l = p;
}","void insert_list(List **l, item_type x) {
  List *p;

  p = malloc(sizeof(List));
  p->item = x;
  p->next = *l;
  *l = p;
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
C: Method to return the nth item from the end of a linked list.,C: Method to return the nth item from the end of a linked list.,"int value_n_from_end(node_t *head, int n) {
  if (n < 1 || head == NULL) {
    printf(""Cannot get nth item from end."");
    exit(EXIT_FAILURE);
  }

  node_t *current = head;
  node_t *match = head;

  for (int i = 0; i < n && current; ++i) {
    current = current->next;
  }

  if (i != n) {
    printf(""List is too short to get nth item from end."");
    exit(EXIT_FAILURE);
  }

  while (current) {
    current = current->next;
    match = match->next;
  }

  return match->val;
}","int value_n_from_end(node_t *head, int n) {
  if (n < 1 || head == NULL) {
    printf(""Cannot get nth item from end."");
    exit(EXIT_FAILURE);
  }

  node_t *current = head;
  node_t *match = head;

  for (int i = 0; i < n && current; ++i) {
    current = current->next;
  }

  if (i != n) {
    printf(""List is too short to get nth item from end."");
    exit(EXIT_FAILURE);
  }

  while (current) {
    current = current->next;
    match = match->next;
  }

  return match->val;
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many subsets are there in n items?,n개의 항목에 몇 개의 하위 집합이 있나요?,2^n,2^n,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Python: Given an array of non negative numbers and a total, is there subset of numbers in this array which adds up to given total.","파이썬: 음수가 아닌 숫자들의 배열과 총합이 주어졌을 때, 이 배열에는 주어진 총합을 더한 숫자들의 부분 집합이 존재할까요.","""""""
* Time complexity is O(input.size * total_sum)
* Space complexity is O(input.size*total_sum)
""""""

def subset_sum(sequence, sum_value):
    cols = sum_value + 1         # Plus 1 for 0 valued col.
    rows = len(sequence) + 1     # Plus 1 for 0 valued row.
    T = [[False for _ in range(cols)] for _ in range(rows)]

    for row in range(rows):
        T[row][0] = True

    for index_i in range(1, rows):
        for index_j in range(1, cols):
            if index_j >= sequence[index_i - 1]:
                T[index_i][index_j] = T[index_i - 1][index_j] or T[index_i - 1][index_j - sequence[index_i - 1]]
            else:
                T[index_i][index_j] = T[index_i - 1][index_j]

    return T[rows - 1][cols - 1]


if __name__ == '__main__':
    sequence = [2, 3, 7, 8]
    assert True == subset_sum(sequence, 11)","""""""
* Time complexity is O(input.size * total_sum)
* Space complexity is O(input.size*total_sum)
""""""

def subset_sum(sequence, sum_value):
    cols = sum_value + 1         # Plus 1 for 0 valued col.
    rows = len(sequence) + 1     # Plus 1 for 0 valued row.
    T = [[False for _ in range(cols)] for _ in range(rows)]

    for row in range(rows):
        T[row][0] = True

    for index_i in range(1, rows):
        for index_j in range(1, cols):
            if index_j >= sequence[index_i - 1]:
                T[index_i][index_j] = T[index_i - 1][index_j] or T[index_i - 1][index_j - sequence[index_i - 1]]
            else:
                T[index_i][index_j] = T[index_i - 1][index_j]

    return T[rows - 1][cols - 1]


if __name__ == '__main__':
    sequence = [2, 3, 7, 8]
    assert True == subset_sum(sequence, 11)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What is a contiguously-allocated structures, and give examples.","연속적으로 할당된 구조란 무엇이며, 예를 들어 설명해 주세요.","Contiguously-allocated structures are composed of single slabs of memory, and include arrays, matrices, heaps, and hash tables.","연속적으로 할당된 구조는 단일 메모리 슬래브로 구성되며 배열, 행렬, 힙, 해시 테이블을 포함합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are linked data structures and give examples.,연결된 데이터 구조란 무엇이며 예시를 제공합니다.,"Linked data structures are composed of distinct chunks of memory bound together by pointers, and include lists, trees, and graph adjacency lists.","연결된 데이터 구조는 포인터로 결합된 별개의 메모리 덩어리로 구성되며, 리스트, 트리, 그래프 인접 리스트를 포함합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some benefits of arrays?,배열의 장점은 무엇인가요?,"- Constant-time access given the index
- Space efficiency
- Memory locality","- 인덱스가 지정된 일정 시간 액세스
- 공간 효율성
- 기억 지역성",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Why is memory locality important?,기억의 국소성이 중요한 이유는 무엇인가요?,Physical continuity between successive data accesses helps exploit the high-speed cache memory on modern computer architectures.,연속적인 데이터 접근 간의 물리적 연속성은 현대 컴퓨터 아키텍처에서 고속 캐시 메모리를 활용하는 데 도움이 됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some advantages to linked lists over arrays?,연결된 목록이 배열에 비해 어떤 장점이 있나요?,"- Overflow on linked structures can never occur unless the memory is actually full.
- Insertions and deletions are simpler than for contiguous (array) lists.
- With large records, moving pointers is easier and faster than moving the items themselves.","- 메모리가 실제로 가득 차 있지 않으면 연결된 구조물에서 오버플로우가 발생할 수 없습니다.
- 삽입 및 삭제는 연속적인 (어레이) 목록보다 더 간단합니다.
- 큰 기록에서는 포인터를 이동하는 것이 항목 자체를 이동하는 것보다 더 쉽고 빠릅니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some advantages to arrays over linked lists?,연결된 목록에 비해 배열의 장점은 무엇인가요?,"- Linked structures require extra space for storing pointer fields.
- Linked lists do not allow efficient random access to items.
- Arrays allow better memory locality and cache performance than random pointer jumping.","- 연결된 구조는 포인터 필드를 저장하기 위한 추가 공간이 필요합니다.
- 연결된 목록은 항목에 대한 효율적인 무작위 접근을 허용하지 않습니다.
- 배열은 랜덤 포인터 점프보다 메모리 로컬리티와 캐시 성능을 향상시킵니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Given two strings str1 and str2, find the minimum number of edits (edit one character to another, delete char from str1 or delete char from str2) to change str1 to str2.","두 문자열 str1과 str2가 주어졌을 때, str1을 str2로 변경하려면 최소 편집 횟수(한 문자를 다른 문자로 편집하거나 str1에서 char를 삭제하거나 str2에서 char를 삭제)를 구합니다.","""""""
* DP Runtime : O(len(str1) * len(str2))
""""""

def min_edit_distance(str1, str2):
    rows = len(str2) + 1
    cols = len(str1) + 1
    T = [[0 for _ in range(cols)] for _ in range(rows)]

    for j in range(cols):
        T[0][j] = j

    for i in range(rows):
        T[i][0] = i

    for i in range(1, rows):
        for j in range(1, cols):
            if str2[i - 1] == str1[j - 1]:
                T[i][j] = T[i - 1][j - 1]
            else:
                T[i][j] = 1 + min(T[i - 1][j - 1], T[i - 1][j], T[i][j - 1])

    print_edits(T, str1, str2)

    return T[rows - 1][cols - 1]


if __name__ == '__main__':
    str1 = ""azced""
    str2 = ""abcdef""
    expected = 3
    assert expected == min_edit_distance(str1, str2)
    assert expected == min_edit_distance(str2, str1)","""""""
* DP Runtime : O(len(str1) * len(str2))
""""""

def min_edit_distance(str1, str2):
    rows = len(str2) + 1
    cols = len(str1) + 1
    T = [[0 for _ in range(cols)] for _ in range(rows)]

    for j in range(cols):
        T[0][j] = j

    for i in range(rows):
        T[i][0] = i

    for i in range(1, rows):
        for j in range(1, cols):
            if str2[i - 1] == str1[j - 1]:
                T[i][j] = T[i - 1][j - 1]
            else:
                T[i][j] = 1 + min(T[i - 1][j - 1], T[i - 1][j], T[i][j - 1])

    print_edits(T, str1, str2)

    return T[rows - 1][cols - 1]


if __name__ == '__main__':
    str1 = ""azced""
    str2 = ""abcdef""
    expected = 3
    assert expected == min_edit_distance(str1, str2)
    assert expected == min_edit_distance(str2, str1)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Codeless question: Write a function to find the middle node of a singly-linked list.,코드 없는 질문: 단일 링크 목록의 중간 노드를 찾기 위한 함수를 작성합니다.,How would you do it?,그걸 어떻게 하시겠어요?,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Codeless question: Write a function to compare whether two binary trees are identical. Identical trees have the same key value at each position and the same structure.,코드 없는 질문: 두 이진 트리가 동일한지 비교하는 함수를 작성합니다. 동일한 트리는 각 위치와 구조에서 동일한 키 값을 갖습니다.,How?,어떻게?,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Codeless quesiton: Write a program to convert a binary search tree into a linked list.,코드리스 질문: Binary Search Tree를 연결된 목록으로 변환하는 프로그램을 작성합니다.,How would you do it?,그걸 어떻게 하시겠어요?,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Codeless Question: You are given a search string and a magazine. You seek to generate all the characters in search string by cutting them out from the magazine. Give an algorithm to efficiently determine whether the magazine contains all the letters in the search string.,코드 없는 질문: 검색 문자열과 잡지가 주어집니다. 잡지에서 모든 문자를 잘라내어 검색 문자열에 있는 모든 문자를 생성하려고 합니다. 잡지에 검색 문자열에 모든 문자가 포함되어 있는지 효율적으로 판단할 수 있는 알고리즘을 제시합니다.,How would you do it?,그걸 어떻게 하시겠어요?,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Codeless question: Give an algorithm for finding an ordered word pair (e.g., “New York”) occurring with the greatest frequency in a given webpage. Which data structures would you use?","코드 없는 질문: 주어진 웹페이지에서 가장 높은 빈도로 발생하는 정렬된 단어 쌍(예: ""뉴욕"")을 찾기 위한 알고리즘을 제시하세요. 어떤 데이터 구조를 사용하시겠습니까?","You could use a hash table, creating or updating an entry for each pair. 
Keep track of max_frequency and most_frequent_phrase.
Just increment the count, and when you see the new count is > than max_frequency, update max_frequency and most_frequent_phrase","해시 테이블을 사용하여 각 쌍에 대한 항목을 만들거나 업데이트할 수 있습니다. 
max_frequency와 most_frequency_phrase를 추적하세요.
카운트를 늘리기만 하면 새 카운트가 max_frequency보다 >인 것을 확인하고 max_frequency 및 most_frequency_frequency를 업데이트합니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Codeless question: Given a set of n numbers, how do you find the pair of numbers that have the smallest difference between them?","코드 없는 질문: n개의 숫자 집합이 주어졌을 때, 두 숫자 사이의 차이가 가장 작은 두 숫자를 어떻게 찾을 수 있을까요?","Sort them: Once the numbers are sorted, the closest pair of numbers must lie next to each other somewhere in sorted order. Thus, a linear-time scan through them completes the job, for a total of O(n log n) time including the sorting.",정렬하기: 숫자가 정렬되면 가장 가까운 숫자 쌍이 정렬된 순서대로 서로 옆에 있어야 합니다. 따라서 정렬을 포함하여 총 O(n 로그 n) 시간 동안 숫자를 선형 시간 스캔하면 작업이 완료됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Codeless question: Are there any duplicates in a given set of n items?,코드 없는 질문: 주어진 n개의 항목 집합에 중복되는 항목이 있나요?,"This is a special case of the closest-pair problem, where we ask if there is a pair separated by a gap of zero. The most efficient algorithm sorts the numbers and then does a linear scan though checking all adjacent pairs.","이것은 가장 가까운 쌍 문제의 특별한 경우로, 0의 간격으로 분리된 쌍이 있는지 묻는 문제입니다. 가장 효율적인 알고리즘은 숫자를 정렬한 다음 인접한 모든 쌍을 확인하여 선형 스캔을 수행합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Codeless question: Given a set of n items, which element occurs the largest number of times in the set? Bonus: How do you find out how many times some element k appears?","코드 없는 질문: n개의 항목 집합이 주어졌을 때, 집합에서 가장 많이 발생하는 요소는 무엇인가요? 보너스: 어떤 요소 k가 몇 번이나 나타나는지 어떻게 알 수 있나요?","If the items are sorted, we can sweep from left to right and count them, since all identical items will be lumped together during sorting.

To find out how often an arbitrary element k occurs, look up k using binary search in a sorted array of keys. Then use binary search in each direction to find where that run of the number begins and ends.","항목이 정렬되면 정렬 중에 모든 동일한 항목이 함께 모이게 되므로 왼쪽에서 오른쪽으로 쓸어 세어볼 수 있습니다.

임의의 요소 k가 얼마나 자주 발생하는지 알아보려면 정렬된 키 배열에서 이진 검색을 사용하여 k를 찾아보세요. 그런 다음 각 방향에서 이진 검색을 사용하여 숫자의 시작과 끝을 찾습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Codeless question: Give an efficient algorithm to determine whether two sets (of size m and n, respectively) are disjoint.",코드 없는 질문: 두 집합(각각 크기 m과 n)이 서로 분리되어 있는지 여부를 결정하는 효율적인 알고리즘을 제시합니다.,"The small set can be sorted in O(m log m) time. We can now do a binary search with each of the n elements in the big set, looking to see if it exists in the small one. The total time will be O((n + m) log m).

This is better than sorting the larger array or sorting both sets and going through the list.","작은 집합은 O(m log m) 시간 내에 정렬할 수 있습니다. 이제 큰 집합의 n개 원소 각각으로 이진 검색을 수행하여 작은 집합에 존재하는지 확인할 수 있습니다. 총 시간은 O((n + m) log m입니다.

이것은 더 큰 배열을 정렬하거나 두 집합을 정렬하고 목록을 살펴보는 것보다 낫습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Python: Function that reads file numbers.txt and outputs numbers-mult.txt where each number in numbers.txt is multiplied by its line number.,Python: 파일 번호.txt를 읽고 숫자-mult.txt를 출력하는 함수입니다. 여기서 숫자.txt의 각 숫자는 줄 번호로 곱해집니다.,"# don't use os.linesep

def main():
    input_file = ""numbers.txt""
    output_file = ""numbers-mult.txt""

    output = []

    with open(input_file, ""r"") as input_handle:
        for line_number, line in enumerate(input_handle, 1):
            output.append(line_number * int(line.rstrip()))

    output_handle = open(output_file, ""w"")
    output_handle.write('\n'.join(str(n) for n in output))","# don't use os.linesep

def main():
    input_file = ""numbers.txt""
    output_file = ""numbers-mult.txt""

    output = []

    with open(input_file, ""r"") as input_handle:
        for line_number, line in enumerate(input_handle, 1):
            output.append(line_number * int(line.rstrip()))

    output_handle = open(output_file, ""w"")
    output_handle.write('\n'.join(str(n) for n in output))",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a uniform distribution?,균일 분포란 무엇인가요?,"When a known finite number of outcomes are equally likely to occur. When graphed as a histogram of occurrences, it's a flat line. N items each have 1/n probability.",알려진 유한한 수의 결과가 동일하게 발생할 가능성이 있는 경우. 발생 히스토그램으로 그래프로 표시하면 평평한 선이 됩니다. N개의 항목은 각각 1/n의 확률을 갖습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a normal distribution?,정규 분포란 무엇인가요?,The standard normal probability density function has the famous bell shape that is known to just about everyone.,표준 정규 확률 밀도 함수는 거의 모든 사람에게 알려진 유명한 종 모양을 가지고 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an n-gram?,n그램이란 무엇인가요?,A set of N sequential words appearing together.,N개의 순차 단어 집합이 함께 나타납니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the maximum unsigned number you can represent with 9 bits?,9비트로 표현할 수 있는 최대 부호 없는 숫자는 얼마인가요?,511,511,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Whats the average height of a binary search tree after n insertions?,n번의 삽입 후 Binary Search Tree의 평균 높이는 얼마인가요?,"2 ln n
About 39% taller than a perfectly balanced BST","2 ln n
완벽하게 균형 잡힌 BST보다 약 39% 더 큽니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the runtime of randomized quicksort?,무작위 퀵소트의 실행 시간은 어떻게 되나요?,"Theta(n log n) time on any input, with high probability.","모든 입력에 대한 Theta(n 로그 n) 시간, 높은 확률로.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
No answer: Write a function to find the square root of a number within the tolerance of 0.0001,답이 없습니다: 0.0001의 허용 오차 내에서 숫자의 제곱근을 구하는 함수를 작성하세요,?,?,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Alter a binary search function to find the start and end indexes of the incidences of a number k in a sorted list.,이진 검색 함수를 변경하여 정렬된 목록에서 숫자 k의 발생 시작 및 끝 인덱스를 찾습니다.,"Alter this:


int binary_search(item_type s[], item_type key, int low, int high)
{
    int middle; /* index of middle element */

    if (low > high) return (-1); /* key not found  - replace with return low instead of -1

    middle = (low+high)/2;

    if (s[middle] == key) return(middle); // delete

    if (s[middle] > key)
        return( binary_search(s,key,low,middle-1) );
    else
        return(binary_search(s,key,middle+1,high) );
}","Alter this:


int binary_search(item_type s[], item_type key, int low, int high)
{
    int middle; /* index of middle element */

    if (low > high) return (-1); /* key not found  - replace with return low instead of -1

    middle = (low+high)/2;

    if (s[middle] == key) return(middle); // delete

    if (s[middle] > key)
        return( binary_search(s,key,low,middle-1) );
    else
        return(binary_search(s,key,middle+1,high) );
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Codeless question: If you are given a million integers to sort, what algorithm would you use to sort them? How much time and memory would that consume?",코드 없는 질문: 백만 개의 정수를 정렬하려면 어떤 알고리즘을 사용하여 정렬하시겠습니까? 그렇게 하면 얼마나 많은 시간과 메모리가 소모될까요?,?,?,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Codeless question: Describe advantages and disadvantages of the most popular sorting algorithms.,코드 없는 질문: 가장 인기 있는 정렬 알고리즘의 장단점을 설명하세요.,?,?,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Codeless: Implement an algorithm that takes an input array and returns only the unique elements in it.,코드리스: 입력 배열을 가져와서 고유한 요소만 반환하는 알고리즘을 구현합니다.,?,?,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Codeless: You have a computer with only 2Mb of main memory. How do you use it to sort a large file of 500 Mb that is on disk?,코드리스: 주 메모리가 2Mb뿐인 컴퓨터가 있습니다. 디스크에 있는 500Mb의 대용량 파일을 어떻게 정렬하나요?,?,?,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Python: Default arguments are okay to use with the following caveat.,Python: 기본 인수는 다음 주의사항과 함께 사용해도 괜찮습니다.,"Do not use mutable objects as default values in the function or method definition.

Lists are not ok.","함수나 메서드 정의에서 기본값으로 변경 가능한 객체를 사용하지 마십시오.

목록이 좋지 않습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Python: Give an example of a conditional expression.,파이썬: 조건부 표현의 예를 들어보세요.,x = 1 if cond else 2,x = 1 if cond else 2,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Python: break this string 'a/b/c' into a list of ['a', 'b', c']","파이썬: 이 문자열 'a/b/c'를 [a', 'b', c']의 목록으로 나눕니다",'a/b/c'.split('/'),'a/b/c'.split('/',CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Python: split a word or sentences into characters.,파이썬: 단어나 문장을 문자로 나눕니다.,list('some words'),몇 단어 나열하기'),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the difference between foo.sort() and sorted(foo) where foo is a list?,foo.sort()와 sorted(foo)의 차이점은 무엇인가요? 여기서 foo는 목록입니다?,"foo.sort() changes the list to its sorted state
sorted(foo) doesn't change foo, just returns a sorted list.","foo.sort()가 목록을 정렬된 상태로 변경합니다
정렬된(foo)은 foo를 변경하지 않고 정렬된 목록만 반환합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Can you sort a tuple?,튜플을 분류할 수 있나요?,"Yes, using sorted(foo)
but not with foo.sort()","예, 정렬된(foo)을 사용합니다
하지만 foo.sort()는 안 돼요",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Python: How would you remove indices 6 to 11 in a list foo?,파이썬: 리스트 푸에서 인덱스 6에서 11을 어떻게 제거하시겠습니까?,del foo[6:12],del foo[6:12],CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Python: How can you tell if an index is in a list?,파이썬: 인덱스가 목록에 있는지 어떻게 알 수 있나요?,if 0 < i < len(foo):,만약 0 < i < len(foo)):,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Python: How to output today's date, like August 10, 2016",Python: 2016년 8월 10일과 같이 오늘 날짜를 출력하는 방법,"import datetime

currentDate = datetime.date.today()
print(currentDate.strftime(""The date is %B %d, %Y""))","날짜 가져오기

현재 날짜 = datetime.date.today ()
print(현재 날짜.strftime(""날짜는 %B %d, %Y"")",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Python: How to output today's date, like 8/10/2016 (August, not October)","파이썬: 오늘 날짜를 출력하는 방법, 예를 들어 2016년 8월(10월이 아닌 8월)","import datetime

currentDate = datetime.date.today()
print(currentDate.strftime(""The date is %m/%d/%Y""))","import datetime

currentDate = datetime.date.today()
print(currentDate.strftime(""The date is %m/%d/%Y""))",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the probability of getting heads twice? P(HH),두 번 앞면이 나올 확률은 얼마인가요? P(HH),"1/4 
= 1/2 * 1/2","1/4 
= 1/2 * 1/2",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What's the probability of getting heads, tails, heads? P(HTH)","앞면, 뒷면, 앞면이 나올 확률은 얼마인가요? P(HTH)","1/8 
= 1/2 * 1/2 * 1/2
the ordering of HTH doesn't matter. It could be TTH or HHH or TTT, they are tall the same.","1/8 
= 1/2 * 1/2 * 1/2
HTH의 순서는 중요하지 않습니다. TTH일 수도 있고, HHH일 수도 있고, TTT일 수도 있습니다. 둘 다 키가 큽니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the probability of getting heads 200 times in a row?,200번 연속으로 앞면이 나올 확률은 얼마인가요?,(1/2)^200,(1/2)^200,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What's the Probability of getting head, tails or tails, heads? P(HT U TH)","앞면, 뒷면 또는 뒷면, 앞면이 나올 확률은 얼마인가요? P(HT U TH)",(1/2 * 1/2) + (1/2 * 1/2) = 2/4 = 1/2,(1/2 * 1/2) + (1/2 * 1/2) = 2/4 = 1/2,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the probability of getting exactly 3 heads in 8 flips?,8번의 플립에서 정확히 3개의 헤드가 나올 확률은 얼마인가요?,"56/256 = 7/32

(8 choose 3)/2^8","56/256 = 7/32

(8 choose 3)/2^8",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
You have 26 letters in an alphabet. How many ways you can arrange 3 letters from that alphabet where repeated letters is OK?,알파벳에는 26개의 문자가 있습니다. 반복되는 문자가 괜찮은 알파벳에서 3개의 문자를 배열할 수 있는 방법은 몇 가지인가요?,"26*26*26 = 26^3 = 17,576","26*26*26 = 26^3 = 17,576",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
You have 26 letters in an alphabet. How many ways you can arrange 3 letters from that alphabet without repeating a letter?,알파벳에는 26개의 글자가 있습니다. 알파벳에서 글자를 반복하지 않고 3개의 글자를 배열할 수 있는 방법은 몇 가지인가요?,"26*25*24 = 26 permute 3 = 15,600","26*25*24 = 26 permute 3 = 15,600",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Given an alphabet of 26 letters, how many times you can you choose 3 letters, if ordering of the letters doesn't matter?","알파벳 26글자가 주어졌을 때, 글자 순서가 상관없다면 3글자를 몇 번이나 선택할 수 있나요?",26*25*24 / 3! = 2600,26*25*24 / 3! = 2600,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is 0! ?,0이란 무엇인가요?,1,1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
There are 4 people. How many ways can they shake each other's hands without shaking the same person's hand twice?,4명이 있습니다. 같은 사람의 손을 두 번 흔들지 않고 서로 악수할 수 있는 방법은 몇 가지일까요?,"6
= 4 choose 2
= 4 * 3 / 2","6
= 4 선택 2
= 4 * 3 / 2",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Right-propagate the rightmost 1-bit, producing all 1's if x = 0 (e.g., 01011000 01011111):",가장 오른쪽에 있는 1비트를 오른쪽으로 전파하여 x = 0인 경우 모든 1을 생성합니다(예: 01011000 01011111):,x |= (x - 1),x |= (x - 1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Isolate the right-most bit in x.,x에서 가장 오른쪽 비트를 분리하세요.,x & ~(x - 1),x & ~(x - 1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How would you swap 2 integers with no temporary variables and no bitwise operations?,임시 변수나 비트 단위 연산 없이 2개의 정수를 어떻게 교환하시겠습니까?,"a = a + b
b = a - b
a = a - b","a = a + b
b = a - b
a = a - b",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is P?,P란 무엇인가요?,The set of all problems solvable in polynomial time.,다항 시간 내에 풀 수 있는 모든 문제의 집합.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is EXP?,EXP란 무엇인가요?,The set of all problems solvable in exponential time.,지수 시간 내에 풀 수 있는 모든 문제의 집합.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is R? (not real numbers),R이란 무엇인가요? (실수가 아님),The set of problems solvable in finite time.,유한한 시간 내에 해결할 수 있는 문제들의 집합.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is the Halting Problem in R?,정지 문제는 R에 있나요?,No.,아니요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does NP mean? What is an NP algorithm?,NP는 무엇을 의미하나요? NP 알고리즘이란 무엇인가요?,NP is the set of decision problem solvable in non-deterministric polynomial time. An NP problem can be solved by a lucky algorithm that magically always finds a yes decision. NP problems can be checked in polynomial time.,NP는 비결정적 다항식 시간 내에 해결할 수 있는 결정 문제의 집합입니다. NP 문제는 마법처럼 항상 '예' 결정을 찾는 행운의 알고리즘으로 해결할 수 있습니다. NP 문제는 다항식 시간 내에 확인할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What makes a problem NP-Complete?,NP-완전 문제의 원인은 무엇인가요?,If x is an element of NP and of NP-hard. Np-Complete is the narrow intersection of NP and NP-hard.,x가 NP와 NP-난해의 원소인 경우. NP-완전은 NP와 NP-난해의 좁은 교차점입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Fib(0) ?,Fib(0)이란 무엇인가요?,0,0,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Fib(3) ?,Fib(3)이란 무엇인가요?,2,2,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Fib(2) ?,Fib(2)란 무엇인가요?,1,1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a PTAS?,PTAS란 무엇인가요?,Polynomial-time approximation scheme.,다항 시간 근사 방식.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a pointer?,포인터란 무엇인가요?,A memory address stored in memory.,메모리에 저장된 메모리 주소.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Give 2 examples of common data structures that contain reference cycles.,참조 주기를 포함하는 일반적인 데이터 구조의 두 가지 예를 들어보세요.,"- Doubly-linked lists
- Trees with parent and child pointers","- 이중 연결 목록
- 부모 및 자식 포인터가 있는 트리",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a weak reference in Python?,파이썬에서 약한 참조란 무엇인가요?,"A weak reference to an object does not affect its reference count. 
When the only remaining references to a referent are weak references, garbage collection is free to destroy the referent and reuse its memory for something else. A primary use for weak references is to implement caches or mappings holding large objects, where it’s desired that a large object not be kept alive solely because it appears in a cache or mapping.","객체에 대한 약한 참조는 참조 횟수에 영향을 미치지 않습니다. 
참조에 대한 유일한 참조가 약한 참조인 경우, 가비지 컬렉션은 참조를 파괴하고 메모리를 다른 용도로 재사용할 수 있습니다. 약한 참조의 주요 용도는 캐시나 매핑에 나타난다고 해서 큰 객체를 유지하지 않는 캐시나 매핑을 구현하는 것입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does garbage collection work in CPython?,CPython에서는 쓰레기 수거가 어떻게 작동하나요?,"CPython uses reference counting and generational garbage collection. There are 3 age stages where objects live in memory. They all start in the ""nursery"", stage0, then if they survive a garbage collection, they are moved to stage1, the oldest objects that continue to survive in stage1 are promoted to stage2. The gc module has thresholds 700, 10, 10 for each stage. In order to decide when to run, the collector keeps track of the number object allocations and deallocations since the last collection. When the number of allocations minus the number of deallocations exceeds threshold0, collection starts. If generation 0 has been examined more than threshold1 times since generation 1 has been examined, then generation 1 is examined as well. Similarly, threshold2 controls the number of collections of generation 1 before collecting generation 2.","CPython은 참조 카운팅과 세대 쓰레기 수집을 사용합니다. 객체가 기억 속에 존재하는 연령 단계는 3단계가 있습니다. 이 단계들은 모두 ""양육""인 0단계에서 시작하여 쓰레기 수집에서 살아남으면 1단계로 이동하고, 1단계에서 계속 생존하는 가장 오래된 객체는 2단계로 승격됩니다. GC 모듈에는 각 단계마다 임계값이 700, 10, 10입니다. 실행 시기를 결정하기 위해 수집기는 마지막 수집 이후의 객체 할당 및 할당 해제 횟수를 추적합니다. 할당 횟수에서 할당 해제 횟수를 뺀 값이 임계값 0을 초과하면 수집이 시작됩니다. 1세대가 검토된 이후 0세대가 임계값 1번 이상 검토된 경우, 1세대도 검토됩니다. 마찬가지로 임계값 2는 2세대를 수집하기 전에 1세대의 수집 횟수를 제어합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is reference counting?,참조 카운팅이란 무엇인가요?,"RC is a method of garbage collection. The runtime keeps track of references to an object by manipulating the reference count on each assignment and delete (del), and when the reference count reaches 0 it means the object is practically unreachable. When the next collection runs, the object's memory will be reserved to allocate for new objects.","RC는 가비지 컬렉션의 한 방법입니다. 런타임은 각 할당과 삭제(del)에서 참조 카운트를 조작하여 객체에 대한 참조를 추적하며, 참조 카운트가 0에 도달하면 객체에 거의 도달할 수 없음을 의미합니다. 다음 컬렉션이 실행되면 객체의 메모리가 새 객체에 할당되도록 예약됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a finalizer in Python?,파이썬에서 피니셔란 무엇인가요?,"A finalizer is a destructor, named __del__. __del__() is run when the runtime is about to destroy the object.","파이널라이저는 __del_. __del_()이라는 이름의 디스트럭터로, 런타임이 객체를 파괴하려고 할 때 실행됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are 2 advantages of reference counting?,참조 카운팅의 두 가지 장점은 무엇인가요?,"- easy to implement
- collects garbage incidentally without large pauses in execution.","- 구현하기 쉬운
- 실행 중에 큰 멈춤 없이 부수적으로 쓰레기를 수집합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are 2 disadvantages of reference counting?,참조 카운팅의 두 가지 단점은 무엇인가요?,"- it cannot collect circular references
- manipulating reference counts at each assignment is very slow.","- 순환 참조를 수집할 수 없습니다
- 각 과제에서 참조 횟수를 조작하는 것은 매우 느립니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is cyclic garbage collection?,순환 쓰레기 수거란 무엇인가요?,Detects and removes cycles unreachable by the program.,프로그램이 도달할 수 없는 사이클을 감지하고 제거합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How is garbage collection done in PyPy?,PyPy에서는 쓰레기 수거를 어떻게 하나요?,"The GC implementation can be chosen at runtime. It's pluggable.
PyPy uses mark and sweep, and generational gc optimization. Marked objects are promoted from the nursery to an older generation.
PyPy uses incremental garbage collection, where major collection is split into multiple passes, each lasting only a few milliseconds.","GC 구현은 런타임에 선택할 수 있습니다. 플러그인이 가능합니다.
PyPy는 마크 앤 스윕과 세대 GC 최적화를 사용합니다. 마크된 객체는 보육원에서 이전 세대로 승격됩니다.
PyPy는 점진적인 가비지 컬렉션을 사용하며, 주요 컬렉션은 여러 번의 패스로 나뉘며 각 패스는 몇 밀리초 동안만 지속됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a pointer?,포인터란 무엇인가요?,A pointer is a memory address stored in memory.,포인터는 메모리에 저장된 메모리 주소입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does mark and sweep work?,표시와 스위프는 어떻게 작동하나요?,"(In Java) Perform a DFS on the graph of references to objects. This graph can have multiple roots. Each root is a reference that the program can access directly, such as a variable. Traverse the graph, setting a mark bit in each object. The sweep phase causes unmarked memory to be linked together in a list, so that memory can be reallocated. Sometimes this also triggers compaction, which moves used objects adjacent to each other in memory. The side effect of this is that free memory is also adjacent to free memory so large blocks can be allocated.",(Java에서) 객체에 대한 참조 그래프에 대해 DFS를 수행합니다. 이 그래프는 여러 루트를 가질 수 있습니다. 각 루트는 변수와 같이 프로그램이 직접 액세스할 수 있는 참조입니다. 그래프를 가로지르며 각 객체에 표시 비트를 설정합니다. 스윕 단계에서는 표시되지 않은 메모리가 목록에서 서로 연결되어 메모리를 재할당할 수 있습니다. 때때로 이는 메모리에서 서로 인접한 사용된 객체를 이동시키는 압축을 유발하기도 합니다. 이로 인해 빈 메모리도 빈 메모리에 인접하여 큰 블록을 할당할 수 있다는 부작용이 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is copying garbage collection (stop and copy)?,쓰레기 수거(정지 및 복사)를 복사하는 것은 무엇인가요?,"Heap memory is split into 2 partitions: an old space and a new space. Find live objects by DFS of their reference graph, and move live objects into the new space. The new space is now called the old space. Unreachable objects are simply left in the old space to be overwritten the next time collection occurs. The movement of objects implicitly compacts the objects. Disadvantage: you can only use half of the heap space.",힙 메모리는 두 개의 partition으로 나뉩니다: 오래된 공간과 새로운 공간. 참조 그래프의 DFS를 통해 살아있는 객체를 찾아 새로운 공간으로 이동합니다. 이제 새로운 공간을 이전 공간이라고 합니다. 도달할 수 없는 객체는 다음 컬렉션이 발생할 때 덮어쓰기 위해 이전 공간에 그대로 둡니다. 객체의 움직임은 암묵적으로 객체를 압축합니다. 단점: 힙 공간의 절반만 사용할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How could you implement an LRU cache?,LRU 캐시를 어떻게 구현할 수 있나요?,"A fast lookup table, like a hash table or binary tree, and a linked list of items by use. When you access or add an item, you delete it from the linked list and add it to the head of the list.  Then to prune, traverse the linked list and remove trailing elements, and delete them from the storage (tree or hash table).
You can also use a splay tree, since it moves accesses to the root. To prune items, somehow find and remove the leaves, since the number of leaves will be about n/2.","해시 테이블 또는 이진 트리와 같은 빠른 조회 테이블과 사용 용도별 항목 목록입니다. 항목에 액세스하거나 추가할 때는 링크된 목록에서 항목을 삭제하고 목록의 맨 앞에 추가합니다. 그런 다음 연결된 목록을 가지치기하고 후행 요소를 제거한 다음 저장소(트리 또는 해시 테이블)에서 삭제합니다.
뿌리로 접근할 수 있도록 이동하기 때문에 스플레이 트리를 사용할 수도 있습니다. 잎의 수는 n/2 정도이므로 항목을 가지치기하려면 어떻게든 잎을 찾아서 제거하세요.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a direct mapped cache?,직접 매핑 캐시란 무엇인가요?,"It's a type of cache used in the CPU, where the lower order bits of a given memory address are used modulo the number of cache lines to place or lookup in the cache. Collisions are treated as overwrites.","CPU에서 사용되는 캐시 유형으로, 주어진 메모리 주소의 하위 비트를 캐시에 배치하거나 조회할 캐시 라인의 수에 따라 모듈로 사용합니다. 충돌은 덮어쓰기로 처리됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a fully-associative cache?,완전 결합 캐시란 무엇인가요?,"It's a type of cache used in the CPU, where lookups are done on all cache lines in parallel to determine a hit or miss.

This requires a very large number of comparators that increase the complexity and cost of implementing large caches. Therefore, this type of cache is usually only used for small caches, typically less than 4K.","CPU에서 사용되는 캐시 유형으로, 모든 캐시 라인에서 조회가 병렬로 수행되어 히트 또는 미스를 결정합니다.

이를 위해서는 대규모 캐시 구현의 복잡성과 비용을 증가시키는 매우 많은 수의 비교기가 필요합니다. 따라서 이러한 유형의 캐시는 일반적으로 4K 미만의 소규모 캐시에만 사용됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Disadvantage of a fully-associative cache?,완전 결합 캐시의 단점은 무엇인가요?,"- expensive due to parallel checks
- complexity of implementing this scheme","- 병렬 검사로 인해 비용이 많이 듭니다
- 이 계획을 구현하는 복잡성",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How do some processors handle caching for data and instructions?,일부 프로세서는 데이터와 명령어에 대한 캐싱을 어떻게 처리하나요?,There will be a slightly slower (3-4 clocks latency) separate cache for data.,데이터에 대해 약간 느린(3-4 클럭 지연 시간) 별도의 캐시가 있을 것입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an N-way set associative cache?,N-way 집합 연관 캐시란 무엇인가요?,A Set-Associative cache scheme is a combination of Fully-Associative and Direct Mapped caching schemes. A set-associate scheme works by dividing the cache SRAM into equal sections (2 or 4 sections typically) called cache ways. The cache page size is equal to the size of the cache way. Each cache way is treated like a small direct mapped cache.,집합 연관 캐시 방식은 완전 연관 캐싱 방식과 직접 매핑 캐싱 방식의 조합입니다. 집합 연관 방식은 캐시 SRAM을 캐시웨이라고 하는 동일한 섹션(일반적으로 2개 또는 4개 섹션)으로 나누어 작동합니다. 캐시 페이지 크기는 캐시웨이의 크기와 동일합니다. 각 캐시웨이는 작은 직접 매핑 캐시처럼 취급됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Describe the memory hierarchy of a Core i7 processor.,Core i7 프로세서의 메모리 계층 구조를 설명하세요.,"Inside of each core is a 32 kB L1 instruction cache, a 32 kB L1 data cache (it's 8-way set associative), and a dedicated 256 kB L2 cache (also 8-way set associative). 
Outside of the cores is the L3, which is much larger at 8 MB and smarter (16-way associative) than the L2s.","각 코어 내부에는 32kB L1 명령어 캐시, 32kB L1 데이터 캐시(8방향 집합 연관), 그리고 전용 256kB L2 캐시(8방향 집합 연관)가 있습니다. 
코어 외부에는 L3가 있으며, 이는 L2보다 8MB로 훨씬 크고 더 똑똑합니다(16방향 연관성).",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
When is entropy at its maximum?,엔트로피는 언제 최대치인가요?,When all outcomes are equal.,모든 결과가 같을 때.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"As predictability increases, what happens to entropy?",예측 가능성이 증가하면 엔트로피는 어떻게 될까요?,It decreases.,감소합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"As it relates to compression, as entropy increases, does our ability to compress increase?",압축과 관련하여 엔트로피가 증가함에 따라 우리의 압축 능력이 증가하나요?,"No, it decreases.","아니요, 감소합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does low entropy mean?,낮은 엔트로피는 무엇을 의미하나요?,Very predictable.,매우 예측 가능합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is entropy?,엔트로피란 무엇인가요?,"The minimum number of bits needed to represent x number of states. Also, information we don't know.","x개의 상태를 나타내기 위해 필요한 최소 비트 수입니다. 또한, 우리가 모르는 정보도 포함됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a Caesar cipher?,시저 암호란 무엇인가요?,The cipher created by shifting/rotating an alphabet by a specific number previously agreed upon.,알파벳을 이전에 합의된 특정 숫자만큼 이동하거나 회전시켜 만든 암호입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a polyalphabetic cipher?,다항식 암호란 무엇인가요?,A cipher where each letter is shifted based on the shifts of letters in a key word.,각 문자가 주요 단어의 문자 이동에 따라 이동되는 암호입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the entropy of n equally likely outcomes?,n개의 동등하게 가능한 결과의 엔트로피는 얼마인가요?,log(n),로그(n),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is GET idempotent?,GET는 무력한가요?,Yes,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is PUT idempotent?,PUT는 무력한가요?,Yes.,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is POST idempotent?,POST는 무력한가요?,No.,아니요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is DELETE idempotent?,DELETE는 idempotent인가요?,"According to the REST spec, yes, but it's up to the developer to conform to that. It can be achieved by using a deleted flag for a resource instead of completely removing the resource.",REST 사양에 따르면 그렇습니다. 하지만 이를 준수하는 것은 개발자의 몫입니다. 리소스를 완전히 제거하는 대신 삭제된 플래그를 사용하여 리소스를 달성할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is idempotent?,발기부전이란 무엇인가요?,The property that a method has side-effects of making more than one identical requests is the same as for a single request.,메서드가 여러 개의 동일한 요청을 하는 부작용이 있는 속성은 단일 요청의 속성과 동일합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is HMAC?,HMAC이란 무엇인가요?,"HMAC is a keyed-hash message authentication code used to provide a checksum for a message, sent along with the message to provide confidence that the message has not been tampered.","HMAC는 메시지의 체크섬을 제공하는 데 사용되는 키 해시 메시지 인증 코드로, 메시지가 변조되지 않았다는 확신을 주기 위해 메시지와 함께 전송됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a MAC?,MAC이란 무엇인가요?,"MAC is a message authentication code used to provide a checksum for a message, sent along with the message to provide confidence that the message has not been tampered.","MAC은 메시지의 체크섬을 제공하는 데 사용되는 메시지 인증 코드로, 메시지가 변조되지 않았다는 확신을 주기 위해 메시지와 함께 전송됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does RSA work?,RSA는 어떻게 작동하나요?,"It's a public/private key cryptography method. The public key can be used to encrypt a message into ciphertext that only the owner of the key can decrypt. The owner of the key uses their secret key to encrypt messages, and their secret key to decrypt messages encrypted with their public key.","공개/개인 키 암호화 방법입니다. 공개 키는 메시지를 암호화하여 키 소유자만 해독할 수 있는 암호문으로 암호화하는 데 사용할 수 있습니다. 키 소유자는 비밀 키를 사용하여 메시지를 암호화하고, 비밀 키를 사용하여 공개 키로 암호화된 메시지를 해독합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the phi function?,파이 함수란 무엇인가요?,It answers the number of integers <= n that do not share a common factor with n.,n과 공통 인수를 공유하지 않는 정수의 수 <= n에 답합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is phi(n) if n is prime?,n이 소수라면 phi(n)은 무엇인가요?,n - 1,n - 1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the gcd of a number a and prime p when p is prime?,p가 소수일 때 숫자 a와 소수 p의 gcd는 무엇인가요?,"1, unless a is a pseudoprime (Carmichael number)","1, a가 의사 소수(카마이클 수)가 아닌 경우",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does SHA stand for?,SHA는 무엇을 의미하나요?,One of the family of Secure Hashing Algorithms.,보안 해싱 알고리즘 계열 중 하나입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the largest output size of SHA-3?,SHA-3의 가장 큰 출력 크기는 무엇인가요?,512 bits,512비트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are desirable properties of one-way functions?,단방향 함수의 바람직한 특성은 무엇인가요?,"- collision resistant
- target collision resistant
- non-malleable","- 충돌 저항성
- 목표 충돌 저항성
- 가단성이 없는",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"If a one-way function is collision-resistant, does that mean it's also target collision-resistant?","단방향 함수가 충돌 저항성이 있다면, 그것도 목표 충돌 저항성이 있다는 뜻인가요?",Yes.,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"If a one-way function is target collision-resistant, does that mean it's also collision-resistant?","단방향 함수가 목표 충돌에 강하다면, 그것도 충돌에 강하다는 뜻인가요?",No.,아니요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is symmetric key encryption?,대칭 키 암호화란 무엇인가요?,"There is a known encryption function, and one key is used to encrypt and decrypt. The key has to be shared between 2 parties.","알려진 암호화 기능이 있으며, 하나의 키는 암호화 및 복호화에 사용됩니다. 키는 두 당사자가 공유해야 합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does Diffie-Hellman key exchange work?,디피-헬만 키 교환은 어떻게 작동하나요?,"2 parties agree on a G and a modulus p, and each party comes up with a number. One party does G^a and the other G^b. They pass this information. One party A computes the key from B as B^a mod p. B computes A^b mod p to get the key.",두 당사자는 G와 모듈러스 p에 동의하고 각 당사자는 숫자를 제시합니다. 한 당사자는 g^a를 하고 다른 당사자는 g^b를 합니다. 그들은 이 정보를 전달합니다. 한 당사자 A는 B에서 키를 b^a mod p로 계산합니다. B는 키를 얻기 위해 a^b mod p를 계산합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is Diffie-Hellman key exchange perfect?,디피-헬만 키 교환이 완벽한가요?,"No. A man in the middle can intercept one side, and communicate with parties A and B independently.",아니요. 중간에 있는 사람은 한쪽을 가로채서 A와 B 당사자와 독립적으로 소통할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How is RSA (using product of large primes) better than using NP-Complete algorithms for encryption?,RSA(큰 소수의 곱을 사용하는 것)가 암호화를 위해 NP-Complete 알고리즘을 사용하는 것보다 어떻게 더 나은가요?,"NP-Complete algorithms are hard in the worst case, but can be sometimes solved in linear time in the average case. Compositing the product of large primes is hard in the average case.",NP-완전 알고리즘은 최악의 경우 어렵지만 평균적인 경우 선형 시간으로 해결할 수도 있습니다. 큰 소수의 곱을 합성하는 것은 평균적인 경우 어렵습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Vigenere cipher?,비게네르 암호란 무엇인가요?,"Improvement on Caesar cipher. Letters are shifted based on a shifted dictionary. ""Polyalphabetic cipher""","시저 암호의 개선. 문자는 이동된 사전을 기반으로 이동됩니다. ""다중 알파벳 암호""",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a one-time pad encryption?,일회용 패드 암호화란 무엇인가요?,"The ""perfect"" simple encryption scheme. Pad/key is the same size as the message being encrypted. The key is randomly generated and xored against the plain text. Or key used to determine the amount each letter should be shifted.","""완벽한"" 간단한 암호화 방식입니다. 패드/키는 암호화되는 메시지의 크기와 동일합니다. 키는 무작위로 생성되어 일반 텍스트에 대해 탐색됩니다. 또는 각 문자가 이동해야 하는 양을 결정하는 데 사용되는 키입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is block size in cryptography?,암호화에서 블록 크기란 무엇인가요?,Symmetric key ciphers are generally divided into stream ciphers and block ciphers. Block ciphers operate on a fixed length string of bits. The length of this bit string is the block size. Both the input (plaintext) and output (ciphertext) are the same length; the output cannot be shorter than the input – this is logically required by the Pigeonhole principle and the fact that the cipher must be invertible – and it is simply undesirable for the output to be longer than the input.,"대칭 키 암호는 일반적으로 스트림 암호와 블록 암호로 나뉩니다. 블록 암호는 고정된 길이의 비트 문자열에서 작동합니다. 이 비트 문자열의 길이는 블록 크기입니다. 입력(평면 텍스트)과 출력(암호문)의 길이는 모두 동일하며, 출력은 입력보다 짧을 수 없습니다. 이는 Pionehole 원리와 암호가 가역적이어야 한다는 사실에 의해 논리적으로 요구되며, 출력이 입력보다 길어지는 것은 바람직하지 않습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the limiting factor of compression?,압축의 한계 요인은 무엇인가요?,"For lossless compression, it's entropy. For lossy compression, it's our acceptance with the amount of loss.",무손실 압축의 경우 엔트로피입니다. 무손실 압축의 경우 손실의 양에 대한 우리의 수용입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is LZ* compression based on?,LZ* 압축은 무엇을 기반으로 하나요?,Cataloging the positions and lengths of redundant patterns and combining the values with a dictionary.,중복 패턴의 위치와 길이를 목록화하고 값을 사전과 결합합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is LZMA?,What is LZMA?,It's a variant of LZ77 that uses Markov chains. It's used in the 7z compression algorithms used in 7-zip.,마르코프 체인을 사용하는 LZ77의 변형입니다. 7-zip에서 사용되는 7z 압축 알고리즘에 사용됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is DEFLATE?,디플레이션이란 무엇인가요?,"It's an lossless compression algorithm based on LZ77 used in Gzip, WinZip, and mod_deflate, which is bundled with Apache web server for automated gzip compression of HTTP served content. It uses LZ77 and Huffman coding.","Gzip, WinZip, mod_deflate에서 사용되는 LZ77 기반의 무손실 압축 알고리즘으로, HTTP 서비스 콘텐츠의 자동 Gzip 압축을 위해 Apache 웹 서버와 번들로 제공됩니다. LZ77과 허프만 코딩을 사용합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does LZ77-based compression work?,LZ77 기반 압축은 어떻게 작동하나요?,"LZ77 is a dictionary encoding algorithm, which is a statistical encoding algorithm. Compression in the LZ77 algorithm is based on the notion that strings of characters (words, phrases, etc.) occur repeatedly in the message being compressed.

The input is partitioned into 2 segments: a search buffer and a look-ahead buffer. The search buffer maxes out at 32KB. Starting with one character in the LA buffer, it looks back in the search buffer to find a copy of the symbol. If one is found, it looks at the second symbol of the LA buffer to see if it also matches the predecessor. Using this method, it can detect long phrases of symbols and encode them as one unit.

This process implicitly creates a rolling statistical probability for each symbol/phrase.","LZ77은 통계 인코딩 알고리즘인 사전 인코딩 알고리즘입니다. LZ77 알고리즘의 압축은 압축 중인 메시지에서 문자 문자열(단어, 구문 등)이 반복적으로 발생한다는 개념에 기반합니다.

입력은 검색 버퍼와 룩어헤드 버퍼의 두 세그먼트로 나뉩니다. 검색 버퍼는 32KB에서 최대치를 기록합니다. LA 버퍼에서 한 문자로 시작하여 검색 버퍼를 다시 찾아 심볼의 복사본을 찾습니다. 하나가 발견되면 LA 버퍼의 두 번째 심볼을 찾아 이전 심볼과도 일치하는지 확인합니다. 이 방법을 사용하면 심볼의 긴 구문을 감지하여 하나의 단위로 인코딩할 수 있습니다.

이 과정은 각 기호/구에 대해 암묵적으로 롤링 통계 확률을 생성합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Huffman encoding?,허프만 인코딩이란 무엇인가요?,"Huffman encoding algorithm analyzes the occurrence of individual symbols and creates a binary tree where the common symbols are closest to the root, using fewer bits to encode, and less common/rare symbols have longer paths on the tree, with longer encodings to accommodate. By traversing the tree, from root to leaf, and keeping track of 1 or 0 at each node, we can determine the encoding of the symbol.","허프만 인코딩 알고리즘은 개별 심볼의 발생을 분석하여 공통 심볼이 루트에 가장 가까운 이진 트리를 생성하고, 인코딩하는 비트 수가 적고, 공통/희귀 심볼이 적은 경우 트리의 경로가 길며, 인코딩하는 길이가 길어집니다. 루트에서 리프까지 트리를 탐색하고 각 노드에서 1 또는 0을 추적하여 심볼의 인코딩을 결정할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the primary factor of compression?,압축의 주요 요인은 무엇인가요?,Probability of redundant portions of input.,입력의 중복된 부분이 있을 확률.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you maximize compression?,압축을 최대화하려면 어떻게 해야 하나요?,By deeply analyzing the given input to reduce redundancy as much as possible.,주어진 입력을 깊이 분석하여 중복성을 최대한 줄입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What compression scheme uses Burrows-Wheeler transform?,버로우스 휠러 변환을 사용하는 압축 방식은 무엇인가요?,BZip2,BZip2,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Burrows-Wheeler transform?,버로우스-휠러 변환은 무엇인가요?,"It's a compression method involving the sorting of all possible rotations of the input text into lexicographic order. Take as output the last column and the index of the row that the original text appears in. 

To decode, take the single column and repeatedly add the final columns characters to each of the rows, sorting each time. Once you've reached the length of the column's height, use the index to find the output string.","입력 텍스트의 모든 가능한 회전을 사전 순서로 정렬하는 압축 방법입니다. 원본 텍스트가 표시되는 행의 마지막 열과 인덱스를 출력으로 사용합니다. 

디코딩하려면 단일 열을 가져와 각 행에 최종 열 문자를 반복적으로 추가하고 매번 정렬합니다. 열의 높이 길이에 도달하면 인덱스를 사용하여 출력 문자열을 찾습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"For Gzip in web servers, what is the usual setting?",웹 서버에서 Gzip의 일반적인 설정은 무엇인가요?,6,6,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the min and max compression settings in command line gzip?,명령줄 gzip에서 최소 및 최대 압축 설정은 무엇인가요?,0-9,0-9,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you make JSON better compressable with Gzip?,Gzip으로 JSON을 더 잘 압축할 수 있도록 하려면 어떻게 해야 하나요?,Transpose from multiple mini-dicts into one dict with arrays as the values. This allows the items in an array to fit within the 32KB search buffer common to LZ-based compression.,"여러 개의 미니 딕트에서 하나의 딕트로 전환하고, 배열을 값으로 사용합니다. 이렇게 하면 배열의 항목들이 LZ 기반 압축에 공통적으로 사용되는 32KB 검색 버퍼 내에 들어갈 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are Dense Codes?,밀집 코드란 무엇인가요?,"A way to put symbols or words into a dictionary or array, and use the indices as the values in the text to save space so that words are not repeated.","기호나 단어를 사전이나 배열에 넣고, 인덱스를 텍스트의 값으로 사용하여 단어가 반복되지 않도록 공간을 절약하는 방법입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the LZ in LZ compression?,LZ 압축에서 LZ는 무엇인가요?,Lempel-Ziv,렘펠-지브,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is OS hardware virtualization?,OS 하드웨어 가상화란 무엇인가요?,"The abstraction of heterogeneous hardware provided by the operating system, to hide the details of interfacing with various hardware so that they share a common interface for that type.",운영 체제에서 제공하는 이기종 하드웨어의 추상화는 다양한 하드웨어와의 인터페이스 세부 사항을 숨겨 해당 유형에 대한 공통 인터페이스를 공유하도록 합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a process?,프로세스란 무엇인가요?,"An instance of an executing program consisting of an address space and one or more threads of control. It has restricted rights. It owns a region of memory. It owns file descriptors, file system context. It encapsulates one or more threads sharing the process' resources. It is isolated from other processes.","주소 공간과 하나 이상의 제어 스레드로 구성된 실행 프로그램의 인스턴스입니다. 권한이 제한되어 있습니다. 메모리 영역을 소유하고 있습니다. 파일 설명자, 파일 시스템 컨텍스트를 소유하고 있습니다. 프로세스의 리소스를 공유하는 하나 이상의 스레드를 캡슐화합니다. 다른 프로세스와 분리되어 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a context switch?,컨텍스트 전환이란 무엇인가요?,The copying out and in of register state to switch from running one process to running another.,한 프로세스를 실행하는 것에서 다른 프로세스로 전환하기 위해 레지스터 상태를 복사하거나 복사하는 것입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the scheduler?,스케줄러가 무엇인가요?,The scheduler manages the priorities of user and OS processes.,스케줄러는 사용자 및 운영 체제 프로세스의 우선순위를 관리합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What causes operating systems to crash most of the time?,운영 체제가 대부분의 경우 충돌하는 원인은 무엇인가요?,"Device drivers. They are in the kernel and very low level. They have access to all the hardware, including memory. They are written by authors outside of the operating system.",장치 드라이버. 커널에 있고 매우 낮은 수준입니다. 메모리를 포함한 모든 하드웨어에 액세스할 수 있습니다. 운영 체제 외부의 저자가 작성한 것입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a process VM?,프로세스 VM이란 무엇인가요?,A virtual environment that supports the execution of a single program. This is provided by an operating system.,단일 프로그램 실행을 지원하는 가상 환경입니다. 운영 체제에서 제공합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a system VM?,시스템 VM이란 무엇인가요?,A virtual environment that supports the execution of an entire operating system and its applications.,전체 운영 체제와 그 응용 프로그램의 실행을 지원하는 가상 환경입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does the OS abstract the environment for a process?,OS는 프로세스 환경을 어떻게 추상화하나요?,"Each process thinks it has all the memory and CPU time, and thinks it owns all devices.","각 프로세스는 모든 메모리와 CPU 시간을 가지고 있다고 생각하며, 모든 장치를 소유하고 있다고 생각합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is fault isolation?,결함 격리란 무엇인가요?,Processes are unable to directly impact other processes. Bugs can't crash the whole machine.,프로세스는 다른 프로세스에 직접적인 영향을 미칠 수 없습니다. 버그는 전체 기계를 충돌시킬 수 없습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a thread?,실이란 무엇인가요?,"A single, unique execution context.",하나의 독특한 실행 컨텍스트.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the maximum address in memory for a 32 bit processor?,32비트 프로세서의 메모리 최대 주소는 얼마인가요?,2^32 - 1,2^32 - 1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the execution sequence for a program?,프로그램의 실행 순서는 무엇인가요?,"- Fetch instruction
- Decode
- Execute (perhaps using ALU and writing result to a register)
- Write results to registers or memory
- Increment program counter
- Repeat","- 가져오기 지침
- 디코딩
- 실행(아마도 ALU를 사용하여 레지스터에 결과를 작성하는 것)
- 레지스터 또는 메모리에 결과 쓰기
- 증분 프로그램 카운터
- 반복",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does the program counter point to?,프로그램 카운터는 무엇을 의미하나요?,An address in memory that contains the current instruction.,현재 명령어를 포함하는 메모리 내 주소입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the stack pointer?,스택 포인터란 무엇인가요?,A register that holds the address of the top of the stack portion of a process' memory.,프로세스 메모리의 스택 부분 상단 주소를 저장하는 레지스터입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the heap pointer?,힙 포인터란 무엇인가요?,A register that holds the address of the top of the heap portion of a process' memory.,프로세스 메모리의 힙 부분 상단 주소를 저장하는 레지스터입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is multiprogramming?,멀티프로그래밍이란 무엇인가요?,"Making one processor appear as multiple processors, each handling one process each.","하나의 프로세서를 여러 개의 프로세서로 보이게 하고, 각 프로세서는 각각 하나의 프로세스를 처리합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What triggers a context switch?,컨텍스트 전환의 원인은 무엇인가요?,"Timer interrupt, hardware interrupt, I/O where we're waiting for a read or write to complete (OS doesn't want to waste time waiting), voluntary yield.","타이머 인터럽트, 하드웨어 인터럽트, 읽기나 쓰기가 완료되기를 기다리는 입출력(OS는 기다리는 시간을 낭비하고 싶지 않습니다), 자발적인 수율.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is dual-mode operation?,듀얼 모드 작동이란 무엇인가요?,"Hardware provides at least 2 modes: user mode and kernel (aka: supervisor, protected) mode.","하드웨어는 최소 두 가지 모드를 제공합니다: 사용자 모드와 커널 모드(일명: 슈퍼바이저, 보호됨).",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does the OS run a program?,OS는 프로그램을 어떻게 실행하나요?,"It does an exec from kernel mode (system mode 1). We go to system mode 0, user mode. When the program exits, we switch back to kernel mode.","커널 모드(시스템 모드 1)에서 실행을 수행합니다. 시스템 모드 0, 사용자 모드로 이동합니다. 프로그램이 종료되면 커널 모드로 다시 전환합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does a user program interact with the kernel?,사용자 프로그램은 커null과 어떻게 상호작용하나요?,"It makes a system call, and the kernel takes over, completes the action, and the kernel returns to the process (back to user mode).",시스템 호출을 수행하면 커널이 작업을 완료하고 커널이 프로세스로 돌아갑니다(사용자 모드로 돌아갑니다).,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What happens when the hardware needs something to happen?,하드웨어에 무언가가 필요할 때는 어떻게 되나요?,"It does an interrupt, and the kernel takes control, switches the process, and once hardware task is complete, does a return from interrupt back to user mode.","It does an interrupt, and the kernel takes control, switches the process, and once hardware task is complete, does a return from interrupt back to user mode.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What happens when a program makes an exception?,프로그램이 예외를 만들면 어떻게 되나요?,"The program terminates, and switches to kernel mode.",프로그램이 종료되고 커널 모드로 전환됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is base and bound?,베이스 앤 바운드란 무엇인가요?,It's a memory addressing restriction where a processes are only allowed access to the memory between a base address and the bound + base addresses. Each process has its own base and bound. A drawback is you don't get address 0. Address translation fixes this.,프로세스가 기본 주소와 바인딩 + 기본 주소 사이에서만 메모리에 액세스할 수 있는 메모리 주소 지정 제한입니다. 각 프로세스에는 고유한 기본 및 바인딩이 있습니다. 단점은 주소 0을 얻지 못한다는 것입니다. 주소 변환을 통해 이 문제를 해결할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does the OS know how to handle an interrupt?,OS는 인터럽트를 어떻게 처리하는지 알고 있나요?,It keeps an interrupt vector in the memory of the OS. Each interrupt type is mapped to an address to execute. They are just pointers to code in the OS.,OS의 메모리에 인터럽트 벡터를 유지합니다. 각 인터럽트 유형은 실행할 주소로 매핑됩니다. 이는 OS의 코드에 대한 포인터일 뿐입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the difference between PC and uPC?,PC와 uPC의 차이점은 무엇인가요?,PC is the program counter for the current process. uPC is the PC of the user process we will return to once an interrupt or other OS process switches context.,PC는 현재 프로세스의 프로그램 카운터입니다. uPC는 인터럽트 또는 기타 운영 체제 프로세스가 컨텍스트를 전환하면 반환되는 사용자 프로세스의 PC입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How are base and bound enforced?,기지와 경계는 어떻게 시행되나요?,They are stored in registers. Access is restricted by the hardware.,레지스터에 저장됩니다. 하드웨어에 의해 액세스가 제한됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does x86 do segments and stacks?,x86은 세그먼트와 스택을 어떻게 하나요?,"Each process' individual segments (heap, stack, code, static data) get their own base and bound. They don't even need to be adjacent in memory and their location is hidden by memory addressing.","각 프로세스의 개별 세그먼트(히프, 스택, 코드, 정적 데이터)는 고유한 베이스와 바운드를 얻습니다. 메모리에 인접할 필요도 없고 메모리 주소 지정을 통해 위치가 숨겨집니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"When a process forks, what happens?",프로세스가 중단되면 어떻게 되나요?,"The process is paused, and a complete copy is made: code, stack, heap, data, program counter and registers.
The child and parent resume with returning from fork syscall.","프로세스가 일시 중지되고 코드, 스택, 힙, 데이터, 프로그램 카운터 및 레지스터와 같은 완전한 복사본이 만들어집니다.
아이와 부모는 포크 시스콜에서 돌아오는 것으로 재개합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does fork() return?,포크()는 무엇을 반환하나요?,"It returns the child process id to the parent, and 0 to the child. < 0 if error.","자식 프로세스 ID를 부모에게 반환하고, 자식에게 0을 반환합니다. 오류가 발생하면 < 0입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does wait() do?,What does wait() do?,Causes the parent process to pause until the child terminates.,자식이 종료될 때까지 부모 프로세스가 일시 중지됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does exec() do?,What does exec() do?,It's a system call to change the currently running program to something else.,현재 실행 중인 프로그램을 다른 프로그램으로 변경하기 위한 시스템 호출입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What comes back from wait()?,기다림()에서 돌아오는 것은 무엇인가요?,"on success, returns the process ID of the terminated child; on error, -1 is returned.","성공하면 종료된 자식의 프로세스 ID를 반환하고, 오류가 발생하면 -1을 반환합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a signal?,신호란 무엇인가요?,A system call to send a notification to another process.,다른 프로세스에 알림을 보내기 위한 시스템 호출입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In a child process, what can you do with fork and then exec?",아동 과정에서 포크로 무엇을 한 다음 실행할 수 있나요?,Create a completely new process and then exit.,완전히 새로운 프로세스를 만든 다음 종료하세요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a shell?,껍질이란 무엇인가요?,A job control program. It allows a programmer to create and manage a set of programs to do some task.,작업 제어 프로그램. 프로그래머가 작업을 수행하기 위해 일련의 프로그램을 만들고 관리할 수 있게 해줍니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a microsecond? Also known as μs,마이크로초란 무엇인가요? μs라고도 합니다,1 millionth of a second.,백만 분의 일 초.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a nanosecond?,나노초란 무엇인가요?,1 billionth of a second. ns,10억 분의 1초. ns,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a picosecond?,피코초란 무엇인가요?,A trillionth of a second.,1조 분의 1초.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does the kernel handle reads and writes?,커널은 읽기와 쓰기를 어떻게 처리하나요?,It buffers reads so they can be handled as a stream in your program. Writes are buffered and are not written until the kernel flushes the buffer.,읽기를 버퍼링하여 프로그램의 스트림으로 처리할 수 있습니다. 쓰기는 버퍼링되며 커null이 버퍼를 플러시할 때까지 쓰기되지 않습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What's the difference between the fread, read, fwrite, write I/O calls?","읽기, 읽기, 쓰기, 쓰기 I/O 호출의 차이점은 무엇인가요?",The ones with f are high-level I/O and streamed and buffered by the kernel. The non-f are low-level I/O.,f가 있는 것은 고수준 I/O이며 커널에 의해 스트리밍되고 버퍼링됩니다. 비f는 저수준 I/O입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"When a system call is made, where are parameters stored?",시스템 호출이 이루어질 때 매개변수는 어디에 저장되나요?,In registers.,레지스터에.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a socket?,socket이란 무엇인가요?,"It's an abstraction of a network I/O queue.  It's a method of communication where a producer writes to one side, and a consumer reads from the other side. It's similar to writing and reading a file, but no file is involved.",네트워크 I/O 대기열을 추상화한 것입니다. 생산자는 한쪽에 글을 쓰고 소비자는 다른 쪽에서 글을 읽는 통신 방식입니다. 파일을 쓰고 읽는 것과 비슷하지만 파일은 포함되지 않습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What sockets are in modern use?,현대에는 어떤 socket이 있나요?,"Local sockets to local machine, called UNIX sockets, and TCP/IP and UDP/IP.","로컬 socket을 로컬 머신에 연결하는 UNIX socket이라고 하며, TCP/IP와 UDP/IP입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the GIL?,GIL이란 무엇인가요?,"It's the Global Interpreter Lock. It's is a part of CPython. It ensures only one thread runs in the interpreter at once. Having the GIL simplifies many low-level details (memory management, callouts to C extensions, etc.)","글로벌 인터프리터 잠금 장치입니다. CPython의 일부입니다. 인터프리터에서 한 번에 하나의 스레드만 실행되도록 보장합니다. GIL을 사용하면 메모리 관리, C 확장 호출 등 많은 하위 수준의 세부 사항을 간소화할 수 있습니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
When is the GIL released?,GIL은 언제 출시되나요?,"During I/O (disk IO, network IO, output to display) including when a thread uses sleep.","I/O 중(디스크 IO, 네트워크 IO, 출력 표시)에는 스레드가 절전 모드를 사용할 때가 포함됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What is a ""tick"" in CPython?","CPython에서 ""틱""이란 무엇인가요?",Approximately 1 machine instruction.,대략 1개의 기계 명령어.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What happens every 100 ""ticks"" in the CPython interpreter?","CPython 인터프리터에서 100개의 ""틱""마다 무슨 일이 일어나나요?",A thread check occurs during which the thread releases the GIL then attempts to reacquire it. Other Python threads will contend for the the GIL. This is no longer the case in 3.4.,스레드가 GIL을 해제한 후 다시 획득하려고 시도하는 동안 스레드 검사가 발생합니다. 다른 파이썬 스레드들도 GIL을 놓고 경쟁하게 됩니다. 3.4에서는 더 이상 그렇지 않습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a lock in CPython?,CPython에서 자물쇠란 무엇인가요?,It's a binary semaphore. It's not a mutex lock.,이진 세마포어입니다. 뮤텍스 자물쇠가 아닙니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What happens when the heap gets too large?,더미가 너무 커지면 어떻게 되나요?,"It does a page fault, and the kernel will allocate more memory.",페이지 오류가 발생하면 커null이 더 많은 메모리를 할당합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What happens when the heap and stack meet in memory?,힙과 스택이 메모리에서 만나면 어떻게 되나요?,A guard page is hit and the process is killed.,경비원 페이지가 열리고 프로세스가 종료됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Where is information about a process stored?,프로세스에 대한 정보는 어디에 저장되나요?,In a PCB (process control block).,PCB(공정 제어 블록)에서.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Where is information about a thread stored?,스레드에 대한 정보는 어디에 저장되어 있나요?,In a TCB (thread control block).,TCB(스레드 제어 블록)에서.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What do multiple threads in the same process share?,같은 프로세스의 여러 스레드가 공유하는 것은 무엇인가요?,"Heap, file descriptors, code, static data.","힙, 파일 설명자, 코드, 정적 데이터.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What do threads in a process NOT share?,프로세스의 스레드는 무엇을 공유하지 않나요?,Registers and stack.,등록하고 쌓습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What can happen with thread stacks if one goes into a deep recursion?,깊은 재귀에 들어가면 스레드 스택에서 어떤 일이 발생할 수 있나요?,One thread's stack can grow into another thread's stack and write over it. A guard page can help to protect from that.,한 스레드의 스택이 다른 스레드의 스택으로 성장하여 그 위에 쓸 수 있습니다. 가드 페이지는 이를 방지하는 데 도움이 될 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What can cause a thread to give control back to the dispatcher?,스레드가 디스패처에 다시 제어권을 부여하는 원인은 무엇인가요?,"Thread returns control voluntarily (yield, requesting I/O (which blocks), wait for signal from another thread) or gets preempted by an interrupt.","스레드는 자발적으로 제어를 반환하거나(수익률, I/O 요청, 차단, 다른 스레드의 신호 대기) 인터럽트에 의해 선점됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How long does it take to do a process context switch?,프로세스 컨텍스트 전환을 수행하는 데 얼마나 걸리나요?,3-4 microseconds.,3-4 마이크로초.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How long does it take to perform a thread context switch?,스레드 컨텍스트 전환을 수행하는 데 얼마나 걸리나요?,100ns,100ns,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How often do context switches happen?,컨텍스트 전환은 얼마나 자주 일어나나요?,Every 10-100 ms.,매 10-100ms마다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Context switch time increases sharply with the size of what? (by 100x or more.),컨텍스트 전환 시간은 무엇의 크기에 따라 급격히 증가하나요? (100배 이상 증가합니다.),The working set - the subset of memory used by the process in a time window. Cache etc.,작업 세트 - 프로세스가 시간 창에서 사용하는 메모리의 하위 집합입니다. 캐시 등.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What happens in a system call to get the OS to switch to kernel mode?,OS를 커널 모드로 전환하려면 시스템 호출에서 어떤 일이 발생하나요?,A trap.,함정.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many threads should you run per process?,프로세스당 몇 개의 스레드를 실행해야 하나요?,One per core.,코어당 하나.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How is concurrency accomplished?,동시성은 어떻게 이루어지나요?,By multiplexing CPU time.,CPU 시간을 다중화함으로써.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the difference between parallelism and concurrency?,병렬성과 동시성의 차이점은 무엇인가요?,"Concurrency means running multiple blocks of instructions independently. Parallelism means running instructions at the same time, as on multiple cores at once.",동시성은 여러 블록의 명령어를 독립적으로 실행하는 것을 의미합니다. 병렬 처리는 여러 코어에서 동시에 명령어를 실행하는 것을 의미합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is oversubscription?,초과 구독이란 무엇인가요?,Spawning more threads than available cores.,사용 가능한 코어보다 더 많은 스레드를 생성합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a race condition?,인종 조건이란 무엇인가요?,When the outcome of a deterministic procedure becomes non-deterministic based on differences in subprocess timing.,결정론적 절차의 결과가 하위 프로세스 타이밍의 차이에 따라 비결정론적이 되는 경우.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What can you put in place to exclusively use a resource without another process interfering?,다른 프로세스를 방해하지 않고 리소스를 독점적으로 사용하기 위해 무엇을 배치할 수 있나요?,"A mutex, or even better, a lock guard.","뮤텍스, 더 좋은 것은 자물쇠 가드입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How do you use a mutex in Python?,파이썬에서 뮤텍스는 어떻게 사용하나요?,"import threading

lock = threading.Lock()

[first process]
global lock
lock.release()
...
[other process]
global lock
lock.acquire() // attempts to get access, waits if it can't","스레드 가져오기

잠금 = 스레드.잠금()

[첫 번째 과정]
전역 잠금
잠금 해제.() 해제
...
[다른 과정]
전역 잠금
lock.acquire() // 액세스를 시도하고, 접속할 수 없으면 기다립니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does a future do?,미래는 무엇을 하나요?,Allows us to receive a return value from a function in a child thread.,Allows us to receive a return value from a function in a child thread.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a promise?,약속이란 무엇인가요?,A promise to send a parameter to a child thread's function later.,나중에 자식 스레드의 함수에 매개변수를 보내겠다는 약속.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is livelock?,라이브록이란 무엇인가요?,"It occurs when multiple processes are attempting to deal with the current state, but neither makes progress. This can happen when a system is attempting to resolve a deadlock situation but another or the same process continue to trigger it.
Starvation is another example.","여러 프로세스가 현재 상태를 처리하려고 시도하지만 둘 다 진전을 이루지 못할 때 발생합니다. 이는 시스템이 deadlock를 해결하려고 시도하지만 다른 프로세스 또는 동일한 프로세스가 계속 트리거될 때 발생할 수 있습니다.
기아도 또 다른 예입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How long does a terminated process stay in the terminated state?,종료된 프로세스는 종료된 상태에서 얼마나 오래 머무르나요?,Until the parent process does a wait to receive its exit code.,부모 프로세스가 종료 코드를 받기 위해 대기할 때까지.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In Python, what can you use to fork a process?",파이썬에서 프로세스를 포크하는 데 무엇을 사용할 수 있나요?,The multiprocessing module. It supports process Pool and Process for making a pool of worker processes or forking temporary subprocesses.,다중 처리 모듈. 작업자 프로세스 풀을 만들거나 임시 하위 프로세스를 포크하는 프로세스 풀 및 프로세스를 지원합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does the concurrent.futures module offer?,동시 선물 모듈은 무엇을 제공하나요?,"ThreadPoolExecutor
ProcessPoolExecutor
Executor objects
Future objects","ThreadPoolExecutor
프로세스풀 실행기
실행자 객체
미래 객체",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an interrupt?,인터럽트란 무엇인가요?,A hardware-invoked context switch. The interrupt handler always runs immediately.,하드웨어로 호출된 컨텍스트 스위치. 인터럽트 핸들러는 항상 즉시 실행됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What happens during an interrupt?,인터럽트 중에 무슨 일이 일어나나요?,"The currently running process' state is saved. We switch to kernel mode, the interrupt handler runs, and once its complete, the system goes back to user mode and the process continues.","현재 실행 중인 프로세스' 상태가 저장됩니다. 커널 모드로 전환하고 인터럽트 핸들러가 실행되며, 완료되면 시스템이 다시 사용자 모드로 돌아가 프로세스가 계속됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What really happens when you fork a process?,프로세스를 포크하면 실제로 어떤 일이 일어날까요?,"A fork doesn't copy everything, it just duplicates the page table pointers, which are all set at read-only. Called copy-on-write. Once you write to memory, then it copies the state.",포크는 모든 것을 복사하는 것이 아니라 읽기 전용으로 설정된 페이지 테이블 포인터를 복제할 뿐입니다. 이를 카피 온 라이트라고 합니다. 메모리에 글을 쓰면 상태가 복사됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is multiprocessing?,다중 처리란 무엇인가요?,Parallel execution on multiple cores.,다중 코어에서 병렬 실행.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does a PCB contain?,PCB에는 무엇이 포함되어 있나요?,"Everything about a process:
- status
- register state (when not in ready state)
- PID, User, Executable, Priority
- Execution time
- Memory space, translation","프로세스의 모든 것:
- 상태
- 상태 등록(준비되지 않은 경우)
- PID, 사용자, 실행 파일, 우선순위
- 실행 시간
- 메모리 공간, 번역",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is special about an interrupt handler?,인터럽트 핸들러의 특별한 점은 무엇인가요?,It disables interrupts and runs to completion.,인터럽트를 비활성화하고 완료까지 실행합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the five states a process can be in?,프로세스가 가질 수 있는 다섯 가지 상태는 무엇인가요?,"- new (when being created)
- ready
- running
- waiting (for I/O or event coordination)
- terminated (waits for parent process to receive its exit code)","- 새로 생성될 때
- 준비 완료
- 달리기
- 대기(I/O 또는 이벤트 조정 대기)
- 종료됨(부모 프로세스가 종료 코드를 수신하는 waits)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the difference between filter() and map()?,필터()와 맵()의 차이점은 무엇인가요?,"Filter uses a function that returns true or false (predicate).
Map uses a function that returns a value.","필터는 true 또는 false(예언)을 반환하는 함수를 사용합니다.
지도는 값을 반환하는 함수를 사용합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is synchronization?,동기화란 무엇인가요?,Using atomic operations to ensure cooperation between threads.,원자 연산을 사용하여 스레드 간의 협력을 보장합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a critical section?,중요한 섹션이란 무엇인가요?,"A block of code that you lock before entering, then unlock when leaving. This creates a mutual exclusion on shared data.",입력하기 전에 잠그고 나갈 때 잠금 해제하는 코드 블록입니다. 이렇게 하면 공유 데이터에 대한 상호 배제가 발생합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the priority inversion problem?,우선순위 역전 문제는 무엇인가요?,"A thread that is busy-waiting for a lock to be released ends up stealing CPU and getting a higher priority than the thread with the lock. SO since the waiting thread gets higher priority, the thread holding the lock can't complete and release the lock.",잠금이 해제되기를 기다리는 스레드는 CPU를 훔쳐서 잠금이 있는 스레드보다 더 높은 우선순위를 얻게 됩니다. 따라서 대기 중인 스레드가 우선순위가 높기 때문에 잠금을 유지하는 스레드가 잠금을 완료하고 해제할 수 없습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is busy-waiting?,바쁘게 기다리는 것이 무엇인가요?,"One or more threads is using a lot of CPU by continuously checking a value, or test&set() checking and writing a value in wiating for a lock to release, thus stealing CPU from the thread holding the lock.","하나 이상의 스레드는 값을 지속적으로 확인하거나, 잠금이 해제되기를 기다리는 동안 값을 확인하고 기록하여 잠금을 유지하는 스레드에서 CPU를 훔치는 방식으로 많은 CPU를 사용하고 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a semaphore?,세마포어란 무엇인가요?,"A semaphore (defined by Dijkstra) is kind of signaling solution for handling concurrency data integrity problems that arise in multi-threaded applications. It has a non-negative integer that supports 2 operations:
- P() [proberen, to test/probe] - atomic operation that waits for semaphore to become > 1, then decrements it by 1 (wait)
- V() [verhogen, to increment] - an atomic operation that increments the semaphore by 1, waking up any P (signal)

The initial semaphore value will determine how many threads can run in the critical section at once.","A semaphore (defined by Dijkstra) is kind of signaling solution for handling concurrency data integrity problems that arise in multi-threaded applications. It has a non-negative integer that supports 2 operations:
- P() [proberen, to test/probe] - atomic operation that waits for semaphore to become > 1, then decrements it by 1 (wait)
- V() [verhogen, to increment] - an atomic operation that increments the semaphore by 1, waking up any P (signal)

The initial semaphore value will determine how many threads can run in the critical section at once.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's another name for a mutual exclusion?,상호 배제의 다른 이름은 무엇인가요?,Binary semaphore.,이진 세마포어.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a monitor?,모니터란 무엇인가요?,A lock and zero or more condition variables for managing concurrent access to shared data.,공유 데이터에 대한 동시 접근을 관리하기 위한 잠금 및 0개 이상의 조건 변수.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What should locks and condition variables each be used for?,잠금 장치와 상태 변수는 각각 무엇에 사용해야 하나요?,"locks - mutual exclusion
condition variables - scheduling constraints","잠금 - 상호 제외
조건 변수 - 스케줄링 제약 조건",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a condition variable?,조건 변수란 무엇인가요?,A queue of threads waiting for access to something in a critical section.,중요한 섹션에서 무언가에 대한 접근을 기다리는 스레드의 줄.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a special feature of condition variables?,조건 변수의 특별한 특징은 무엇인가요?,It allows sleeping inside a critical section by atomically releasing lock at the time we sleep.,우리가 잠을 잘 때 원자적으로 잠금 장치를 해제하여 중요한 구역 안에서 잠을 잘 수 있게 해줍니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the 3 methods on a condition variable?,조건 변수에 대한 3가지 방법은 무엇인가요?,"wait(&lock)
signal() - signals the next waiting member
broadcast() - signals all waiting members","대기(&잠금)
신호 () - 다음 대기 멤버에게 신호를 보냅니다
방송 () - 대기 중인 모든 멤버에게 신호를 보냅니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What type of scheduling do most modern processors use?,대부분의 최신 프로세서는 어떤 종류의 스케줄링을 사용하나요?,Mesa-scheduling.,메사 스케줄링.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some things the scheduler tries to accomplish?,스케줄러가 달성하려고 하는 것들은 무엇인가요?,"- minimize response time
- maximize throughput
- fairness","- 응답 시간 최소화
- 처리량 최대화
- 공정성",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a drawback of context switching?,문맥 전환의 단점은 무엇인가요?,CPU cache misses as thread comes back from switching and finds the CPU cache doesn't have the values it had before.,스레드가 스위칭에서 돌아와 CPU 캐시가 이전 값을 가지지 않는다는 것을 발견하면 CPU 캐시가 누락됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's the convoy effect?,호송 효과는 무엇인가요?,Short processes get stuck behind long processes in a FIFO style ready queue.,짧은 프로세스는 FIFO 스타일의 준비 대기열에서 긴 프로세스 뒤에 갇혀 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the round robin scheduling scheme?,라운드 로빈 스케줄링 방식이란 무엇인가요?,"Each process gets a time quantum q milliseconds to run. 10-100ms, the q is tunable. Each process runs for that time slice (or until completion if close to done) and then goes back on the ready queue.",각 프로세스는 실행되는 데 시간 양자 q 밀리초가 걸립니다. 10-100ms 동안 q는 조정할 수 있습니다. 각 프로세스는 해당 시간 슬라이스(또는 완료에 가까울 경우 완료될 때까지) 동안 실행된 다음 준비 대기열로 돌아갑니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are pros of the round-robin scheduling scheme?,라운드 로빈 스케줄링 방식의 장점은 무엇인가요?,"- better for short jobs (they fit in the time slice)
- fair","- 짧은 작업에 더 적합합니다 (시간 단축에 맞습니다)
- 공정한",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a con of the round-robin scheduling scheme?,라운드 로빈 스케줄링 방식의 단점은 무엇인가요?,Long jobs take longer because context-switching time adds up.,긴 작업은 컨텍스트 전환 시간이 늘어나기 때문에 더 오래 걸립니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How long does context switching take?,컨텍스트 전환은 얼마나 걸리나요?,"0.1ms - 1ms
It's roughly 1% overhead.","0.1ms - 1ms
대략 1%의 오버헤드입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is starvation?,기아란 무엇인가요?,When low-priority jobs never get run because there are always higher priority jobs running.,우선순위가 낮은 작업이 항상 더 높은 우선순위의 작업이 실행되기 때문에 실행되지 않을 때.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does a process' priority get changed?,프로세스의 우선순위는 어떻게 변경되나요?,"The scheduler utilizes heuristics on interactivity, locking, burst behavior, etc.","스케줄러는 상호작용성, 잠금, 버스트 동작 등에 대한 휴리스틱을 활용합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some methods of avoiding deadlock?,deadlock를 피하는 방법에는 어떤 것들이 있나요?,"- don't allow waiting for a resource (means a lot of retries)
- make all threads request everything they'll need at the beginning
- force all threads to request resources in a particular order preventing any cyclic uses of resources (so no cycle exists)
- temporarily expand resources when a deadlock is detected","- 리소스 대기를 허용하지 않습니다(means 많은 재시도)
- 모든 스레드가 처음에 필요한 모든 것을 요청하도록 합니다
- 자원의 순환적 사용을 방지하기 위해 모든 스레드가 특정 순서로 자원을 요청하도록 강제합니다(그래서 사이클이 존재하지 않음)
- deadlock가 감지되면 일시적으로 리소스를 확장합니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the banker's algorithm for preventing deadlock?,deadlock를 방지하기 위한 은행가의 알고리즘은 무엇인가요?,"- allocate resources dynamically
- evaluate each request and grant if some ordering of threads is still deadlock-free afterward
- do so by pretending the request was granted, then running a simulation to see if a deadlock would occur","- 자원을 동적으로 할당하다
- 각 요청을 평가하고 스레드의 일부 순서가 이후에도 deadlock가 없는지 승인합니다
- 요청이 승인된 것처럼 행동한 다음 시뮬레이션을 실행하여 deadlock가 발생하는지 확인합니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does the banker's algorithm solve the dining lawyers problem?,은행가의 알고리즘은 식당 변호사 문제를 어떻게 해결하나요?,"When you try to grab a chopstick, it's either:
- not the last chopstick
- is last chopstick but someone else will have two afterwards","젓가락을 잡으려고 할 때, 그것은 둘 중 하나입니다:
- 마지막 젓가락이 아닙니다
- 마지막 젓가락이지만 나중에 다른 사람이 두 개를 갖게 될 것입니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Does the CPU use virtual addresses or physical addresses?,"CPU는 가상 주소를 사용하나요, 아니면 물리적 주소를 사용하나요?",Virtual addresses,가상 주소,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What translates virtual to physical addresses?,가상 주소를 물리적 주소로 변환하는 것은 무엇인가요?,The MMU - the memory management unit,MMU - 메모리 관리 장치,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the four conditions needed for a deadlock?,deadlock에 빠지기 위해 필요한 네 가지 조건은 무엇인가요?,"- mutual exclusion
- hold and wait
- no preemption
- circular wait","- 상호 배제
- 잡고 기다리다
- 선점 없음
- 순환 대기",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many bits represent an IPv4 address?,IPv4 주소는 몇 비트인가요?,32,32,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many bits represent an IPv6 address?,IPv6 주소는 몇 비트인가요?,128,128,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Name some of the protocols used within the TCP/IP application layer.,TCP/IP 애플리케이션 계층에서 사용되는 몇 가지 프로토콜의 이름을 말하세요.,"- http
- https
- ftp
- tftp
- ntp
- irc
- telnet
- smtp
- ssh
- dns
- snmp
- pop3","- http
- https
- FTP
- tftp
- ntp
- irc
- 텔넷
- SMTP
- SSH
- DNS
- SNMP
- 팝3",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is NTP?,NTP란 무엇인가요?,Network time protocol,네트워크 시간 프로토콜,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some protocols in the TCP/IP transport layer?,TCP/IP 전송 계층에는 어떤 프로토콜이 있나요?,"- TCP
- UDP","- TCP
- UDP",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some TCP/IP network layer protocols?,TCP/IP 네트워크 계층 프로토콜이란 무엇인가요?,"IP - internet protocol
ICMP - internet control message protocol
ARP - address resolution protocol","IP - 인터넷 프로토콜
ICMP - 인터넷 제어 메시지 프로토콜
ARP - 주소 확인 프로토콜",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some TCP/IP network access layer protocols?,TCP/IP 네트워크 액세스 계층 프로토콜에는 어떤 것이 있나요?,"- RJ45
- ISDN
- Microwave
- Ethernet
- Wifi
- Fiber optics
- ATM
- RJ48
- Copper cables","- RJ45
- ISDN
- 전자레인지
- 이더넷
- 와이파이
- 광섬유
- ATM
- RJ48
- 구리 케이블",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a PDU?,PDU란 무엇인가요?,"Protocol data unit
- generic term used to describe the information at a given layer in the TCP/IP stack","프로토콜 데이터 단위
- TCP/IP 스택의 특정 계층에서 정보를 설명하는 데 사용되는 일반 용어",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the PDU for OSI layer 7?,OSI 레이어 7의 PDU는 무엇인가요?,"data, determined by what information is being exchanged: text, encrypted text, compressed data","교환되는 정보에 따라 결정되는 데이터: 텍스트, 암호화된 텍스트, 압축된 데이터",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the PDUs for the the OSI transport layer?,OSI 전송 계층의 PDU는 무엇인가요?,"for TCP, it's called a segment
for UDP, it's called a datagram","TCP의 경우 세그먼트라고 합니다
UDP의 경우 데이터그램이라고 합니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the PDU for the TCP/IP internet layer?,TCP/IP 인터넷 계층의 PDU는 무엇인가요?,packet,패킷,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the 2 PDUs of the OSI Network Access layer?,OSI 네트워크 액세스 계층의 2개 PDU는 무엇인가요?,"data link layer: frames
physical layer: bits","데이터 링크 계층: 프레임
물리 계층: 비트",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the port for DNS?,DNS 포트는 무엇인가요?,53,53,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the port for telnet?,텔넷의 포트는 무엇인가요?,23,23,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the port for ssh?,SSH의 포트는 무엇인가요?,22,22,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the port range for clients?,고객의 포트 범위는 어떻게 되나요?,8000-65535,8000-65535,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many bits are in an ethernet frame?,이더넷 프레임에는 몇 비트가 있나요?,"48 bits, represented as a hexadecimal number.","48비트, 16진수로 표시됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does MAC stand for?,MAC은 무엇을 의미하나요?,"medium access control, a sublayer in the data link layer.","매체 접근 제어, 데이터 링크 계층의 하위 계층.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the PDU and the addressing at the data link layer?,데이터 링크 계층에서 PDU와 주소 지정은 무엇인가요?,"PDU: frame
Addressing: physical (MAC) address","PDU: 프레임
주소 지정: 물리적(MAC) 주소",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What devices are at the data link layer?,데이터 링크 계층에는 어떤 장치가 있나요?,"Bridges, switches (multi-port bridge). They inspect frames and forward or not.","브리지, 스위치(멀티포트 브리지). 프레임을 검사하고 전방 여부를 확인합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What devices are at the Internet/Network layer?,인터넷/네트워크 계층에는 어떤 장치가 있나요?,"Routers
Layer 3 switches: can be a switch or a router","라우터
레이어 3 스위치: 스위치 또는 라우터일 수 있습니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the PDU and the addressing at the Internet/Network layer?,인터넷/네트워크 계층에서 PDU와 주소 지정은 무엇인가요?,"PDU: packet
Addressing IP address","PDU: 패킷
주소 지정 IP 주소",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the PDU and the addressing at the Transport layer?,전송 계층에서 PDU와 주소 지정은 무엇인가요?,"PDU: segment
addressing: ports","PDU: 세그먼트
주소 지정: 포트",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What devices are at the Transport layer?,전송 계층에는 어떤 장치가 있나요?,Firewalls,방화벽,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a socket in HTTP?,HTTP에서 socket이란 무엇인가요?,The combination of an IP address and a port.,IP 주소와 포트의 조합.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is involved in the 3 way handshake (TCP)?,3자 악수(TCP)에는 무엇이 관여하나요?,"SYN=1 - synchronize, gives a Seq number and expects that number + 1 in response
ACK=1 - sent by acknowledging server with incremented number, who also sends a SYN=1 and a Seq
SYN=0 ACK=1 and the Seq (incremented number) back to the server

Now you're talking!","SYN=1 - 동기화하고 Seq 번호를 제공하며 응답에서 숫자 + 1을 기대합니다
ACK=1 - SYN=1 및 Seq도 전송하는 서버를 확인하여 전송합니다
SYN=0 ACK=1 및 Seq(증가된 숫자)가 서버로 돌아갑니다

이제 말하는군요!",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Does Kerberos use symmetric or asymmetric encryption?,케르베로스는 대칭 암호화 또는 비대칭 암호화를 사용하나요?,Symmetric. It tracks all principals and their keys in its KDC table.,대칭. KDC 테이블의 모든 주체와 키를 추적합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the 7 layers of the OSI model?,OSI 모델의 7가지 레이어는 무엇인가요?,"- application
- presentation
- session
- transport
- network
- data link
- physical","- 응용 프로그램
- 프레젠테이션
- 세션
- 운송
- 네트워크
- 데이터 링크
- 물리적",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the 4 layers of TCP/IP?,TCP/IP의 4가지 계층은 무엇인가요?,"- application (application, presentation, session in OSI)
- transport
- internet (network in OSI)
- network access (data link & physical in OSI)","- 애플리케이션(OSI에서 애플리케이션, 프레젠테이션, 세션)
- 운송
- 인터넷(OSI의 네트워크)
- 네트워크 액세스(OSI의 데이터 링크 및 물리적)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How is an SSL certificate generated by the certificate authority (CA)?,SSL 인증서는 인증 기관(CA)에서 어떻게 생성되나요?,"The common name and public key for a given domain name, signed by the certificate authority's secret key.
The browser can verify the cert with CA's public key.","인증 기관의 비밀 키로 서명된 특정 도메인 이름의 일반 이름과 공개 키입니다.
브라우저는 CA의 공개 키로 인증서를 확인할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the secure flag on a cookie?,쿠키의 보안 깃발은 무엇인가요?,"When set on a cookie, it will only be sent on https requests.
When not set, cookie will be sent on both http and https requests.","쿠키를 설정하면 https 요청에만 전송됩니다.
설정되지 않으면 쿠키는 http와 https 요청 모두에 전송됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
When does a Python multi-threaded program terminate?,파이썬 멀티 스레드 프로그램은 언제 종료되나요?,The entire Python program exits when no alive non-daemon threads are left.,살아있는 비데몬 스레드가 남아 있지 않으면 전체 파이썬 프로그램이 종료됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In Python, if a thread is set to daemon, what happens when the thread sleeps?",파이썬에서 스레드가 데몬으로 설정되어 있으면 스레드가 절전 모드로 전환되면 어떻게 되나요?,"If the Python program reaches its end, the thread will be killed even if it's sleeping.","파이썬 프로그램이 종료되면, 스레드가 잠들어 있어도 종료됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"If a thread is a daemon, what happens when you do a join()?",스레드가 데몬인 경우 조인()을 하면 어떻게 되나요?,The main thread will wait for it.,메인 스레드가 그것을 기다릴 것입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does WebRTC stand for?,WebRTC는 무엇을 의미하나요?,Web Real-Time Communication,웹 실시간 커뮤니케이션,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Give an example of the thread-per-connection pattern.,연결당 스레드 패턴의 예를 들어보세요.,"A web server might spawn a thread per connection, then reuse that thread once the connection ends, or terminate the thread.","웹 서버는 연결당 스레드를 생성한 다음, 연결이 끝나면 해당 스레드를 재사용하거나 스레드를 종료할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Give an example of the thread pool model.,스레드 풀 모델의 예를 들어보세요.,A pool of threads can be maintained in order to quickly provide one as a resource for a database connection.,스레드 풀을 유지 관리하여 데이터베이스 연결을 위한 리소스로 빠르게 제공할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Fibonacci in Python,파이썬의 피보나치,"def fib(n):
    a, b = 1, 1
    for i in range(1, n):
        a, b = b, a + b

    return a","def fib(n):
    a, b = 1, 1
    for i in range(1, n):
        a, b = b, a + b

    return a",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is contained in a packet?,패킷에는 무엇이 포함되어 있나요?,"- source IP
- destination IP
- data - some portion of the final payload","- 소스 IP
- 목적지 IP
- 데이터 - 최종 페이로드의 일부",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is TLS?,TLS란 무엇인가요?,The successor to SSL. All of SSL's versions have been deprecated due to security issues.,SSL의 후속 버전입니다. 보안 문제로 인해 모든 SSL 버전이 비활성화되었습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the purpose of the transport layer?,수송층의 목적은 무엇인가요?,To allow multiple applications to use one network connection simultaneously.,여러 애플리케이션이 하나의 네트워크 연결을 동시에 사용할 수 있도록 합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is DNS spoofing?,DNS 스푸핑이란 무엇인가요?,A DNS server is compromised and returns incorrect IP addresses for a some domains.,DNS 서버가 손상되어 일부 도메인에 대해 잘못된 IP 주소를 반환합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does TCP stand for?,TCP는 무엇을 의미하나요?,Transmission Control Protocol,전송 제어 프로토콜,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is special about TCP?,TCP의 특별한 점은 무엇인가요?,"It manages the sending and receiving of packet data.
It acknowledges receipt of packets.
If packets are missing, the source will resend the missing packets.","패킷 데이터의 송수신을 관리합니다.
패킷 수신을 승인합니다.
패킷이 누락된 경우 소스가 누락된 패킷을 다시 전송합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is HTTP?,HTTP란 무엇인가요?,The protocol for client-server communication.,클라이언트-서버 통신 프로토콜.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does UDP stand for?,UDP는 무엇을 의미하나요?,User Datagram Protocol.,사용자 데이터그램 프로토콜.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the size of a UDP header?,UDP 헤더의 크기는 어떻게 되나요?,8 bytes,8바이트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the size of a TCP header?,TCP 헤더의 크기는 어떻게 되나요?,20 bytes,20바이트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does ICMP stand for?,ICMP는 무엇을 의미하나요?,Internet Control Messaging Protocol,인터넷 제어 메시징 프로토콜,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does ICMP allow you to do?,ICMP는 무엇을 가능하게 하나요?,Allows devices to communicate and send errors. Can echo to see if a device is on the network.,장치가 통신하고 오류를 전송할 수 있습니다. 장치가 네트워크에 있는지 확인하기 위해 에코할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does SNMP stand for?,SNMP는 무엇을 의미하나요?,Simple Network Management Protocol.,간단한 네트워크 관리 프로토콜.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does SNMP do?,SNMP는 무엇을 하나요?,"Gathers info from machines on the network when each box has an SNMP agent installed. Can send a large amount of info about machines, software installed, and machine configuration.","각 상자에 SNMP 에이전트가 설치되어 있을 때 네트워크의 컴퓨터에서 정보를 수집합니다. 컴퓨터, 소프트웨어 설치 및 컴퓨터 구성에 대한 대량의 정보를 전송할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Do you need to establish a connection before sending data via UDP?,UDP를 통해 데이터를 보내기 전에 연결을 설정해야 하나요?,"No, it's connectionless.","아니요, 연결이 없습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Tell me about the checksum in a UDP packet.,UDP 패킷의 체크섬에 대해 알려주세요.,It's a 16-bit checksum. It's only mandatory on IPv6,16비트 체크섬입니다. IPv6에서만 필수입니다,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many times are packets sent in UDP?,UDP에서 패킷이 몇 번이나 전송되나요?,Once.,한번만.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is special about UDP?,UDP의 특별한 점은 무엇인가요?,"It's connectionless, packets are only sent once and not re-sent if dropped. Packets may not arrive in the right order, and there is no ordering mechanism to fix on the receiving end. No congestion control.",연결이 없고 패킷은 한 번만 전송되며 떨어뜨려도 다시 전송되지 않습니다. 패킷이 올바른 순서로 도착하지 않을 수 있으며 수신 측에서 수정할 수 있는 순서 메커니즘이 없습니다. 혼잡 제어 기능이 없습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's special about TCP?,TCP의 특별한 점은 무엇인가요?,"It does a 3-way handshake before data is sent.
Delivery is acknowledged by receiver.
Packets missing within a certain time window are re-requested.
Packets are put in order on receipt.
Congestion control: can delay delivery until network is uncongested.
IPv4 and IPv6: error detection, checksum mandatory.","데이터가 전송되기 전에 3방향 핸드셰이크를 수행합니다.
배송은 수신자가 확인합니다.
특정 시간 내에 누락된 패킷은 재요청됩니다.
수령 시 패킷이 순서대로 배치됩니다.
혼잡 제어: 네트워크가 혼잡하지 않을 때까지 배송을 지연시킬 수 있습니다.
IPv4 및 IPv6: 오류 감지, 체크섬 필수.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does OSI stand for?,OSI는 무엇을 의미하나요?,Open Systems Interconnect,오픈 시스템 인터커넥트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Why was OSI created?,OSI는 왜 만들어졌나요?,To solve the interoperability problem of having multiple heterogeneous networks.,여러 이기종 네트워크의 상호 운용성 문제를 해결하기 위해.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is OSI just a model?,OSI는 단지 모델인가요?,Yes.,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What network protocol won the networking wars?,네트워킹 전쟁에서 승리한 네트워크 프로토콜은 무엇인가요?,"TCP/IP, based on the OSI model.",OSI 모델을 기반으로 한 TCP/IP.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What happens at the Application level of the OSI model?,OSI 모델의 응용 수준에서는 어떤 일이 일어나나요?,This is where applications live and they handle data in many forms.,이곳은 애플리케이션이 거주하며 다양한 형태로 데이터를 처리하는 곳입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What happens in the Session layer of the OSI model?,OSI 모델의 세션 계층에서는 어떤 일이 일어나나요?,"This layer handles configuration of the data:
- encryption
- compression
- translation to and from different character encodings","이 계층은 데이터의 구성을 처리합니다:
- 암호화
- 압축
- 다양한 문자 인코딩으로의 번역",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What happens at the Session layer of the OSI model?,OSI 모델의 세션 계층에서는 어떤 일이 일어나나요?,"This layer controls the communication's access via:
- login rights
- permissions
- rights
- roles","이 계층은 다음을 통해 통신의 액세스를 제어합니다:
- 로그인 권한
- 권한
- 권리
- 역할",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What happens at the Transport layer of the OSI model?,OSI 모델의 전송 계층에서는 어떤 일이 일어나나요?,"This layer guarantees end-to-end delivery of data:
- packet ordering
- error detection
- acknowledgements","이 계층은 데이터의 종단 간 전달을 보장합니다:
- 패킷 순서 지정
- 오류 감지
- 감사의 표시",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What happens at the Network layer of the OSI model?,OSI 모델의 네트워크 계층에서는 어떤 일이 일어나나요?,"This layer's function is to find the shortest path through the network to the destination network.
Deals with congestion, bandwidth, etc.","이 계층의 기능은 네트워크를 통해 목적지 네트워크로 가는 최단 경로를 찾는 것입니다.
혼잡, 대역폭 등을 처리합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What happens at the Data Link layer of the OSI model?,OSI 모델의 데이터 링크 계층에서는 어떤 일이 일어나나요?,"It decides whose turn it is to talk on the network using bus arbitration methods.
It finds the physical device on the network.","그것은 버스 중재 방법을 사용하여 네트워크에서 누구의 차례인지 결정합니다.
네트워크에서 물리적 장치를 찾습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What happens at the Physical layer of the OSI model?,OSI 모델의 물리 계층에서는 어떤 일이 일어나나요?,"It's the physical network that deals with the physical transmission of electricity through wire:
- cables
- voltages
- frequencies
- connectors
- bits
- transfer rates
- and much more","전선을 통한 전기의 물리적 전송을 다루는 물리적 네트워크입니다:
- 케이블
- 전압
- 주파수
- 커넥터
- 비트
- 전송 속도
- 그리고 훨씬 더 많이",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does HTTP/2 save bandwidth?,HTTP/2는 대역폭을 어떻게 절약하나요?,"Headers are compressed and do not need to send the same headers in a session if they haven't changed.
Servers can send assets referenced in a document without waiting for discrete requests for them.","헤더는 압축되어 있으며 변경되지 않은 경우 세션에서 동일한 헤더를 보낼 필요가 없습니다.
서버는 문서에 참조된 자산을 개별 요청을 기다리지 않고 전송할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does HTTP/2 improve cache breaking?,HTTP/2는 캐시 중단을 어떻게 개선하나요?,A server can send updated assets using server push when it recognizes a file has changed.,서버는 파일이 변경되었음을 인식할 때 서버 푸시를 사용하여 업데이트된 자산을 전송할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the stream parallelism in HTTP/2?,HTTP/2의 스트림 병렬 처리란 무엇인가요?,"It's fully multiplexed, so it can use 100-1000 streams in a connection.",완전히 다중화되어 있어 연결 시 100-1000개의 스트림을 사용할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is HTTP/2 binary or textual?,"HTTP/2는 이진인가요, 아니면 텍스트인가요?",HTTP/2 is a binary protocol.,HTTP/2는 이진 프로토콜입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How are headers and body treated differently in HTTP/2?,HTTP/2에서는 헤더와 본문이 어떻게 다르게 취급되나요?,"They are split into a header frame and a data frame. Multiple requests can be interleaved in a connection, so a request doesn't block.",헤더 프레임과 데이터 프레임으로 나뉩니다. 여러 요청을 연결에 인터리빙할 수 있으므로 요청이 차단되지 않습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is priority in HTTP/2?,HTTP/2에서 우선순위는 무엇인가요?,Different assets can have different priority so that below the fold content can arrive later.,자산마다 우선순위가 다를 수 있으므로 접힘 내용 아래에 나중에 도착할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the range of the first octet on a Class A network?,클래스 A 네트워크에서 첫 번째 옥텟의 범위는 무엇인가요?,1-126. We don't use 0 or 127.,1-126. 우리는 0이나 127을 사용하지 않습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many network IDs are there on a Class A network?,클래스 A 네트워크에는 몇 개의 네트워크 ID가 있나요?,"2^7 = 128
First bit is 0, bits 1-7 are network IDs","2^7 = 128
첫 번째 비트는 0이고, 비트 1-7은 네트워크 ID입니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many host IDs are supported on a Class A network?,클래스 A 네트워크에서 지원되는 호스트 ID는 몇 개인가요?,"2^24 = 16 million
There are 8 bits for the network ID, and the remaining 24 bits are for host IDs.
So there are 16 million per network.","2^24 = 1,600만
네트워크 ID에는 8비트가 있고, 나머지 24비트는 호스트 ID용입니다.
그래서 네트워크당 1,600만 개가 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the range of the first octet on a Class B network?,클래스 B 네트워크에서 첫 번째 옥텟의 범위는 무엇인가요?,128 - 191,128 - 191,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many network IDs are supported on a Class B network?,클래스 B 네트워크에서 지원되는 네트워크 ID는 몇 개인가요?,"2^14 = 16,384
First 2 bits are 10, bits 3-16 are network IDs","2^14 = 16,384
처음 2비트는 10, 비트 3-16은 네트워크 ID입니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many host IDs are supported on a Class B network?,클래스 B 네트워크에서 지원되는 호스트 ID는 몇 개인가요?,"2^16 = 65,536
So there are 65,536 per network","2^16 = 65,536
따라서 네트워크당 65,536개가 있습니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the range of the first octet on a Class C network?,클래스 C 네트워크에서 첫 번째 옥텟의 범위는 무엇인가요?,192-223,192-223,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many network IDs are supported on a Class C network?,클래스 C 네트워크에서 지원되는 네트워크 ID는 몇 개인가요?,"2^21 = 2 million
First 3 bits are 110, bits 4-24 are network IDs","2^21 = 200만
처음 3비트는 110, 비트 4-24는 네트워크 ID입니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many host IDs are supported on a Class C network?,클래스 C 네트워크에서 지원되는 호스트 ID는 몇 개인가요?,"2^8 = 256
There are 256 hosts per network","2^8 = 256
네트워크당 256개의 호스트가 있습니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a class D network reserved for?,클래스 D 네트워크는 무엇을 위해 예약되어 있나요?,Multicasting,멀티캐스팅,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is unicasting?,유니캐스트란 무엇인가요?,Sending a packet from one host to another.,한 호스트에서 다른 호스트로 패킷을 전송합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does a network ID end in?,네트워크 ID는 무엇으로 끝나나요?,0,0,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does a broadcast ID end in?,방송 ID는 무엇으로 끝나나요?,255,255,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Who does a broadcast address of 255.255.255.255 send to?,방송 주소 255.255.255는 누구에게 보내나요?,All hosts within the network.,네트워크 내의 모든 호스트.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a directed broadcast?,연출 방송이란 무엇인가요?,It's a broadcast to all hosts within another network.,다른 네트워크 내의 모든 호스트에게 방송하는 것입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a limited broadcast address?,제한된 방송 주소란 무엇인가요?,The limited broadcast address is the address formed by setting all 32 bits of the IP address to 1 (255.255.255.255). The limited broadcast address is used when an IP node must perform a one-to-everyone delivery on the local network but the network ID is unknown.,제한 방송 주소는 IP 주소의 32비트를 모두 1(255.255.255.255)로 설정하여 형성된 주소입니다. 제한 방송 주소는 IP 노드가 로컬 네트워크에서 일대일 전송을 수행해야 하지만 네트워크 ID를 알 수 없는 경우에 사용됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What should you make networks as small as possible?,네트워크를 가능한 한 작게 만드는 것은 무엇인가요?,"For:
- security
- maintenance
- management","다음을 위해:
- 보안
- 유지 보수
- 관리",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How you divide a network?,네트워크를 어떻게 나누나요?,By subnetting.,서브넷으로.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does a /27 CIDR mean?,/27 CIDR은 무엇을 의미하나요?,The first 27 bits are masked with 1s. The remaining 5 bits are reachable in the subnet.,처음 27비트는 1로 마스킹됩니다. 나머지 5비트는 서브넷에서 도달할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does a /24 CIDR mean?,/24 CIDR은 무엇을 의미하나요?,The first 24 bits of the IP address are masked. Only hosts with addresses in the unmasked portion are reachable.,IP 주소의 처음 24비트는 마스킹됩니다. 마스킹되지 않은 부분에 주소가 있는 호스트만 도달할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a block cipher?,블록 암호란 무엇인가요?,"A block cipher is a method of encrypting text (to produce ciphertext) in which a cryptographic key and algorithm are applied to a block of data (for example, 64 contiguous bits) at once as a group rather than to one bit at a time.","블록 암호는 암호화된 텍스트를 암호화하는 방법으로, 암호화된 키와 알고리즘을 한 번에 하나의 비트가 아닌 그룹으로 데이터 블록(예: 64개의 연속 비트)에 적용하여 암호화하는 것입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is QUIC?,QUIC이란 무엇인가요?,"QUIC is a new transport which reduces latency compared to that of TCP. On the surface, QUIC is very similar to TCP+TLS+HTTP/2 implemented on UDP.",QUIC는 TCP에 비해 지연 시간을 줄여주는 새로운 전송 방식입니다. 표면적으로 QUIC는 UDP에 구현된 TCP+TLS+HTTP/2와 매우 유사합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Capsicum?,캡시쿰이란 무엇인가요?,A sandboxing framework that adds capability-based security to unix-like kernels and denies access to global namespaces.,유닉스 계열 커널에 기능 기반 보안을 추가하고 글로벌 네임스페이스에 대한 액세스를 거부하는 샌드박스 프레임워크입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a global namespace in unixy terms?,유닉스 용어로 글로벌 네임스페이스란 무엇인가요?,"aspects of a system that can be accessed from anywhere:
- file paths
- networks
- PIDs","어디서든 접근할 수 있는 시스템의 측면:
- 파일 경로
- 네트워크
- PID",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Google Native Client?,Google 네이티브 클라이언트란 무엇인가요?,"Also called NaCl, Native Client is a sandbox for running compiled C and C++ code in the browser efficiently and securely, independent of the user’s operating system.",NaCl이라고도 하는 네이티브 클라이언트는 사용자의 운영 체제와 독립적으로 브라우저에서 컴파일된 C 및 C++ 코드를 효율적이고 안전하게 실행하기 위한 샌드박스입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are web sockets?,웹 socket이란 무엇인가요?,Full-duplex communication between client and server.,클라이언트와 서버 간의 전이중 통신.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the same-origin policy?,동일 기원 정책이란 무엇인가요?,"Goal: Two websites should not be able to tamper with each other.
Strategy: each resource is assigned an origin. JS can only access resources from its own origin.
Origin: scheme + hostname + port","목표: 두 웹사이트는 서로 조작할 수 없어야 합니다.
전략: 각 리소스에는 출처가 할당됩니다. JS는 자체 출처에서만 리소스에 액세스할 수 있습니다.
출처: 스키마 + 호스트 이름 + 포트",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can 2 origins (let's say 2 frames) communicate?,2개의 원점(예: 2프레임)은 어떻게 통신할 수 있나요?,window.postMessage (HTML5) allows for sending data messages between two windows/frames across domains.,window.postMessage (HTML5)는 도메인 간에 두 개의 창/프레임 간에 데이터 메시지를 전송할 수 있게 해줍니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is JIT compilation?,JIT 컴파일이란 무엇인가요?,"JIT compilation, also known as dynamic translation, is compilation done at run-time rather than ahead of time (AOT).","JIT 컴파일은 동적 번역이라고도 하며, 사전에 실행되는 것이 아니라 런타임에 수행되는 컴파일입니다(AOT).",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is PyPy?,PyPy란 무엇인가요?,"PyPy is a replacement for CPython. It is built using the RPython language that was co-developed with it. RPython is a subset of Python and can be translated to C. The main reason to use it instead of CPython is speed: it runs generally faster due to JIT compilation.
PyPy implements Python 2.7.10. It supports all of the core language, passing the Python test suite (with minor modifications that were already accepted in the main python in newer versions). It supports most of the commonly used Python standard library modules.","PyPy는 CPython을 대체하는 언어입니다. Python과 함께 개발된 RPython 언어를 사용하여 구축되었습니다. RPython은 Python의 하위 집합이며 C로 번역할 수 있습니다. CPython 대신 사용하는 주된 이유는 속도입니다: JIT 컴파일로 인해 일반적으로 더 빠르게 실행되기 때문입니다.
PyPy는 Python 2.7.10을 구현합니다. PyPy는 모든 핵심 언어를 지원하며, Python 테스트 스위트를 통과합니다 (새로운 버전의 메인 Python에서 이미 받아들여진 약간의 수정 사항도 포함되어 있습니다). 이는 일반적으로 사용되는 대부분의 Python 표준 라이브러리 모듈을 지원합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does SMT stand for?,SMT는 무엇을 의미하나요?,Satisfiability modulo theories.,만족도 모듈로 이론.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an SMT solver?,SMT 솔버란 무엇인가요?,A satisfiability modulo theories solver solves for large interconnected logic formulas to determine if a given formula can be satisfied. These are helpful for determining the outcome or inputs for a program using symbolic execution.,만족 모듈로 이론 솔버는 대규모 상호 연결 논리 공식을 해결하여 주어진 공식을 만족시킬 수 있는지 여부를 결정합니다. 이는 심볼릭 실행을 사용하여 프로그램의 결과나 입력을 결정하는 데 도움이 됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How do we find that a condition exists that will cause a program to have a predicted outcome?,프로그램이 예측된 결과를 초래할 수 있는 조건이 존재한다는 것을 어떻게 알 수 있을까요?,"Using an SAT solver (using logic tests) and an SMT solver (that plugs in numbers), and tells the SAT solver where it got it wrong. They provide feedback in a cycle to each other until a condition can be found.",SAT 솔버(논리 테스트 사용)와 SMT 솔버(숫자를 연결하는)를 사용하여 SAT 솔버가 어디서 잘못되었는지 알려줍니다. SAT 솔버는 조건을 찾을 때까지 주기적으로 서로 피드백을 제공합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is  transactional memory?,트랜잭션 메모리란 무엇인가요?,Transactional memory attempts to simplify concurrent programming by allowing a group of load and store instructions to execute in an atomic way. It is a concurrency control mechanism analogous to database transactions for controlling access to shared memory in concurrent computing.,트랜잭션 메모리는 로드 및 저장 명령어 그룹이 원자적 방식으로 실행될 수 있도록 하여 동시 프로그래밍을 단순화하려고 시도합니다. 이는 동시 컴퓨팅에서 공유 메모리에 대한 액세스를 제어하기 위한 데이터베이스 트랜잭션과 유사한 동시성 제어 메커니즘입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is software transactional memory?,소프트웨어 트랜잭션 메모리란 무엇인가요?,"Software transactional memory provides transactional memory semantics in a software runtime library or the programming language, and requires minimal hardware support (typically an atomic compare and swap operation, or equivalent). As the downside, software implementations usually come with a performance penalty, when compared to hardware solutions.","소프트웨어 트랜잭셔널 메모리는 소프트웨어 런타임 라이브러리나 프로그래밍 언어에서 트랜잭셔널 메모리 의미를 제공하며, 최소한의 하드웨어 지원(일반적으로 원자 비교 및 스왑 작업 또는 이에 상응하는 작업)이 필요합니다. 단점으로, 소프트웨어 구현은 하드웨어 솔루션과 비교할 때 성능 저하가 발생하는 경우가 많습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Does PyPY have a GIL?,PyPY에 GIL이 있나요?,"Yes. The GIL is very difficult to remove. You can use pypy-stm instead, which uses software transactional memory, but will suffer a performance penalty.",예. GIL은 제거하기가 매우 어렵습니다. 대신 소프트웨어 트랜잭션 메모리를 사용하는 pypy-stm을 사용할 수 있지만 성능 저하가 발생합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can a server deal with a SYN flood attack?,서버가 SYN 홍수 공격에 어떻게 대처할 수 있나요?,"When it detects a large number of SYN packets at once, or the size of its SN (sequence number) data structure reaches a certain threshold of entries, it can switch to a stateless version, where it send SN responses as signed values with a timestamp, and if it receives one back it lets them through without needing a lookup table.","한 번에 많은 수의 SYN 패킷을 감지하거나 SN(시퀀스 번호) 데이터 구조의 크기가 특정 항목 임계값에 도달하면 상태 비저장 버전으로 전환하여 타임스탬프가 있는 서명된 값으로 SN 응답을 전송하고, 하나를 받으면 조회 테이블 없이 SN 응답을 통과시킬 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a stack canary?,스택 카나리아란 무엇인가요?,"It's a buffer overflow defense where a random value is pushed onto the stack after the saved EBP, and before tearing down the stack frame, the value is checked. Any buffer flow targeting the return instruction pointer would have to have overwritten this value.",저장된 EBP 후 무작위 값을 스택에 밀어넣고 스택 프레임을 분해하기 전에 값을 확인하는 버퍼 오버플로 방어입니다. 반환 명령 포인터를 대상으로 하는 버퍼 흐름은 이 값을 덮어쓰야 합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What type of buffer overflow protection does gcc and Visual Studio employ?,gcc와 Visual Studio는 어떤 유형의 버퍼 오버플로 방지 기능을 사용하나요?,"They use a stack check guard of bytes before and after the buffer's allocated memory. Once values are written to the buffer, the bytes are checked to ensure they are still the same.",버퍼에 할당된 메모리 전후의 바이트 스택 검사 가드를 사용합니다. 값이 버퍼에 기록되면 바이트가 여전히 동일한지 확인합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is scalability?,확장성이란 무엇인가요?,"Scalability is the measure to which a system can adapt to a change in demand for resources, without negatively impacting performance.",확장성은 시스템이 성능에 부정적인 영향을 미치지 않으면서 리소스 수요 변화에 적응할 수 있는 척도입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Akka?,아카란 무엇인가요?,"An open source project that provides a simpler, single programming model - one way of coding for concurrent and distributed applications - the actor programming model.
Akka’s primary goal is to make it simpler to build applications that are deployed in the cloud or run on devices with many cores and that efficiently leverage the full capacity of the computing power available. It’s a toolkit that provides an actor model, runtime, and required supporting tools for building scalable applications.","더 간단하고 단일한 프로그래밍 모델을 제공하는 오픈 소스 프로젝트 - 동시 및 분산 애플리케이션을 위한 코딩 방법 중 하나인 액터 프로그래밍 모델.
Akka의 주요 목표는 클라우드에 배포되거나 코어가 많은 디바이스에서 실행되는 애플리케이션을 더 쉽게 구축하고 사용 가능한 컴퓨팅 성능의 전체 용량을 효율적으로 활용하는 것입니다. 이 툴킷은 확장 가능한 애플리케이션을 구축하기 위한 액터 모델, 런타임 및 필수 지원 도구를 제공합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an actor?,배우란 무엇인가요?,"Briefly, actors are a lot like message queues without the configuration and message broker installation overhead. They’re like programmable message queues shrunk to microsize—you can easily create thousands, even millions of them. They don’t “do”
anything unless they’re sent a message.
Messages are simple data structures that can’t be changed after they’ve been created, or in a single word, they’re immutable.
Actors can receive messages one at a time and execute some behavior whenever a message is received. Unlike queues, they can also send messages (to other actors).
Everything an actor does is executed asynchronously. Simply put, you can send a message to an actor without waiting for a response. Actors aren’t like threads, but messages sent to them are pushed through on a thread at some point in time. How actors are connected to threads is configurable - this is not a hardwired relationship.
For now the most important aspect of actors is that you build applications by sending and receiving messages. A message could be processed locally on some available thread, or remotely on another server. Exactly where the message is processed and where the actor lives are things you can decide later, which is very different compared to hardcoding threads and RPC style networking. Actors make it easy to build your application out of small parts that resemble networked services, only shrunk to microsize in footprint and administrative overhead.","간단히 말해서, 배우들은 설정과 메시지 브로커 설치 오버헤드가 없는 메시지 큐와 매우 비슷합니다. 마치 프로그래밍 가능한 메시지 큐를 축소하여 마이크로사이즈로 만드는 것과 같습니다. 수천 개, 심지어 수백만 개를 쉽게 만들 수 있습니다. 그들은 ""하지"" 않습니다
메시지를 보내지 않는 한 무엇이든.
메시지는 생성된 후에는 변경할 수 없거나 한 마디로 변경할 수 없는 단순한 데이터 구조입니다.
배우는 메시지를 한 번에 하나씩 받고 메시지를 받을 때마다 일부 동작을 실행할 수 있습니다. 대기열과 달리 다른 배우에게 메시지를 보낼 수도 있습니다.
배우가 하는 모든 작업은 비동기식으로 실행됩니다. 간단히 말해, 응답을 기다리지 않고 배우에게 메시지를 보낼 수 있습니다. 배우는 스레드와 같지는 않지만, 배우에게 보낸 메시지는 특정 시점에 스레드를 통해 전달됩니다. 배우가 스레드에 연결되는 방식은 구성할 수 있으며, 이는 유선 연결된 관계가 아닙니다.
현재 배우의 가장 중요한 측면은 메시지를 주고받으며 애플리케이션을 구축하는 것입니다. 메시지는 사용 가능한 스레드에서 로컬로 처리되거나 다른 서버에서 원격으로 처리될 수 있습니다. 메시지가 정확히 처리되는 위치와 배우의 거주 위치는 나중에 결정할 수 있는 사항으로, 하드코딩 스레드나 RPC 스타일 네트워킹과 비교하면 매우 다릅니다. 배우는 네트워크 서비스와 유사한 작은 부분으로 애플리케이션을 쉽게 구축할 수 있으며, 발자국과 관리 오버헤드를 미세화하기 위해 축소할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an IDL-based encoding?,IDL 기반 인코딩이란 무엇인가요?,"An interface description language or interface definition language (IDL) encoding. 
It requires a schema definitions. They offer peace of mind with respect to data format and validation for consumers while sacrificing flexibility in the schema’s evolution.","인터페이스 설명 언어 또는 인터페이스 정의 언어(IDL) 인코딩. 
스키마 정의가 필요합니다. 스키마의 진화에 유연성을 희생하면서 소비자에게 데이터 형식과 검증에 대한 안심을 제공합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Tarantool?,타란툴이란 무엇인가요?,An in-memory noSQL database that uses write-ahead logging for crash resistance and persistence.,충돌 저항성과 지속성을 위해 쓰기 전 로깅을 사용하는 in-memory noSQL 데이터베이스입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a coroutine?,코루틴이란 무엇인가요?,"An object representing activity that eventually completes. Also refers the the function we call that returns a coroutine.
In Python, coroutines are generators.","결국 완료되는 활동을 나타내는 객체입니다. 또한 코루틴을 반환하는 함수라고도 합니다.
파이썬에서 코루틴은 생성기입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a future?,미래란 무엇인가요?,An object representing a result that may not be available yet.,아직 사용할 수 없는 결과를 나타내는 객체.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is AQP?,What is AQP?,Approximate query processing. It means pulling a sample of data instead of taking time to process an exact result. It is often used when a data storage involves terabytes or more.,대략적인 쿼리 처리. 정확한 결과를 처리하는 데 시간이 걸리는 대신 데이터 샘플을 가져오는 것을 의미합니다. 데이터 저장소에 테라바이트 이상이 포함된 경우 자주 사용됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How would you visualize billions of items in a graph?,그래프에서 수십억 개의 항목을 어떻게 시각화하시겠습니까?,"In many cases, you don't need to graph every point, just use visualization-aware sampling. Sometime 1% or less will do.",많은 경우 모든 점을 그래프로 그릴 필요는 없으며 시각화 인식 샘플링만 사용하면 됩니다. 1% 이하면 충분합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is F1/Spanner?,F1/스패너란 무엇인가요?,Fault-Tolerant Distributed RDBMS (Spanner) Supporting Google's Ad Business (F1),구글의 광고 비즈니스(F1)를 지원하는 내결함성 분산 RDBMS(스패너),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Photon?,광자란 무엇인가요?,Fault-tolerant and Scalable Joining of Continuous Data Streams,연속 데이터 스트림의 내결함성과 확장 가능한 결합,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Mesa?,메사란 무엇인가요?,"Geo-Replicated, Near Real-Time, Scalable Data Warehousing","지리적으로 복제된 거의 실시간, 확장 가능한 데이터 웨어하우스",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does Google use multi-homed datacenters?,Google은 멀티홈 데이터 센터를 어떻게 사용하나요?,"A multi-homed system runs live in multiple datacenters all the time. Each datacenter processes work all the time, and work is dynamically shared between datacenters to balance load. When one datacenter is slow, some fraction of work automatically moves to faster datacenters. When a datacenter is completely unavailable, all its work is automatically distributed to other datacenters.","멀티홈 시스템은 항상 여러 데이터 센터에서 실시간으로 실행됩니다. 각 데이터 센터 프로세스는 항상 작동하며, 작업은 데이터 센터 간에 동적으로 공유되어 부하 균형을 맞춥니다. 한 데이터 센터의 속도가 느리면 작업의 일부가 자동으로 더 빠른 데이터 센터로 이동합니다. 데이터 센터를 완전히 사용할 수 없는 경우 모든 작업이 자동으로 다른 데이터 센터로 분산됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is ElasticSearch?,ElasticSearch란 무엇인가요?,"Open Source, Distributed, RESTful Search Engine","오픈 소스, 분산, RESTful 검색 엔진",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an example of a circuit breaker?,회로 차단기의 예는 무엇인가요?,Start sending 503s if your service is choked to avoid numerous simultaneous retries that just make the system worse.,시스템을 악화시키는 여러 번의 동시 재시도를 피하기 위해 서비스가 중단된 경우 503을 전송하기 시작하세요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the name of Google's search ranking algorithm?,구글 검색 순위 알고리즘의 이름은 무엇인가요?,Hummingbird. PageRank is just one factor used by the algorithm.,벌새. 페이지랭크는 알고리즘이 사용하는 한 가지 요소일 뿐입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is celery?,Celery란 무엇인가요?,Distributed Task Queue,분산 작업 대기열,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
LRU is the most popular type of what kind of policy?,LRU는 어떤 종류의 정책에서 가장 인기가 있나요?,Eviction,퇴거,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does an eviction policy try to predict?,퇴거 정책은 무엇을 예측하려고 하나요?,"An eviction policy tries to predict which entries are most likely to be used again in the near future, thereby maximizing the hit ratio",퇴거 정책은 가까운 미래에 다시 사용될 가능성이 가장 높은 항목을 예측하여 적중률을 극대화하려고 합니다,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Caffiene?,카페이엔이란 무엇인가요?,"Caffeine is a high performance, near optimal caching library based on Java 8.","카페인은 Java 8을 기반으로 한 고성능, 거의 최적의 캐싱 라이브러리입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is request coalescing?,요청 통합이란 무엇인가요?,"When many requests arrive for some content that’s missing in the cache (cache miss), only one instance request will proceed to the backend to fetch the content on behalf of all to avoid a flood.","캐시에 누락된 콘텐츠(캐시 미스)에 대한 요청이 많이 도착하면, 홍수를 피하기 위해 백엔드로 콘텐츠를 가져오기 위해 하나의 인스턴스 요청만 진행됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
When might you need to use a NoSQL database,NoSQL 데이터베이스를 사용해야 하는 시기,"You don’t have any relational data.
If you need to store > 5 TB of data or you have an incredibly data intensive workload.
Your application has super low-latency requirements.
You need really high throughput.","관계 데이터가 없습니다.
5TB 이상의 데이터를 저장해야 하거나 데이터 집약적인 작업량이 있는 경우.
귀하의 애플리케이션은 대기 시간이 매우 짧습니다.
정말 높은 처리량이 필요합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is AMP?,AMP란 무엇인가요?,"AMP is a restricted subset of HTML designed to make the web fast on mobile devices.
Provides a shared library of scripts so they don’t have to downloaded every time.
Sets standards for the architecture of advertising so advertising doesn't infect pages.
Shared mechanism for collecting data for analytics so you don’t have N different packages on a page gathering stats.","AMP는 모바일 기기에서 웹을 빠르게 만들기 위해 설계된 HTML의 제한된 하위 집합입니다.
스크립트를 매번 다운로드할 필요 없이 공유 라이브러리를 제공합니다.
광고가 페이지에 영향을 미치지 않도록 광고 아키텍처의 기준을 설정합니다.
분석을 위한 데이터 수집 메커니즘을 공유하여 페이지에 N개의 다른 패키지가 포함되지 않도록 합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a benefit of making processes asynchronous?,프로세스를 비동기화하면 어떤 이점이 있나요?,Flexibility in the architecture. Getting users on hooked on synchronous low-latency interactions doesn't allow for architecture flexibility.,아키텍처의 유연성. 사용자가 동기화된 저지연 상호작용에 매료되는 것은 아키텍처의 유연성을 보장하지 않습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is BASE?,BASE란 무엇인가요?,"basically available
soft state
eventually consistent

A BASE based system is more tolerant to latency because it is an inherently partitioned and loosely coupled architecture and it uses eventual consistency.","기본적으로 사용 가능
소프트 상태
결국 일관된

BASE 기반 시스템은 본질적으로 분할되고 느슨하게 결합된 아키텍처이며 궁극적인 일관성을 사용하기 때문에 지연 시간에 더 관대합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is ACID?,산이란 무엇인가요?,"atomicity
consistency
isolation
durability","원자성
일관성.
고립
내구성",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the CAP theorem?,CAP 정리란 무엇인가요?,"The CAP theorem, also named Brewer's theorem, states that it is impossible for a distributed computer system to simultaneously provide all three of the following guarantees:

- Consistency (all nodes see the same data at the same time)
- Availability (every request receives a response about whether it succeeded or failed)
- Partition tolerance (the system continues to operate despite arbitrary partitioning due to network failures)","CAP 정리, 브루어 정리라고도 불리는 이 정리는 분산 컴퓨터 시스템이 다음 세 가지 보장을 동시에 제공하는 것이 불가능하다고 명시하고 있습니다:

- 일관성(모든 노드가 동일한 데이터를 동시에 봅니다)
- 가용성(모든 요청은 성공 여부에 대한 응답을 받습니다)
- partition 허용 오차(네트워크 장애로 인한 임의의 partition에도 불구하고 시스템은 계속 작동합니다)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is zero copy?,제로 카피란 무엇인가요?,"Applications that use zero copy request that the kernel copy the data directly from the disk file to the socket, without going through the application. Zero copy greatly improves application performance and reduces the number of context switches between kernel and user mode.",제로 복사를 사용하는 애플리케이션은 커null이 애플리케이션을 거치지 않고 디스크 파일에서 socket으로 직접 데이터를 복사할 것을 요청합니다. 제로 복사는 애플리케이션 성능을 크게 향상시키고 커null과 사용자 모드 간의 컨텍스트 전환 횟수를 줄여줍니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a metaclass?,메타클래스란 무엇인가요?,Any callable (function or class) that implements type()'s function signature.,Any callable (function or class) that implements type()'s function signature.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is privilege separation?,특권 분리란 무엇인가요?,Separating an application into different areas so a vulnerability in one area doesn't affect the entire application.,애플리케이션을 다른 영역으로 분리하여 한 영역의 취약점이 전체 애플리케이션에 영향을 미치지 않도록 하는 것입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In security, what is a principal?",보안 분야에서 주체란 무엇인가요?,An entity with privileges or rights.,특권이나 권리를 가진 단체.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In Unix, who is the owner of a file?",유닉스에서 파일의 소유자는 누구인가요?,The user with the user ID that matches the UID of the inode.,inode의 UID와 일치하는 사용자 ID를 가진 사용자.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What privilege do you need to lookup files or directories in a path?,경로에서 파일이나 디렉터리를 조회하려면 어떤 권한이 필요하나요?,The executable permission.,실행 가능한 권한.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
When is security enforced on a file?,파일에 대한 보안은 언제 시행되나요?,Security is checked when the file descriptor is created. Then it's up to the user to be careful and secure the file descriptor.,파일 설명자가 생성되면 보안이 확인됩니다. 그런 다음 파일 설명자를 주의하고 보호하는 것은 사용자의 몫입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is ptrace?,ptrace란 무엇인가요?,"ptrace is a system call found in several Unix and Unix-like operating systems. By using ptrace, one process can control another, enabling the controller to inspect and manipulate the internal state of its target.","ptrace는 여러 유닉스 및 유닉스 계열 운영 체제에서 사용되는 시스템 호출입니다. ptrace를 사용하면 한 프로세스가 다른 프로세스를 제어할 수 있으며, 이를 통해 컨트롤러가 대상의 내부 상태를 검사하고 조작할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What can you use to debug a process?,프로세스를 디버깅하는 데 무엇을 사용할 수 있나요?,ptrace,흔적,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What user privilege is required to bind to ports < 1024?,포트 < 1024에 바인딩하려면 어떤 사용자 권한이 필요하나요?,root,뿌리,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"During system bootstrapping, what call is performed by the system to give a non-root user the ownership of a process?",시스템 부트스트래핑 중 루트가 아닌 사용자에게 프로세스의 소유권을 부여하기 위해 시스템이 수행하는 호출은 무엇인가요?,setuid(),setuid(),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the setuid binaries?,setuid 바이너리란 무엇인가요?,"su
sudo","수
수도",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does chroot do?,chroot은 무엇을 하나요?,Changes the root directory (/) for a user to be a directory on the filesystem where they can't escape.,사용자가 탈출할 수 없는 파일 시스템의 디렉토리가 되도록 루트 디렉토리(/)를 변경합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a confused deputy?,혼란스러운 대리인이란 무엇인가요?,"A confused deputy is a computer program that is innocently fooled by some other party into misusing its authority. It is a specific type of privilege escalation. In information security, the confused deputy problem is often cited as an example of why capability-based security is important, as capability systems protect against this whereas access control list-based systems do not.
The classic example is a Fortran compiler that creates a billing record for each use. A user was able to tell the compiler to output a binary with the same name as the billing file, overwriting it.","혼란스러운 대리인은 다른 당사자가 순진하게 속아 권한을 남용하는 컴퓨터 프로그램입니다. 이는 특정 유형의 권한 확대입니다. 정보 보안에서 혼란스러운 대리인 문제는 종종 기능 기반 보안이 중요한 이유를 보여주는 예로 언급되는데, 이는 기능 시스템이 이를 보호하는 반면 접근 제어 목록 기반 시스템은 그렇지 않기 때문입니다.
고전적인 예는 각 사용에 대한 청구 기록을 생성하는 포트란 컴파일러입니다. 사용자는 컴파일러에게 청구 파일과 동일한 이름의 바이너리를 출력하도록 지시하고 이를 덮어쓸 수 있었습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an example of a confused deputy in the web frontend world?,웹 프론트엔드 세계에서 혼란스러운 대리인의 예는 무엇인가요?,A CSRF attack.,CSRF 공격.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What is ambient authority, or ambient privilege?",주변 권한 또는 주변 특권이란 무엇인가요?,"The decision about whether a process or agent can perform an action is based on information not explicitly stated, but inherited instead.","프로세스나 에이전트가 행동을 수행할 수 있는지 여부에 대한 결정은 명시적으로 명시되지 않은 정보를 기반으로 하며, 대신 상속됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a capability?,기능이란 무엇인가요?,"The privilege to act upon something given your ownership of it, and the inability to act on something using an intermediate process' privileges. An example would be a function where you pass a file descriptor as an argument and the function uses your capability, not its own.",소유권이 주어졌을 때 어떤 것에 대해 행동할 수 있는 권한과 중간 프로세스의 권한을 사용하여 어떤 것에 대해 행동할 수 없는 권한을 말합니다. 예를 들어 파일 설명자를 인수로 전달하고 해당 기능이 자신의 기능이 아닌 자신의 기능을 사용하는 함수를 들 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a requirement of enabling sandboxing?,샌드박스를 활성화하기 위한 요건은 무엇인가요?,"The kernel must be able to support it by disallowing system calls that reference global namespaces:
- file paths starting at root - must be relative
- network
- PIDs - use process descriptors instead","커널은 전역 네임스페이스를 참조하는 시스템 호출을 허용하지 않음으로써 커null을 지원할 수 있어야 합니다:
- 루트에서 시작하는 파일 경로 - 상대적이어야 합니다
- 네트워크
- PID - 대신 프로세스 설명자 사용",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How is RSA decryption optimized for speed?,RSA 복호화는 속도에 어떻게 최적화되나요?,"- c^d mod p and c^d mod q are processed in parallel and merged at the end using the Chinese remainder theorem
- put into Montgomery format
- sliding windows to exponentiate on bits of exponent
- perhaps a single extra reduction
- convert back from Montgomery format
- merge using CRT","- c^d mod p와 c^d mod q는 병렬로 처리되며, 마지막에 중국 잔여 정리를 사용하여 병합됩니다
- 몽고메리 형식으로 번역하다
- 윈도우를 슬라이딩하여 지수 비트로 지수화합니다
- 아마도 한 번의 추가 감소
- 몽고메리 형식에서 다시 변환
- CRT를 사용하여 병합",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How do you change a positive integer to negative?,양의 정수를 음수로 어떻게 변경하나요?,"Subtract 1, flip all bits",1을 빼고 모든 비트를 뒤집습니다,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How do you change a negative integer to positive?,음수를 양수로 어떻게 변경하나요?,"Flip all bits, then add 1",모든 비트를 뒤집은 다음 1을 추가합니다,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Intel architecture?,인텔 아키텍처란 무엇인가요?,"CISC - Complex Instruction Set Computer
Many special-purpose instructions.","CISC - 복잡한 명령어 집합 컴퓨터
많은 특수 목적 지침.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What size are Intel instructions?,인텔 지침은 어떤 크기인가요?,"They are variable-length, from 1 to theoretically 16 bytes.",그것들은 1바이트에서 이론적으로 16바이트까지의 가변 길이입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is RISC?,RISC란 무엇인가요?,"Reduced Instruction Set Architecture. 
- more registers
- fewer, fixed-sized instructions
- used in PowerPC, ARM, SPARC, MIPS","축소된 명령어 집합 아키텍처. 
- 더 많은 레지스터
- 더 적은 수의 고정 크기 지침
- PowerPC, ARM, SPARC, MIPS에 사용됨",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What Endianness is Intel?,인텔의 엔디안니스란 무엇인가요?,"Little Endian, but only in memory. In registers, all are Big Endian.",리틀 엔디안이지만 기억 속에서만 가능합니다. 레지스터에는 모두 빅 엔디안입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Little Endianness?,리틀 엔디안니스란 무엇인가요?,The least significant bytes of a word or larger are stored in the lowest address. All bytes are the same. There is no Endianness within a byte.,단어 이상의 최하위 바이트는 가장 낮은 주소에 저장됩니다. 모든 바이트는 동일합니다. 바이트 내에는 엔디안니스가 없습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many registers are on CISC?,CISC에는 몇 개의 레지스터가 있나요?,8 general-purpose registers and an instruction pointer. 2 of 8 are not that general.,8개의 범용 레지스터와 명령 포인터. 8개 중 2개는 그렇게 일반적이지 않습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the word size on Intel?,인텔의 단어 크기는 무엇인가요?,16 bits,16비트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the double-word size on Intel?,인텔의 더블 워드 크기는 무엇인가요?,32 bits,32비트,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Big Endianness?,빅 엔디안니스란 무엇인가요?,The most significant bytes of a word or larger are stored in the lowest address.,단어 이상의 가장 중요한 바이트는 가장 낮은 주소에 저장됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the EAX register used for?,EAX 레지스터는 무엇에 사용되나요?,Stores the function's return value.,함수의 반환 값을 저장합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the EBX register used for?,EBX 레지스터는 무엇에 사용되나요?,Base pointer to the data section.,데이터 섹션으로 가는 기본 포인터.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the ECX register used for?,ECX 레지스터는 무엇에 사용되나요?,Counter for string and loop operations.,문자열 및 루프 연산을 위한 카운터.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the EDX register used for?,EDX 레지스터는 무엇에 사용되나요?,I/O pointer,입출력 포인터,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the ESI register used for?,ESI 레지스터는 무엇에 사용되나요?,Source pointer for string or other copy operations.,문자열 또는 기타 복사 작업을 위한 소스 포인터.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the EDI register used for?,EDI 레지스터는 무엇에 사용되나요?,Destination pointer for string or other copy operations.,문자열 또는 기타 복사 작업을 위한 대상 포인터.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the ESP register used for?,ESP 레지스터는 무엇에 사용되나요?,Stack pointer,스택 포인터,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the EBP register used for?,EBP 레지스터는 무엇에 사용되나요?,Stack frame base pointer,스택 프레임 베이스 포인터,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the EIP register used for?,EIP 레지스터는 무엇에 사용되나요?,Instruction pointer - next instruction pointer to execute.,명령 포인터 - 다음으로 실행할 명령 포인터.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the caller-save registers?,호출자 저장 레지스터는 무엇인가요?,"eax
edx
ecx","이완
edx
ECX",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the callee-save registers?,호출기 저장 레지스터는 무엇인가요?,"ebp
ebx
esi
edi","ebp
ebx
에시
에디",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Other than the main registers, what other registers can be used?",주요 레지스터 외에 어떤 다른 레지스터를 사용할 수 있나요?,"Legacy 8 and 16-bit registers: AX, AH, AL, SP, BP, SI","레거시 8비트 및 16비트 레지스터: AX, AH, AL, SP, BP, SI",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the caller register-saving convention on Linux systems?,리눅스 시스템에서 발신자 등록 저장 규칙은 무엇인가요?,cdecl - C declaration,cdecl - C 선언,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is avalancing?,눈사태란 무엇인가요?,The effect of a hashing method where a small change in the input has a large effect on the output.,입력의 작은 변화가 출력에 큰 영향을 미치는 해싱 방법의 효과.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Chef?,셰프란 무엇인가요?,A configuration tool. You write or reuse recipes that declare the state you wish your server to be in. It calculates the delta and builds out for you.,구성 도구. 서버가 원하는 상태를 선언하는 레시피를 작성하거나 재사용합니다. 이 도구는 델타를 계산하고 사용자를 위해 빌드를 제공합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an example of a non-cryptographic hash function?,비암호화 해시 함수의 예는 무엇인가요?,"MurmurHash is an efficient, non-cryptographic hash function suitable for general hash-based lookup. The name comes from two basic operations, multiply (MU) and rotate (R), used in its inner loop. It has an avalanche effect. The current version is MurmurHash3 which yields a 32-bit or 128-bit hash value.","MurmurHash is an efficient, non-cryptographic hash function suitable for general hash-based lookup. The name comes from two basic operations, multiply (MU) and rotate (R), used in its inner loop. It has an avalanche effect. The current version is MurmurHash3 which yields a 32-bit or 128-bit hash value.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How could you process calculations on elements of an array in parallel?,배열의 요소에 대한 계산을 병렬로 처리하려면 어떻게 해야 하나요?,"Using recursion, divide and conquer, breaking down the array into smaller segments, then merging the values as the recursion unwinds. Non-mutation of the array means locking is not required.",재귀를 사용하여 분할하고 정복한 다음 배열을 더 작은 세그먼트로 분해한 다음 재귀가 풀릴 때 값을 병합합니다. 배열의 돌연변이가 없다는 것은 잠금이 필요하지 않다는 것을 의미합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What factor should you keep in mind when doing parallel computation on different parts of a large data structure?,대규모 데이터 구조의 여러 부분에서 병렬 계산을 할 때 염두에 두어야 할 요소는 무엇인가요?,The memory bandwidth of your RAM. It can become a bottleneck.,RAM의 메모리 대역폭. 병목 현상이 발생할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What will be the computation time when processing multiple tasks?,여러 작업을 처리할 때 계산 시간은 어떻게 되나요?,The length of time the longest subcomputation takes.,가장 긴 서브 계산 시간.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Why should you avoid starting and joining a task or thread on the same line or proximity?,같은 선상이나 근접 지점에서 작업이나 스레드를 시작하거나 참여하는 것을 피해야 하는 이유는 무엇인가요?,"Execution on the current thread will block until it completes, thereby obviating the concurrent call.",현재 스레드에서 실행이 완료될 때까지 차단되어 동시 호출을 피할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What factors affect performance?,성과에 영향을 미치는 요인은 무엇인가요?,"- processor speed 
- number of processors
- memory access latency and throughput
- cache behavior
- runtime behavior (garbage collection, JIT compilation, thread scheduling)","- 프로세서 속도 
- 프로세서 수
- 메모리 액세스 지연 시간 및 처리량
- 캐시 동작
- 런타임 동작(쓰레기 수집, JIT 컴파일, 스레드 스케줄링)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Amdahl's Law?,암달의 법칙이란 무엇인가요?,It gives the theoretical speedup in latency of the execution of a task at fixed workload that can be expected of a system whose resources are improved.,자원이 개선된 시스템에서 기대할 수 있는 고정 작업 부하에서 작업 실행 지연 시간을 이론적으로 단축합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What aspects are important in measuring and benchmarking performance, parallel or otherwise?",성능을 측정하고 벤치마킹하는 데 있어 병렬적이든 다른 방식이든 중요한 측면은 무엇인가요?,"- multiple repetitions
- statistical treatment - mean and variance
- eliminate statistical outliers
- ensuring steady-state (warm-up)
- preventing anomalies (garbage collection, JIT compilation, compiler optimizations in benchmark code that misrepresents real-world)","- 여러 번 반복
- 통계적 처리 - 평균 및 분산
- 통계적 이상치 제거
- 정상 상태 보장(워밍업)
- 이상 현상 방지(쓰레기 수집, JIT 컴파일, 벤치마크 코드에서 실제 세계를 잘못 표현하는 컴파일러 최적화)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"When associative operations are used, what does it mean?","연상 연산이 사용될 때, 그것은 무엇을 의미하나요?",Grouping doesn't matter. It will evaluate to the same result.,그룹화는 중요하지 않습니다. 동일한 결과로 평가될 것입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a synonym of reduce()?,reduce()의 동의어는 무엇인가요?,fold(),fold(),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the commutative property?,교환 속성이란 무엇인가요?,"The condition that a group of quantities connected by operators gives the same result whatever the order of the quantities involved. So order of operands doesn't matter, but grouping may matter.",연산자로 연결된 양의 그룹이 관련된 양의 순서에 관계없이 동일한 결과를 제공한다는 조건입니다. 따라서 피연산자의 순서는 중요하지 않지만 그룹화는 중요할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a bag?,가방이란 무엇인가요?,A multiset.,멀티셋.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a multiset?,멀티셋이란 무엇인가요?,A set in which elements do not have to be unique.,요소들이 반드시 고유할 필요는 없는 집합.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some examples of operations that are both associative and commutative?,연상 연산과 가환 연산의 예로는 어떤 것들이 있나요?,"- Addition and multiplication of integers
- Union, intersection, and  symmetric difference of sets
- Addition of vectors
- Addition of matrices of fixed dimension
- Addition and multiplication of polynomials","- 정수의 덧셈 및 곱셈
- 집합의 합집합, 교집합, 대칭 차이
- 벡터의 덧셈
- 고정 차원 행렬의 추가
- 다항식의 덧셈 및 곱셈",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some examples of operations that are associative but not commutative?,연상적이지만 가환적이지 않은 연산의 예는 무엇인가요?,"- concatenation of lists
- concatenation of strings
- matrix multiplication","- 목록 연결
- 문자열 연결
- 행렬 곱셈",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What should we worry about floating point addition and multiplication?,부동 소수점 덧셈과 곱셈에 대해 무엇을 걱정해야 할까요?,It is commutative but not associative.,그것은 교환적이지만 연상적이지 않습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the rule of thumb before optimizing or parallelizing?,최적화하거나 병렬화하기 전의 경험 법칙은 무엇인가요?,"Ensure the code works correctly first. Then, if you want to get fancy, you can begin to optimize your code for greater speed.",먼저 코드가 올바르게 작동하는지 확인하세요. 그런 다음 더 빠른 속도를 위해 코드를 최적화할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Does Python have an opcode cache?,파이썬에 옵코드 캐시가 있나요?,"In a way. It outputs a .pyc file, containing the bytecode. When a module is imported for the first time, or when the source is more recent than the current compiled file, a .pyc file containing the compiled code will usually be created in the same directory as the .py file. When you run the program next time, Python uses this file to skip the compilation step.",어떤 면에서는 바이트코드가 포함된 .pyc 파일을 출력합니다. 모듈을 처음 가져오거나 소스가 현재 컴파일된 파일보다 최근에 가져온 경우 일반적으로 컴파일된 코드가 포함된 .pyc 파일이 .py 파일과 동일한 디렉토리에 생성됩니다. 다음에 프로그램을 실행할 때 Python은 이 파일을 사용하여 컴파일 단계를 건너뛸 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Design a URL shortening service.,URL 단축 서비스를 설계하세요.,ask:,물어보세요:,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How would you design the feature in LinkedIn where it computes how many hops there are between you and another person?,LinkedIn에서 사용자와 다른 사람 사이에 몇 개의 홉이 있는지 계산하는 기능을 어떻게 설계하시겠습니까?,ask:,물어보세요:,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"If you were to design a web platform for online chess games, how would you do that?",온라인 체스 게임을 위한 웹 플랫폼을 디자인한다면 어떻게 하시겠습니까?,"ask:
-","물어보세요:
-",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some key things to remember when scaling a large system?,대규모 시스템을 확장할 때 기억해야 할 주요 사항은 무엇인가요?,"1) Asynchronous is good  (use queues, topics/pub-sub)
2) Parallel is good  (multi-threading, load balancing etc.)
3) Avoid points of contention e.g. synchronization
4) Avoid writing to disk until you must - cache like crazy
5) Scale out not up
6) At web scale the speed of light is a problem
7) At web scale everything fails - networks, load balancers etc.","1) 비동기식은 좋습니다 (큐, 토픽/펍 서브 사용)
2) 병렬 처리가 좋습니다(멀티스레딩, 로드 밸런싱 등)
3) 동기화와 같은 논쟁의 여지를 피하세요
4) 디스크에 쓰기 전까지는 쓰기를 피하세요 - 미친 듯이 캐시하세요
5) 스케일아웃, 업이 아닌 스케일아웃
6) 웹 규모에서는 빛의 속도가 문제입니다
7) 웹 규모에서는 네트워크, 로드 밸런서 등 모든 것이 실패합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Thrift?,중고품이란 무엇인가요?,"Apache Thrift is a framework for scalable cross-language services development. It combines a software stack with a code generation engine to build services that work efficiently and seamlessly between different languages. It handles serialization and has its own communication protocol.
IDL-based.","Apache Srift는 확장 가능한 언어 간 서비스 개발을 위한 프레임워크입니다. 소프트웨어 스택과 코드 생성 엔진을 결합하여 서로 다른 언어 간에 효율적이고 원활하게 작동하는 서비스를 구축합니다. 직렬화를 처리하고 자체 통신 프로토콜을 갖추고 있습니다.
IDL 기반.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Memcache?,멤카체란 무엇인가요?,An in-memory distributed hash table. It supports only a few commands but it is extremely efficient.,in-memory 분산 해시 테이블. 몇 가지 명령어만 지원하지만 매우 효율적입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does/did Facebook use memcache and mySQL in 2009?,2009년에 Facebook은 memcache와 mySQL을 어떻게 사용했나요?,"No joins in production. They have many logical databases for all of their types: people, events, place info, etc. They treat the web tier as a CPU, memcache as system memory, and the database as disk. Everything has an ID and you use the ID to query memcache using a multiget. Any misses are fetched from the database and cached in memcache.","프로덕션에 참여하지 않습니다. 사람, 이벤트, 장소 정보 등 모든 유형의 논리적 데이터베이스가 많이 있습니다. 웹 계층을 CPU, 멤캐시를 시스템 메모리, 데이터베이스를 디스크로 취급합니다. 모든 것에는 ID가 있으며, 이 ID를 사용하여 멀티젯을 사용하여 멤캐시를 쿼리합니다. 누락된 항목은 데이터베이스에서 가져와 멤캐시에 캐시됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an out-of-band cache?,대역 외 캐시란 무엇인가요?,"A cache layer that does not synch with persistent storage. When changes are made to the database, there are no notifications to synchronize with the cache. The cache entry would need to be updated or evicted by other means.",영구 저장소와 동기화되지 않는 캐시 계층입니다. 데이터베이스에 변경 사항이 적용되면 캐시와 동기화하라는 알림이 표시되지 않습니다. 캐시 항목은 다른 방법으로 업데이트하거나 삭제해야 합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a monad?,모나드란 무엇인가요?,"In functional programming, monads are a way to build computer programs by joining simple components in predictable and robust ways. A monad is a structure that represents computations defined as sequences of steps: a type with a monad structure defines what it means to chain operations together, or nest functions of that type. This allows the programmer to build pipelines that process data in a series of steps (i.e. a series of actions applied to the data), in which each action is decorated with additional processing rules provided by the monad. A monad is defined by a return operator that creates values, and a bind operator used to link the actions in the pipeline.","함수형 프로그래밍에서 모나드는 예측 가능하고 견고한 방식으로 간단한 구성 요소를 결합하여 컴퓨터 프로그램을 구축하는 방법입니다. 모나드는 일련의 단계로 정의된 계산을 나타내는 구조입니다. 모나드 구조를 가진 유형은 연산을 함께 연쇄하는 것이 무엇을 의미하는지 또는 해당 유형의 함수를 중첩하는 것을 정의합니다. 이를 통해 프로그래머는 데이터를 일련의 단계(즉, 데이터에 적용되는 일련의 작업)로 처리하는 파이프라인을 구축할 수 있으며, 각 작업은 모나드에서 제공하는 추가 처리 규칙으로 장식됩니다. 모나드는 값을 생성하는 반환 연산자와 파이프라인의 작업을 연결하는 데 사용되는 바인딩 연산자로 정의됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is pyramidpypi?,피라미드피피란 무엇인가요?,A self-hosted mirror of pypi.,자체 호스팅된 파이피 거울.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Big Omega represents what?,Big O메가는 무엇을 의미하나요?,A lower bound on the growth of a function. f grows at least as fast as g.,함수의 성장에 대한 하한선. f는 적어도 g만큼 빠르게 성장합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Theta represents what?,세타는 무엇을 의미하나요?,"A tight asymptotic bound on a function, in other words if both f and g have approximately the same rate of growth.","함수에 대한 엄격한 asymptotic 경계, 즉 f와 g가 거의 동일한 성장률을 가질 경우.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"For graph problems, the complexity  Theta(N + M) is known as what?",그래프 문제의 경우 복잡도 세타(N + M)는 무엇으로 알려져 있나요?,linear in the graph size,그래프 크기에 선형적인,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What is a better way of saying ""at least O(n^2)""?","""적어도 O(n^2)""를 더 잘 표현하는 방법은 무엇인가요?",big Omega(n^2),큰 오메가(n^2),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is data normalization?,데이터 정규화란 무엇인가요?,"Normalization is a systematic approach of decomposing tables to eliminate data redundancy and undesirable characteristics like insertion, update and deletion anomalies.

Normalization is used for mainly two purpose,
- eliminating redundant (useless) data
- ensuring data dependencies make sense","정규화는 데이터 중복성과 삽입, 업데이트 및 삭제 이상 현상과 같은 바람직하지 않은 특성을 제거하기 위해 테이블을 분해하는 체계적인 접근 방식입니다.

정규화는 주로 두 가지 목적으로 사용됩니다,
- 중복(useless) 데이터 제거
- 데이터 종속성이 합리적인지 확인하기",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the requirements for first normal form?,퍼스트 노멀 양식의 요구 사항은 무엇인가요?,"- each cell has a single value
- all items in a column must be of the same type
- rows are uniquely identified by a unique ID or a composite key","- 각 셀에는 단일 값이 있습니다
- 열의 모든 항목은 동일한 유형이어야 합니다
- 행은 고유 ID 또는 복합 키로 고유하게 식별됩니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the requirements for second normal form?,두 번째 정상 양식의 요구 사항은 무엇인가요?,All attributes (non-key columns) are dependent on the key,모든 속성(키가 아닌 열)은 키에 따라 달라집니다,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the requirements for third normal form?,세 번째 정상 양식의 요구 사항은 무엇인가요?,All fields can only be determined by the key in the table and no other column.,모든 필드는 테이블의 키로만 확인할 수 있으며 다른 열은 확인할 수 없습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the requirements for fourth normal form?,네 번째 정규 형식의 요구 사항은 무엇인가요?,"No multi-valued dependencies, meaning records should not be duplicated in a table just because more than one item is associated. This creates records that are duplicates except for one field.",다중 값 종속성이 없으므로 두 개 이상의 항목이 연관되어 있다고 해서 테이블에서 레코드를 중복해서는 안 됩니다. 이렇게 하면 한 필드를 제외하고 중복되는 레코드가 생성됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some use cases of Hadoop?,Hadoop의 사용 사례에는 어떤 것들이 있나요?,"- reporting on user behavior over many events
- log processing of 100s of billions of rows","- 여러 이벤트에 대한 사용자 행동 보고
- 1000억 개의 행에 대한 로그 처리",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some solid principles to keep in mind for scaling?,확장을 위해 염두에 두어야 할 몇 가지 확실한 원칙은 무엇인가요?,"- Keep it very simple
- Don’t re-invent the wheel
- Go with boring, proven and well-supported technologies when you can
- Build for what you will need over the next 12-18 months
- Make different things look the same
- Cache to protect the database
- Good enough is good enough","- 아주 간단하게 유지하세요
- 바퀴를 다시 발명하지 마세요
- 지루하고 검증되었으며 잘 지원되는 기술을 사용할 수 있습니다
- 향후 12~18개월 동안 필요한 것을 위해 구축하세요
- 다양한 것들을 똑같이 보이게 하세요
- 데이터베이스 보호를 위한 캐시
- 충분해, 충분해",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is gunicorn?,구니콘이란 무엇인가요?,A Python WSGI HTTP Server,파이썬 WSGI HTTP 서버,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is WSGI?,WSGI란 무엇인가요?,"WSGI is the Web Server Gateway Interface. It is a specification that describes how a web server communicates with web applications, and how web applications can be chained together to process one request. It was outlined in PEP 3333.

A WSGI server (meaning WSGI compliant) only receives the request from the client, pass it to the application and then send the response returned by the application to the client.","WSGI는 웹 서버 게이트웨이 인터페이스입니다. 이 인터페이스는 웹 서버가 웹 애플리케이션과 통신하는 방법과 웹 애플리케이션을 연결하여 하나의 요청을 처리하는 방법을 설명하는 사양입니다. 이 사양은 PEP 3333에 설명되어 있습니다.

WSGI 서버(WSGI 준수를 의미)는 클라이언트로부터 요청을 받은 후 애플리케이션에 전달한 후 애플리케이션이 반환한 응답을 클라이언트에 전송합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Fabric?,패브릭이란 무엇인가요?,Fabric is a Python (2.5-2.7) library and command-line tool for streamlining the use of SSH for application deployment or systems administration tasks.,Fabric은 애플리케이션 배포 또는 시스템 관리 작업에서 SSH 사용을 간소화하기 위한 Python(2.5-2.7) 라이브러리이자 명령줄 도구입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Apache Solr?,Apache 솔러란 무엇인가요?,"Solr is an open source enterprise search platform built on Apache Lucene.
Solr is highly reliable, scalable and fault tolerant, providing distributed indexing, replication and load-balanced querying, automated failover and recovery, centralized configuration and more.","Solr는 Apache Lucene을 기반으로 구축된 오픈 소스 엔터프라이즈 검색 플랫폼입니다.
Solr는 매우 안정적이고 확장 가능하며 내결함성이 뛰어나 분산 인덱싱, 복제 및 로드 밸런싱 쿼리, 자동화된 페일오버 및 복구, 중앙 집중식 구성 등을 제공합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is munin?,무닌이란 무엇인가요?,Graph metrics and alerting.,그래프 메트릭 및 알림.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What tends to become an issue as you add services in a datacenter and have to ping more caches and services to fulfill a request?,데이터 센터에 서비스를 추가하고 요청을 처리하기 위해 더 많은 캐시와 서비스를 핑해야 할 때 어떤 문제가 발생하는 경향이 있나요?,"Fan-in, where you can overload routers due to increased internal network traffic.",내부 네트워크 트래픽 증가로 인해 라우터를 과부하할 수 있는 팬인.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What can Redis be used for?,Redis는 무엇에 사용할 수 있나요?,"- a noSQL key-value store
- caches
- queues","- noSQL 키-값 저장소
- 캐시
- 대기열",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What is a benefit of sharding a database as it grows, and what determines the size?","데이터베이스가 성장함에 따라 공유하는 것의 이점은 무엇이며, 크기를 결정하는 것은 무엇인가요?","Keeping the index in cache ensures a user lookup doesn't have to hit the disk, lookups can be served from RAM. How much RAM you have will determine the index size which will hint at the underlying data size.","Keeping the index in cache ensures a user lookup doesn't have to hit the disk, lookups can be served from RAM. How much RAM you have will determine the index size which will hint at the underlying data size.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Why do most businesses end up sharding as they scale?,대부분의 비즈니스가 확장됨에 따라 결국 산산조각이 나는 이유는 무엇인가요?,To support massive concurrent writes.,대규모 동시 쓰기를 지원합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a message broker?,메시지 브로커란 무엇인가요?,Message broker is an intermediary program module that translates a message from the formal messaging protocol of the sender to the formal messaging protocol of the receiver. Message brokers are elements in telecommunication networks where software applications communicate by exchanging formally-defined messages. Message brokers are a building block of Message oriented middleware.,메시지 브로커는 메시지를 발신자의 공식 메시징 프로토콜에서 수신자의 공식 메시징 프로토콜로 변환하는 중개 프로그램 모듈입니다. 메시지 브로커는 소프트웨어 애플리케이션이 공식적으로 정의된 메시지를 교환하여 통신하는 통신 네트워크의 요소입니다. 메시지 브로커는 메시지 지향 미들웨어의 구성 요소입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some examples of message brokers?,메시지 브로커의 몇 가지 예는 무엇인가요?,"Apache ActiveMQ
Apache Kafka
Apache Qpid
Celery
Gearman
HornetQ (Red Hat)
IBM Integration Bus
JBoss Messaging (JBoss)
JORAM
Microsoft BizTalk Server (Microsoft)
Microsoft Azure Service Bus (Microsoft)
NATS (MIT Open Source License, written in Go)
Open Message Queue
Oracle Message Broker (Oracle Corporation)
QDB (Apache License 2.0, supports message replay by timestamp)
RabbitMQ (Mozilla Public License, written in Erlang)
SAP PI (SAP AG)
Spread Toolkit
Tarantool, a NoSQL database, with a set of stored procedures for message queues
WSO2 Message Broker
Enduro/X Transactional Message Queue (TMQ)","Apache ActiveMQ
Apache Kafka
Apache Qpid
Celery
Gearman
HornetQ (Red Hat)
IBM 통합 버스
JBoss 메시징(JBoss)
JORAM
Microsoft BizTalk 서버(Microsoft)
Microsoft Azure 서비스 버스(Microsoft)
NATS(MIT 오픈 소스 라이선스, Go로 작성)
메시지 대기열 열기
오라클 메시지 브로커(오라클 코퍼레이션)
QDB(Apache License 2.0, 타임스탬프를 통한 메시지 재생 지원)
RabbitMQ(모질라 공중 사용 허가서, 얼랑어로 작성됨)
SAP PI(SAP AG)
스프레드 툴킷
Tarantool, NoSQL 데이터베이스, 메시지 대기열을 위한 일련의 저장 절차 포함
WSO2 메시지 브로커
Enduro/X 트랜잭션 메시지 대기열(TMQ)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Ehcache?,에카체란 무엇인가요?,"Ehcache is an open source, standards-based cache that boosts performance, offloads your database, and simplifies scalability. It's the most widely-used Java-based cache.",Ehcache는 성능을 향상시키고 데이터베이스를 오프로드하며 확장성을 단순화하는 표준 기반 오픈 소스 캐시입니다. 가장 널리 사용되는 Java 기반 캐시입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Timing of a L1 cache reference?,L1 캐시 참조의 타이밍?,0.5 nanoseconds (ns),0.5 nanoseconds (ns),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Timing of a branch misprediction?,지점의 예측 오류 시기는 언제인가요?,5 nanoseconds (ns),5나노초(ns),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Timing of a L2 cache reference?,L2 캐시 참조의 타이밍?,7 nanoseconds (ns),7나노초(ns),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Timing of a mutex lock/unlock?,뮤텍스 잠금/잠금 해제 타이밍?,25 nanoseconds (ns),25나노초(ns),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Timing of a main memory reference?,주 기억 참조의 타이밍?,100 nanoseconds (ns),100나노초(ns),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Timing to compress 1KB?,1KB를 압축하는 타이밍?,"3,000 nanoseconds (3 microseconds)","3,000나노초(3마이크로초)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Time to send 2K bytes over 1 Gbps network?,1Gbps 네트워크를 통해 2K 바이트를 전송할 시간인가요?,"10,000 nanoseconds (0.01 ms)","10,000 나노초(0.01 밀리초)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Time to read 4KB randomly from an SSD?,SSD에서 4KB를 무작위로 읽을 시간인가요?,"150,000 nanoseconds (0.15 ms)","150,000 나노초(0.15 밀리초)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Timing to read 1MB sequentially from memory?,메모리에서 1MB를 순차적으로 읽는 타이밍?,"250,000 nanoseconds (0.25 ms)","250,000 나노초(0.25 밀리초)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Timing of a disk seek?,디스크 탐색의 타이밍?,"10,000,000 nanoseconds (10 ms)","10,000,000 나노초(10ms)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Time to read 1MB sequentially from an SSD?,SSD에서 1MB를 순차적으로 읽을 시간인가요?,"1,000,000 nanoseconds (1 ms)
4x memory","1,000,000 나노초(1ms)
4배 메모리",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Timing to read 1MB sequentially from disk?,디스크에서 1MB를 순차적으로 읽는 타이밍?,"20,000,000 nanoseconds (20 ms)
80x memory
20x SSD","20,000,000 나노초(20ms)
80배 메모리
20배 SSD",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Timing to send a packet CA -> Netherlands -> CA?,Timing to send a packet CA -> Netherlands -> CA?,"150,000,000 nanoseconds (150 ms)","150,000,000 나노초(150밀리초)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Timing of a context switch between processes?,프로세스 간의 컨텍스트 전환 타이밍?,3000 nanoseconds,3000나노초,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Timing of fork()?,Timing of fork()?,"Between 70,000 and 160,000 nanoseconds.","약 70,000에서 160,000 나노초 사이입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the timing overhead for a system call?,시스템 호출의 타이밍 오버헤드는 얼마인가요?,400 nanoseconds,400나노초,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Kafka?,Kafka란 무엇인가요?,"Apache Kafka is pub-sub messaging rethought as a distributed commit log.
Kafka is a distributed, partitioned, replicated commit log service. It provides the functionality of a messaging system, but with a unique design.
A single Kafka broker can handle hundreds of megabytes of reads and writes per second from thousands of clients.","Apache Kafka는 분산 커밋 로그로 재구성된 펍-서브 메시징입니다.
Kafka는 분산, 분할, 복제된 커밋 로그 서비스입니다. 메시징 시스템의 기능을 제공하지만 독특한 디자인을 가지고 있습니다.
하나의 Kafka 브로커는 수천 명의 클라이언트로부터 초당 수백 메가바이트의 읽기와 쓰기를 처리할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is GAE?,GAE란 무엇인가요?,"Google App Engine is a platform for building scalable web applications and mobile backends. App Engine provides you with built-in services and APIs such as NoSQL datastores, memcache, and a user authentication API, common to most applications.","Google 앱 엔진은 확장 가능한 웹 애플리케이션과 모바일 백엔드를 구축하기 위한 플랫폼입니다. 앱 엔진은 대부분의 애플리케이션에 공통적으로 사용되는 NoSQL 데이터스토어, 멤캐시, 사용자 인증 API와 같은 내장 서비스와 API를 제공합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is GDS?,GDS란 무엇인가요?,"Google Cloud Datastore is a NoSQL document database built for automatic scaling, high performance, and ease of application development. Cloud Datastore features include:

Atomic transactions.
Massive scalability with high performance.
Flexible storage and querying of data.
Balance of strong and eventual consistency. 
Encryption at rest.
Fully managed with no planned downtime.","Google 클라우드 데이터스토어는 자동 확장, 고성능, 애플리케이션 개발의 용이성을 위해 구축된 NoSQL 문서 데이터베이스입니다. 클라우드 데이터스토어 기능에는 다음이 포함됩니다:

원자 거래.
고성능의 대규모 확장성.
유연한 데이터 저장 및 조회.
강력한 일관성과 궁극적인 일관성의 균형. 
암호화가 중단되었습니다.
계획된 다운타임 없이 완벽하게 관리됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the problem that serialization introduces?,연재가 도입하는 문제는 무엇인가요?,"The overhead of serializing and deserializing. It's all expensive, and for Python, it can be terribly slow.","직렬화와 역직렬화의 오버헤드. 이 모든 것이 비싸고, 파이썬의 경우 매우 느릴 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does the Python bisect module do?,파이썬 이등분 모듈은 무엇을 하나요?,"The bisect module, part of the standard library, provides support for maintaining a list in sorted order without having to sort the list after each insertion. For long lists of items with expensive comparison operations, this can be an improvement over the more common approach.","표준 라이브러리의 일부인 이등분 모듈은 각 삽입 후 목록을 정렬할 필요 없이 정렬된 순서대로 목록을 유지할 수 있도록 지원합니다. 비교 작업이 많은 항목의 긴 목록의 경우, 이는 더 일반적인 접근 방식보다 개선된 것일 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is PycURL?,What is PycURL?,"PycURL is a Python interface to libcurl. PycURL can be used to fetch objects identified by a URL from a Python program, similar to the urllib Python module. PycURL is mature, very fast, and supports a lot of features.
PycURL is targeted at an advanced developer - if you need dozens of concurrent, fast and reliable connections or any of the sophisticated features listed above then PycURL is for you.
The main drawback of PycURL is that it is a relatively thin layer over libcurl without any of those nice Pythonic class hierarchies. This means it has a somewhat steep learning curve unless you are already familiar with libcurl's C API.","PycURL은 libcurl에 대한 파이썬 인터페이스입니다. PycURL은 urllib 파이썬 모듈과 유사하게 파이썬 프로그램에서 URL로 식별된 객체를 가져오는 데 사용할 수 있습니다. PycURL은 성숙하고 매우 빠르며 많은 기능을 지원합니다.
PycURL은 고급 개발자를 대상으로 하며, 수십 개의 동시에 빠르고 안정적인 연결이 필요하거나 위에 나열된 정교한 기능이 필요한 경우 PycURL이 적합합니다.
PycURL의 주요 단점은 Libcurl에 비해 상대적으로 얇은 레이어로, 이러한 좋은 Python 클래스 계층 구조가 없다는 것입니다. 이는 Libcurl의 C API에 이미 익숙하지 않은 한 학습 곡선이 다소 가파르다는 것을 의미합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does PycURL compare to requests?,PycURL은 요청과 어떻게 비교되나요?,"PycURL can handle a large number of multiple concurrent requests. When reusing connections, it can perform more than 2,000 requests per second.

pycurl takes about 73 CPU-microseconds to issue a request when reusing a connection
requests takes about 526 CPU-microseconds to issue a request when reusing a connection
pycurl takes about 165 CPU-microseconds to open a new connection and issue a request (no connection reuse), or ~92 microseconds to open
requests takes about 1078 CPU-microseconds to open a new connection and issue a request (no connection reuse), or ~552 microseconds to open","PycURL은 여러 개의 동시 요청을 처리할 수 있습니다. 연결을 재사용할 때 초당 2,000개 이상의 요청을 수행할 수 있습니다.

파이컬은 연결을 재사용할 때 요청을 발행하는 데 약 73 CPU 마이크로초가 걸립니다
연결을 재사용할 때 요청을 발행하는 데 약 526 CPU 마이크로초가 걸립니다
pycurl은 새 연결을 열고 요청을 발행하는 데 약 165 CPU-마이크로초, 즉 연결 재사용이 없는 경우 약 92 마이크로초가 걸립니다
새 연결을 열고 요청을 발행하는 데 약 1078개의 CPU-마이크로초가 소요되며(연결 재사용이 없음), 또는 약 552개의 마이크로초가 소요됩니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is ZooKeeper?,ZooKeeper란 무엇인가요?,"Apache ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them, which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management complexity when the applications are deployed.
Has Java and C interfaces.","Apache ZooKeeper는 구성 정보를 유지 관리하고, 이름을 지정하고, 분산 동기화를 제공하며, 그룹 서비스를 제공하기 위한 중앙 집중식 서비스입니다. 이러한 모든 종류의 서비스는 분산 애플리케이션에 의해 어떤 형태로든 사용됩니다. 각 서비스가 구현될 때마다 버그와 인종 조건을 수정하는 데 많은 노력이 필요합니다. 이러한 종류의 서비스를 구현하는 것이 어렵기 때문에 애플리케이션은 처음에 이러한 서비스를 생략하는 경우가 많으며, 이는 변경이 있을 때 취약하고 관리하기 어렵습니다. 올바르게 수행되더라도 이러한 서비스의 다양한 구현은 애플리케이션이 배포될 때 관리 복잡성을 초래합니다.
Java 및 C 인터페이스가 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is orthogonality?,직교성이란 무엇인가요?,"In mathematical terms, it means being perpendicular.

Orthogonality in programming language design is the ability to use various language features in arbitrary combinations with consistent results.

Orthogonality is a system design property which guarantees that modifying the technical effect produced by a component of a system neither creates nor propagates side effects to other components of the system. Typically this is achieved through the separation of concerns and encapsulation, and it is essential for feasible and compact designs of complex systems. The emergent behavior of a system consisting of components should be controlled strictly by formal definitions of its logic and not by side effects resulting from poor integration, i.e., non-orthogonal design of modules and interfaces. Orthogonality reduces testing and development time because it is easier to verify designs that neither cause side effects nor depend on them.","수학적 용어로, 그것은 수직이라는 것을 의미합니다.

프로그래밍 언어 설계에서 직교성은 다양한 언어 특징을 임의의 조합으로 일관된 결과로 사용할 수 있는 능력입니다.

직교성은 시스템의 구성 요소가 생성하는 기술적 효과를 수정하는 것이 시스템의 다른 구성 요소에 부작용을 일으키거나 전파하지 않도록 보장하는 시스템 설계 속성입니다. 일반적으로 이는 관심사와 캡슐화의 분리를 통해 이루어지며, 복잡한 시스템의 실현 가능하고 컴팩트한 설계에 필수적입니다. 구성 요소로 구성된 시스템의 출현 동작은 모듈과 인터페이스의 비직교 설계, 즉 통합 불량으로 인한 부작용이 아닌 논리의 형식적 정의에 의해 엄격하게 제어되어야 합니다. 직교성은 부작용을 유발하지도 않고 의존하지도 않는 설계를 검증하는 것이 더 쉽기 때문에 테스트 및 개발 시간을 단축시킵니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"When dealing with scaling, how can you deal with rapidly increasing counters, like YouTube video views?","스케일링을 다룰 때, 유튜브 동영상 조회수와 같이 급격히 증가하는 카운터를 어떻게 처리할 수 있을까요?","You can add randomness to a monotonic counter, because as long as people can see it is increasing somewhat monotonically, it doesn't need to be 100% accurate. And avoids need to lock it in a transaction.",단조 카운터에 무작위성을 추가할 수 있습니다. 사람들이 다소 단조롭게 증가하는 것을 볼 수 있는 한 100% 정확할 필요는 없습니다. 또한 트랜잭션에 고정할 필요도 없습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is exponential backoff and when is it used?,지수 백오프란 무엇이며 언제 사용되나요?,"Binary exponential backoff or truncated binary exponential backoff refers to an algorithm used to space out repeated retransmissions of network or other service requests, often as part of congestion avoidance.",이진 지수 백오프 또는 절단 이진 지수 백오프는 혼잡 회피의 일환으로 네트워크 또는 기타 서비스 요청의 반복적인 재전송을 간격을 두는 데 사용되는 알고리즘을 말합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What data structure could be used to efficiently manage a leaderboard?,리더보드를 효율적으로 관리하기 위해 어떤 데이터 구조를 사용할 수 있나요?,A b-tree where each node manages a subset of the range of the worst to best scores.,각 노드가 최악의 점수부터 최고 점수까지의 범위 중 일부를 관리하는 b-트리입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does adding jitter in system design help you avoid?,시스템 설계에 지터를 추가하는 것이 무엇을 피하는 데 도움이 되나요?,"If your system doesn’t jitter then you get thundering herds. Distributed applications are really weather systems. Debugging them is as deterministic as predicting the weather. Jitter introduces more randomness because surprisingly, things tend to stack up.",시스템이 지터지지 않으면 천둥치는 무리가 생깁니다. 분산 애플리케이션은 실제로 기상 시스템입니다. 이를 디버깅하는 것은 날씨를 예측하는 것만큼이나 결정론적입니다. 지터는 놀랍게도 일이 쌓이는 경향이 있기 때문에 더 많은 무작위성을 유발합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an example of adding jitter to a caching system?,캐싱 시스템에 지터를 추가하는 예는 무엇인가요?,"Cache expirations. For a popular video they cache things as best they can. The most popular video they might cache for 24 hours. If everything expires at one time then every machine will calculate the expiration at the same time. This creates a thundering herd.
By jittering you are saying randomly expire between 18-30 hours. That prevents things from stacking up. They use this all over the place. Systems have a tendency to self synchronize as operations line up and try to destroy themselves. Fascinating to watch. You get slow disk system on one machine and everybody is waiting on a request so all of a sudden all these other requests on all these other machines are completely synchronized. This happens when you have many machines and you have many events. Each one actually removes entropy from the system so you have to add some back in.","캐시 만료. 인기 있는 비디오의 경우 가능한 한 최선을 다해 캐시합니다. 24시간 동안 캐시할 수 있는 가장 인기 있는 비디오입니다. 모든 것이 한 번에 만료되면 모든 기계가 동시에 만료를 계산합니다. 이렇게 하면 천둥치는 무리가 생깁니다.
18시간에서 30시간 사이에 무작위로 만료된다고 말하는 것입니다. 그러면 물건이 쌓이는 것을 방지할 수 있습니다. 이를 여기저기 사용합니다. 시스템은 작업이 줄을 서서 스스로를 파괴하려고 할 때 스스로 동기화되는 경향이 있습니다. 보기에 흥미롭습니다. 한 컴퓨터에 느린 디스크 시스템이 있고 모두가 요청을 기다리고 있기 때문에 갑자기 다른 모든 컴퓨터의 다른 요청이 완전히 동기화됩니다. 이는 많은 컴퓨터가 있고 이벤트가 많을 때 발생합니다. 각 시스템은 실제로 시스템에서 엔트로피를 제거하므로 다시 추가해야 합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What value can you make cron or other system intervals so they don't coincide?,cron 또는 기타 시스템 간격이 일치하지 않도록 어떤 값을 만들 수 있나요?,Use distinct prime numbers for periodicities.,주기성을 위해 고유한 소수를 사용하세요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What Python package provides tools for adapting or extending functions and other callable objects, without completely rewriting them?",함수 및 기타 호출 가능한 객체를 완전히 다시 작성하지 않고도 적응하거나 확장할 수 있는 도구를 제공하는 Python 패키지는 무엇인가요?,"functools
offers:
Decorators
Comparison
Rich Comparison
Collation Order
Caching
Reducing a Data Set
Generic Functions","기능 도구
제안:
장식가들
비교
풍부한 비교
대조 순서
캐싱
데이터 세트 줄이기
일반 함수",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a proxy server?,프록시 서버란 무엇인가요?,"A proxy server is an intermediate piece of hardware/software that receives requests from clients and relays them to the backend origin servers. Typically, proxies are used to filter requests, log requests, or sometimes transform requests (by adding/removing headers, encrypting/decrypting, or compression).","프록시 서버는 클라이언트로부터 요청을 받아 백엔드 오리진 서버로 릴레이하는 중간 하드웨어/소프트웨어입니다. 일반적으로 프록시는 헤더 추가/제거, 암호화/복호화 또는 압축을 통해 요청을 필터링하거나 로그 요청을 변환하는 데 사용됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is collapsed forwarding?,붕괴된 전달이란 무엇인가요?,"A proxy server can collapse the same (or similar) requests together into one request, and then return the single result to the requesting clients.

Another great way to use the proxy is to not just collapse requests for the same data, but also to collapse requests for data that is spatially close together in the origin store (consecutively on disk).","프록시 서버는 동일한(또는 유사한) 요청을 하나의 요청으로 통합한 다음, 요청하는 클라이언트에게 단일 결과를 반환할 수 있습니다.

프록시를 사용하는 또 다른 좋은 방법은 동일한 데이터에 대한 요청을 축소하는 것뿐만 아니라 원본 저장소에서 공간적으로 가까운 데이터에 대한 요청도 디스크에서 연속적으로 축소하는 것입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What should be handling requests first, a proxy server or a cache?",요청을 먼저 처리하려면 프록시 서버와 캐시 중 무엇을 해야 하나요?,"Generally it is best to put the cache in front of the proxy. This is because the cache is serving data from memory, it is very fast, and it doesn't mind multiple requests for the same result. But if the cache was located on the other side of the proxy server, then there would be additional latency with every request before the cache, and this could hinder performance.",일반적으로 캐시는 프록시 앞에 두는 것이 가장 좋습니다. 캐시는 메모리에서 데이터를 처리하고 있으며 매우 빠르며 동일한 결과에 대한 여러 요청도 상관없기 때문입니다. 하지만 캐시가 프록시 서버의 반대편에 위치했다면 캐시 이전의 모든 요청에 추가 지연이 발생하여 성능이 저하될 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some popular proxies?,인기 있는 프록시에는 어떤 것이 있나요?,"HAProxy
Squid
Varnish","HAProxy
Squid
Varnish",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Why do indexes tend to slow down writes?,인덱스가 쓰기 속도를 늦추는 경향이 있는 이유는 무엇인가요?,Since you must both write the data and update the index.,데이터를 작성하고 인덱스를 업데이트해야 하기 때문입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the role of a load balancer?,로드 밸런서의 역할은 무엇인가요?,"The role is to distribute load across a set of nodes responsible for servicing requests. This allows multiple nodes to transparently service the same function in a system. Their main purpose is to handle a lot of simultaneous connections and route those connections to one of the request nodes, allowing the system to scale to service more requests by just adding nodes.",역할은 요청을 처리하는 노드 집합에 부하를 분산시키는 것입니다. 이를 통해 여러 노드가 시스템에서 동일한 기능을 투명하게 처리할 수 있습니다. 이들의 주요 목적은 많은 동시 연결을 처리하고 해당 연결을 요청 노드 중 하나로 라우팅하여 노드를 추가하기만 하면 시스템이 더 많은 요청을 처리할 수 있도록 확장할 수 있도록 하는 것입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a drawback of advanced features in a load balancer?,로드 밸런서의 고급 기능의 단점은 무엇인가요?,"Advanced features can make problem diagnosis cumbersome. For example, when it comes to high load situations, load balancers will remove nodes that may be slow or timing out (because of too many requests), but that only exacerbates the situation for the other nodes.","고급 기능은 문제 진단을 번거롭게 만들 수 있습니다. 예를 들어, 부하가 높은 상황에서는 로드 밸런서가 너무 많은 요청으로 인해 속도가 느리거나 타이밍이 맞지 않는 노드를 제거하지만, 이는 다른 노드의 상황을 악화시킬 뿐입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a benefit of adding asynchrony to a system?,시스템에 비동기성을 추가하면 어떤 이점이 있나요?,"It keeps clients from holding connections to servers when waiting for a response for a task that could simply be deferred. This reduces load on servers that are performing writes, for example, and lets them perform a task when ready, not on-demand.","클라이언트가 단순히 지연될 수 있는 작업에 대한 응답을 기다릴 때 서버에 대한 연결을 유지하지 못하도록 합니다. 이렇게 하면 예를 들어 쓰기를 수행하는 서버의 부하를 줄이고, 필요할 때가 아닌 준비된 상태에서 작업을 수행할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the difference between a synchronous system and an asynchronous system?,동기식 시스템과 비동기식 시스템의 차이점은 무엇인가요?,"In a synchronous system, there is no differentiation between request and reply, and they therefore cannot be managed separately. In an asynchronous system the client requests a task, the service responds with a message acknowledging the task was received, and then the client can periodically check the status of the task, only requesting the result once it has completed.

While the client is waiting for an asynchronous request to be completed it is free to perform other work, even making asynchronous requests of other services.","동기화 시스템에서는 요청과 응답을 구분할 수 없으므로 별도로 관리할 수 없습니다. 비동기화 시스템에서는 클라이언트가 작업을 요청하면 서비스가 작업이 수신되었음을 알리는 메시지로 응답하고, 클라이언트는 작업이 완료된 후에만 주기적으로 작업 상태를 확인할 수 있습니다.

클라이언트가 비동기 요청이 완료되기를 기다리는 동안, 다른 작업을 수행하는 것은 자유이며, 심지어 다른 서비스의 비동기 요청도 수행할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some examples of well-known queue (or can act as a queue) software?,잘 알려진 대기열(또는 대기열 역할을 할 수 있는) 소프트웨어의 예는 무엇인가요?,"BeanstalkD
RabbitMQ
ActiveMQ
BeanstalkD
Redis","BeanstalkD
RabbitMQ
ActiveMQ
BeanstalkD
Redis",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Does asynchronous code tend to be CPU-bound or I/O bound?,"비동기 코드는 CPU에 바인딩되는 경향이 있나요, 아니면 I/O에 바인딩되는 경향이 있나요?","Asynchronous code tends to be CPU bound, because anything that would block is simply deferred to later, until the blocking operation completes. This means that threads in asynchronous / non-blocking applications are much more likely to use their full time quantum before the kernel scheduler preempts them.","비동기 코드는 CPU 바인딩인 경향이 있습니다. 왜냐하면 차단 작업이 완료될 때까지 차단할 모든 것이 나중으로 연기되기 때문입니다. 즉, 비동기/비차단 애플리케이션의 스레드는 커널 스케줄러가 이를 선점하기 전에 풀타임 퀀텀을 사용할 가능성이 훨씬 더 높습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the optimal number of threads?,최적의 스레드 수는 얼마인가요?,"And if there's the same number of runnable threads as there are hardware threads, the kernel is very likely to reschedule threads on the same core, which significantly helps performance.","그리고 실행 가능한 스레드의 수가 하드웨어 스레드와 동일하다면, 커널은 동일한 코어에서 스레드를 다시 스케줄링할 가능성이 매우 높아 성능에 큰 도움이 됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the typical time slice for a process on a Linux box?,리눅스 박스에서 프로세스의 일반적인 타임슬라이스는 무엇인가요?,"Linux kernels are often compiled with HZ=100, which entails that processes are given time slices of 10ms.","리눅스 커널은 종종 HZ=100으로 컴파일되며, 이는 프로세스에 10ms의 타임 슬라이스가 부여된다는 것을 의미합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does Linux handle CPU affinity?,Linux는 CPU 친화성을 어떻게 처리하나요?,"Default Linux kernels don't do a good job at keeping CPU affinity, even on idle machines. You must explore alternative schedulers or use taskset or cpuset to control affinity yourself.",기본 Linux 커널은 유휴 머신에서도 CPU 친화성을 잘 유지하지 못합니다. 대체 스케줄러를 탐색하거나 태스크셋 또는 CPU셋을 사용하여 직접 친화성을 제어해야 합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is futex?,퓨텍스란 무엇인가요?,"A futex (short for ""fast userspace mutex"") is a Linux kernel system call that programmers can use to implement basic locking, or as a building block for higher-level locking abstractions such as semaphores and POSIX mutexes or condition variables.","futex(""빠른 사용자 공간 뮤텍스""의 줄임말)는 프로그래머가 기본 잠금을 구현하거나 세마포어 및 POSIX 뮤텍스와 같은 상위 수준의 잠금 추상화 또는 조건 변수를 위한 빌딩 블록으로 사용할 수 있는 리눅스 커널 시스템 호출입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How do context switches perform under virtualization?,가상화 하에서 컨텍스트 스위치는 어떻게 작동하나요?,"On average, it's 2.5x to 3x more expensive to do a context switch when using virtualization. My guess is that this is due to the fact that the guest OS can't update the page table itself, so when it attempts to change it, the hypervisor intervenes, which causes an extra 2 context switches (one to get inside the hypervisor, one to get out, back to the guest OS).","평균적으로 가상화를 사용할 때 컨텍스트 전환을 수행하는 데 2.5배에서 3배 더 비쌉니다. 이는 게스트 OS가 페이지 테이블 자체를 업데이트할 수 없기 때문에 변경을 시도할 때 하이퍼바이저가 개입하여 추가로 두 개의 컨텍스트 전환(하나는 하이퍼바이저 내부로 들어가고, 다른 하나는 게스트 OS로 돌아갑니다)이 발생하기 때문입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a Frame Check Sequence?,프레임 검사 시퀀스란 무엇인가요?,The Frame Check Sequence (FCS) field is used to determine if errors occurred in the transmission and reception of the frame. Error detection is added at the Data Link layer because this is where data is transferred across the media.,프레임 확인 시퀀스(FCS) 필드는 프레임의 송수신에서 오류가 발생했는지 여부를 확인하는 데 사용됩니다. 오류 감지는 미디어를 통해 데이터가 전송되기 때문에 데이터 링크 계층에서 추가됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does Google handle a search request?,Google은 검색 요청을 어떻게 처리하나요?,"Scatter/gather
In this model, the dispatcher multicast the request to all workers of the pool. Each worker will compute a local result and send it back to the dispatcher, who will consolidate them into a single response and then send back to the client.","흩어짐/모여짐
이 모델에서 디스패처는 풀의 모든 작업자에게 요청을 멀티캐스트합니다. 각 작업자는 로컬 결과를 계산하여 디스패처로 전송하고, 디스패처는 이를 단일 응답으로 통합한 다음 클라이언트로 다시 전송합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an example of bulk synchronous processing?,대량 동기화 처리의 예는 무엇인가요?,"Parallel Graph Transformation

The main goal of Graph transformation is to modify the graph. This include modifying the properties of existing nodes and arcs, creating new arcs / nodes and removing existing arcs / nodes. The modification logic is provided by a user-defined function, which will be applied to all active nodes.","병렬 그래프 변환

그래프 변환의 주요 목표는 그래프를 수정하는 것입니다. 여기에는 기존 노드와 아크의 속성을 수정하고, 새로운 아크/노드를 생성하며, 기존 아크/노드를 제거하는 작업이 포함됩니다. 수정 로직은 모든 활성 노드에 적용될 사용자 정의 함수에 의해 제공됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Execution Orchestrator,실행 오케스트레이터,"This model is based on an intelligent scheduler / orchestrator to schedule ready-to-run tasks (based on a dependency graph) across a clusters of dumb workers.

example: Microsoft Dryad","이 모델은 지능형 스케줄러/오케스트레이터를 기반으로 하여, 종속성 그래프를 기반으로 한 실행 준비 작업을 여러 덤 워커 클러스터에서 스케줄링합니다.

예제: Microsoft Dryad",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are 2 reasons for using a load balancer?,로드 밸런서를 사용하는 두 가지 이유는 무엇인가요?,horizontal scalability and redundancy,수평적 확장성 및 중복성,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are balancing methods used by load balancers?,로드 밸런서에서 사용하는 밸런싱 방법은 무엇인가요?,"assignment of a request: random, round-robin, random with weighting for machine capacity, etc
matched with current status (available for requests, not responding, elevated error rate, etc).","요청 할당: 랜덤, 원형 robin, 기계 용량 가중치가 있는 랜덤 등
현재 상태와 일치합니다(요청, 응답 없음, 오류율 상승 등).",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What are the 3 choices in load balancers? The 3 kinds, not balancing mechanisms.",로드 밸런서의 세 가지 선택지는 무엇인가요? 균형 메커니즘이 아닌 세 가지 종류입니다.,"- Smart client, a software based mechanism for determining the availability of a server.
- Hardware load balancer, such as Citrix NetScaler, are remarkably expensive, and they are also ""non-trivial"" to configure.
- Software load balancer: HAProxy","- 스마트 클라이언트는 서버의 가용성을 결정하는 소프트웨어 기반 메커니즘입니다.
- Citrix NetScaler와 같은 하드웨어 로드 밸런서는 놀라울 정도로 비싸고 구성하기에도 ""사소한"" 요소가 없습니다.
- 소프트웨어 로드 밸런서: HAProxy",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are 2 examples of in-memory caches?,in-memory cache의 두 가지 예는 무엇인가요?,Memcached and Redis are both examples of in-memory caches,Memcache와 Redis는 모두 in-memory cache의 예입니다,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is write-through cache?,쓰기 캐시란 무엇인가요?,"Write-through cache directs write I/O onto cache and through to underlying permanent storage before confirming I/O completion to the host. This ensures data updates are safely stored on, for example, a shared storage array, but has the disadvantage that I/O still experiences latency based on writing to that storage. Write-through cache is good for applications that write and then re-read data frequently as data is stored in cache and results in low read latency.","쓰기 캐시는 호스트에게 I/O 완료를 확인하기 전에 쓰기 I/O를 캐시로, 그리고 기본 영구 저장소로 전달합니다. 이렇게 하면 데이터 업데이트가 공유 스토리지 배열에 안전하게 저장되지만, I/O가 해당 저장소에 쓰기를 할 때 여전히 지연이 발생한다는 단점이 있습니다. 쓰기 캐시는 캐시에 데이터가 저장되어 읽기 지연 시간이 짧기 때문에 데이터를 자주 쓰고 다시 읽는 애플리케이션에 적합합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is write-back cache?,라이트백 캐시란 무엇인가요?,"Write-back cache is where write I/O is directed to cache and completion is immediately confirmed to the host. This results in low latency and high throughput for write-intensive applications, but there is data availability exposure risk because the only copy of the written data is in cache. As we will discuss later, suppliers have added resiliency with products that duplicate writes. Users need to consider whether write-back cache solutions offer enough protection as data is exposed until it is staged to external storage. Write-back cache is the best performing solution for mixed workloads as both read and write I/O have similar response time levels.","쓰기-백 캐시는 쓰기 I/O가 캐시로 향하고 완료가 호스트에게 즉시 확인되는 곳입니다. 이로 인해 쓰기 집약적인 애플리케이션에서는 지연 시간이 짧고 처리량이 높지만, 작성된 데이터의 유일한 복사본이 캐시에 있기 때문에 데이터 가용성 노출 위험이 있습니다. 나중에 논의하겠지만, 공급업체는 쓰기를 복제하는 제품으로 복원력을 높였습니다. 사용자는 쓰기-백 캐시 솔루션이 외부 스토리지로 단계적으로 데이터가 노출될 때 충분한 보호 기능을 제공하는지 고려해야 합니다. 쓰기-백 캐시는 읽기 및 쓰기 I/O 모두 응답 시간 수준이 유사하기 때문에 혼합 워크로드에 가장 적합한 성능 솔루션입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is read-through cache?,읽기 캐시란 무엇인가요?,"An item is accessed from cache, and if it's a cache miss, the data will be read from persistent storage (perhaps with a callback) and then placed into cache. The response is then sent back to the host.",캐시에서 항목에 액세스하면 캐시 미스가 발생하면 영구 저장소(아마도 콜백을 사용하여)에서 데이터를 읽은 다음 캐시에 저장합니다. 그런 다음 응답이 호스트로 다시 전송됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is HDFS?,HDFS란 무엇인가요?,"Hadoop File System (HDFS) is a Java-based file system that provides scalable and reliable data storage, and it was designed to span large clusters of commodity servers.","Hadoop 파일 시스템(HDFS)은 확장 가능하고 신뢰할 수 있는 데이터 저장을 제공하는 자바 기반 파일 시스템으로, 대규모 상용 서버 클러스터에 걸쳐 설계되었습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Hortonworks?,호튼웍스란 무엇인가요?,"Hortonworks is a software company focused on the development and support of Apache Hadoop, a framework that allows for the distributed processing of large data sets across clusters of computers.",Hortonworks는 대규모 데이터 세트를 여러 컴퓨터 클러스터에서 분산 처리할 수 있는 프레임워크인 Apache Hadoop의 개발 및 지원에 중점을 둔 소프트웨어 회사입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a platform layer?,플랫폼 레이어란 무엇인가요?,"Web applications to communicate with a platform layer which in turn communicates with your databases. 

First, separating the platform and web application allow you to scale the pieces independently. If you add a new API, you can add platform servers without adding unnecessary capacity for your web application tier. 

Second, adding a platform layer can be a way to reuse your infrastructure for multiple products or interfaces (a web application, an API, an iPhone app, etc) without writing too much redundant boilerplate code for dealing with caches, databases, etc.

Third, a sometimes underappreciated aspect of platform layers is that they make it easier to scale an organization. At their best, a platform exposes a crisp product-agnostic interface which masks implementation details. If done well, this allows multiple independent teams to develop utilizing the platform's capabilities, as well as another team implementing/optimizing the platform itself.","플랫폼 계층과 통신하는 웹 애플리케이션은 다시 데이터베이스와 통신합니다. 

먼저 플랫폼과 웹 애플리케이션을 분리하면 조각을 독립적으로 확장할 수 있습니다. 새 API를 추가하면 웹 애플리케이션 계층에 불필요한 용량을 추가하지 않고도 플랫폼 서버를 추가할 수 있습니다. 

둘째, 플랫폼 계층을 추가하는 것은 캐시, 데이터베이스 등을 처리하기 위해 너무 많은 중복 보일러플레이트 코드를 작성하지 않고도 여러 제품이나 인터페이스(웹 애플리케이션, API, iPhone 앱 등)에 대한 인프라를 재사용할 수 있는 방법이 될 수 있습니다.

셋째, 플랫폼 계층의 때때로 과소평가되는 측면은 조직을 확장하기 쉽게 만든다는 점입니다. 플랫폼은 최상의 경우 구현 세부 사항을 가리는 제품에 구애받지 않는 선명한 인터페이스를 제공합니다. 이를 통해 여러 독립 팀이 플랫폼의 기능을 활용하여 개발할 수 있으며, 다른 팀도 플랫폼 자체를 구현/최적화할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is multi-homing?,멀티 호밍이란 무엇인가요?,Running a service across multiple datacenters.,여러 데이터 센터에서 서비스를 실행합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Where is weak consistency OK?,약한 일관성은 어디에서 괜찮나요?,"- caching
- VOIP
- real-time mutiplayer games","- 캐싱
- VOIP
- 실시간 멀티플레이어 게임",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Paxos algorithm?,팍소스 알고리즘이란 무엇인가요?,Paxos is a family of protocols for solving consensus in a network of unreliable processors. Consensus is the process of agreeing on one result among a group of participants. This problem becomes difficult when the participants or their communication medium may experience failures.,팍소스는 신뢰할 수 없는 프로세서 네트워크에서 합의를 해결하기 위한 프로토콜 제품군입니다. 합의는 참가자 그룹 간에 하나의 결과에 동의하는 과정입니다. 참가자나 그들의 커뮤니케이션 매체가 실패를 경험할 경우 이 문제는 어려워집니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What problem does consistent hashing help solve?,일관된 해싱은 어떤 문제를 해결하는 데 도움이 되나요?,"If you're using a caching scheme like server = hash(i) mod m, and one server in the cluster drops out, consistent hashing is needed to avoid swamping your servers when all the caches need to rehash their entities.","서버 = hash(i) mod m과 같은 캐싱 방식을 사용하고 있는데 클러스터 내 하나의 서버가 중단되는 경우, 모든 캐시가 엔티티를 재해시해야 할 때 서버를 스윕하지 않으려면 일관된 해싱이 필요합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the relationship between consistent hashing and memcache?,일관된 해싱과 멤캐시의 관계는 무엇인가요?,Consistent hashing can be used with memcache not even knowing about it.  It is interesting to note that it is only the client that needs to implement the consistent hashing algorithm - the memcached server is unchanged.,"일관된 해싱은 멤캐시에 대해 알지도 못하는 상태에서 사용할 수 있습니다. 일관된 해싱 알고리즘을 구현해야 하는 것은 클라이언트뿐이며, 멤캐시된 서버는 변하지 않는다는 점이 흥미롭습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some examples of NoSQL solutions?,NoSQL 솔루션의 몇 가지 예는 무엇인가요?,"Google BigTable
HBase (based on Hadoop)
Hypertable
Amazon DynamoDB
Voldemort
Cassandra
Riak
Redis
CouchDB
MongoDB","Google BigTable
HBase(Hadoop 기반)
Hypertable
Amazon DynamoDB
Voldemort
Cassandra
Riak
Redis
CouchDB
MongoDB",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Paxos an example of?,팍소스는 어떤 예인가요?,quorum-based 2PC (2 phase commit) protocol,쿼럼 기반 2PC(2단계 커밋) 프로토콜,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is MVCC?,MVCC란 무엇인가요?,"Multiversion concurrency control (MCC or MVCC), is a concurrency control method commonly used by database management systems to provide concurrent access to the database and in programming languages to implement transactional memory.","다중 버전 동시성 제어(MCC 또는 MVCC)는 데이터베이스 관리 시스템에서 데이터베이스에 대한 동시 접근을 제공하고, 프로그래밍 언어에서 트랜잭션 메모리를 구현하는 데 일반적으로 사용되는 동시성 제어 방법입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the S in SOLID?,SOLID의 S는 무엇인가요?,The single responsibility principle. There should never be more than one reason for a class to change. We can relate the “reason to change” to “the responsibility of the class”. So each responsibility would be an axis for change.,"단일 책임 원칙. 수업이 변화하는 이유는 한 가지 이상이어서는 안 됩니다. 우리는 ""변화의 이유""를 ""수업의 책임""과 연관시킬 수 있습니다. 따라서 각 책임은 변화의 축이 될 것입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does concurrent.futures do?,continuous.futures는 무엇을 하나요?,"The concurrent.futures modules provides interfaces for running tasks using pools of thread or process workers. The APIs are the same, so applications can switch between threads and processes with minimal changes.",컨커런트 퓨처스 모듈은 스레드 또는 프로세스 워커 풀을 사용하여 작업을 실행할 수 있는 인터페이스를 제공합니다. API는 동일하므로 애플리케이션은 최소한의 변경으로 스레드와 프로세스 간에 전환할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the O in SOLID?,솔리드의 O는 무엇인가요?,"The Open/Closed Principle (OCP) states that the design and writing of the code should be done in a way that new functionality should be added with minimum changes in the existing code. The design should be done in a way to allow the adding of new functionality as new classes, keeping as much as possible existing code unchanged.
""open for extension / closed for modifications""

--

During the 1990s, the open/closed principle became popularly redefined to refer to the use of abstracted interfaces, where the implementations can be changed and multiple implementations could be created and polymorphically substituted for each other.

In contrast to Meyer's usage, this definition advocates inheritance from abstract base classes. Interface specifications can be reused through inheritance but implementation need not be.","개방/폐쇄 원칙(OCP)에 따르면 코드의 설계 및 작성은 기존 코드의 최소한의 변경으로 새로운 기능을 추가하는 방식으로 이루어져야 합니다. 기존 코드를 최대한 변경하지 않고 새로운 기능을 새로운 클래스로 추가할 수 있는 방식으로 설계해야 합니다.
""확장을 위해 열려 있음/수정을 위해 닫힘""

--

1990년대 동안, 개방/폐쇄 원칙은 추상화된 인터페이스를 사용하는 것을 의미하도록 대중적으로 재정의되었습니다. 여기서 구현은 변경될 수 있으며, 여러 구현이 생성되고 서로 다형성적으로 대체될 수 있습니다.

마이어의 사용과 달리, 이 정의는 추상적인 기본 클래스로부터의 상속을 옹호합니다. 인터페이스 사양은 상속을 통해 재사용할 수 있지만 구현할 필요는 없습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is RTTI?,What is RTTI?,run time type identification,실행 시간 유형 식별,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Which SOLID principle is ""Make all Member Variables Private."" helping to enforce?","""모든 구성원 변수를 비공개로 설정""하는 것이 어떤 솔리드 원칙을 시행하는 데 도움이 되나요?",The open/closed principle (OCP),개방/폐쇄 원칙 (OCP),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the L in SOLID?,솔리드의 L은 무엇인가요?,"The Liskov substitution principle (LSP)
We must make sure that the new derived classes just extend without replacing the functionality of old classes. Otherwise the new classes can produce undesired effects when they are used in existing program modules.

Liskov's Substitution Principle states that if a program module is using a Base class, then the reference to the Base class can be replaced with a Derived class without affecting the functionality of the program module.

This principle is just an extension of the Open Close Principle and it means that we must make sure that new derived classes are extending the base classes without changing their behavior.","리스코프 치환 원리 (LSP)
새로운 파생 클래스가 기존 클래스의 기능을 대체하지 않고 확장되도록 해야 합니다. 그렇지 않으면 새로운 클래스가 기존 프로그램 모듈에서 사용될 때 원치 않는 효과를 낼 수 있습니다.

리스코프의 대체 원리에 따르면, 프로그램 모듈이 기본 클래스를 사용하는 경우, 기본 클래스에 대한 참조는 프로그램 모듈의 기능에 영향을 주지 않으면서 파생 클래스로 대체될 수 있습니다.

이 원칙은 오픈 클로즈 원칙의 확장일 뿐이며, 새로운 파생 클래스가 기본 클래스의 동작을 변경하지 않고 확장되도록 해야 한다는 것을 의미합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the I in SOLID?,솔리드의 I는 무엇인가요?,"The Interface Segregation Principle (ISP) states that clients should not be forced to implement interfaces they don't use. Instead of one fat interface many small interfaces are preferred based on groups of methods, each one serving one submodule.","인터페이스 분리 원칙(ISP)은 클라이언트가 사용하지 않는 인터페이스를 강제로 구현해서는 안 된다고 명시하고 있습니다. 하나의 두꺼운 인터페이스 대신, 각 인터페이스는 하나의 하위 모듈에 서비스를 제공하는 메서드 그룹을 기반으로 많은 작은 인터페이스가 선호됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the D in SOLID?,솔리드의 D는 무엇인가요?,"Dependency inversion principle (DIP)
High-level modules should not depend on low-level modules. Both should depend on abstractions.
Abstractions should not depend on details. Details should depend on abstractions.","종속성 반전 원리 (DIP)
고수준 모듈은 저수준 모듈에 의존해서는 안 됩니다. 둘 다 추상화에 의존해야 합니다.
추상화는 세부 사항에 의존해서는 안 됩니다. 세부 사항은 추상화에 의존해야 합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are 3 things CDNs use to ensure availability?,CDN이 가용성을 보장하기 위해 사용하는 3가지 요소는 무엇인가요?,"Local clustering can improve fault-tolerance and scalability. Mirroring (deploying clusters in a few locations) and multihoming (using multiple ISPs to connect to the Internet). 
Clustering, mirroring, and multihoming are common approaches for sites with stringent reliability and scalability needs.","로컬 클러스터링은 내결함성과 확장성을 향상시킬 수 있습니다. 미러링(몇 군데에 클러스터를 배포)과 멀티호밍(여러 ISP를 사용하여 인터넷에 연결). 
클러스터링, 미러링, 멀티호밍은 엄격한 신뢰성과 확장성 요구가 있는 사이트에서 흔히 사용되는 접근 방식입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is hyper-threading?,하이퍼스레딩이란 무엇인가요?,Hyper-threading enables a single processor core to be used for two or more concurrent executions with just a little extra hardware.,"하이퍼스레딩은 하나의 프로세서 코어를 두 개 이상의 동시 실행에 사용할 수 있게 해주며, 약간의 추가 하드웨어만 있으면 가능합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is DMA?,DMA란 무엇인가요?,"DMA (Direct Memory Access) allows devices, with the help of the Northbridge, to store and receive data in RAM directly without the intervention of the CPU.",DMA(직접 메모리 액세스)는 노스브리지의 도움을 받아 장치가 CPU의 개입 없이 RAM에 직접 데이터를 저장하고 수신할 수 있도록 합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does NUMA stand for?,NUMA는 무엇을 의미하나요?,Non-Uniform Memory Architecture,비균일 메모리 아키텍처,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Where are SRAM and DRAM used?,SRAM과 DRAM은 어디에 사용되나요?,SRAMs are used in Caches because of higher speed and DRAMs are used for main memory in a PC because of higher densities.,SRAM은 더 빠른 속도 때문에 캐시에서 사용되고 DRAM은 더 높은 밀도 때문에 PC의 메인 메모리로 사용됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the difference between SRAM and DRAM?,SRAM과 DRAM의 차이점은 무엇인가요?,"DRAM stands for Dynamic Random Access Memory. It is a type of semiconductor memory in which the memory is stored in the form of a charge. Each memory cell in a DRAM is made of a transistor and a capacitor. The data is stored in the capacitor. Capacitors loose charge due to leakage and hence DRAM's are volatile devices. To keep the data in the memory, the device must be regularly refreshed whereas SRAM is static, so it will retain a value as long as power is supplied. SRAM is typically faster than DRAM since it doesn't have refresh cycles. Since each SRAM memory cell is comprised of 6 Transistors unlike a DRAM memory cell, which is comprised of 1 Transistor and 1 Capacitor, the cost per memory cell is far greater in an SRAM compared to a DRAM.",DRAM은 동적 랜덤 액세스 메모리를 의미합니다. DRAM은 메모리가 전하 형태로 저장되는 반도체 메모리의 일종입니다. DRAM의 각 메모리 셀은 트랜지스터와 커패시터로 구성됩니다. 데이터는 커패시터에 저장됩니다. 커패시터는 누설로 인해 전하를 잃기 때문에 DRAM은 휘발성 장치입니다. 데이터를 메모리에 보관하려면 SRAM은 정적인 반면 장치는 정기적으로 새로 고쳐야 하므로 전원이 공급되는 한 값을 유지합니다. SRAM은 일반적으로 새로 고침 주기가 없기 때문에 DRAM보다 빠릅니다. 각 SRAM 메모리 셀은 트랜지스터 1개와 커패시터 1개로 구성된 DRAM 메모리 셀과 달리 6개의 트랜지스터로 구성되어 있기 때문에 메모리 셀당 비용이 DRAM에 비해 SRAM에서 훨씬 더 높습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the difference between a CPU core and a CPU thread?,CPU 코어와 CPU 스레드의 차이점은 무엇인가요?,"The difference between a core and a thread is that separate cores have separate copies of (almost) all the hardware resources. The cores can run completely independently unless they are using the same resources–e.g., the connections to the outside - at the same time. Threads, on the other hand, share almost all of the processor’s resources.
Intel’s implementation of threads has only separate registers for the threads and even that is limited, some registers
are shared.","코어와 스레드의 차이점은 별도의 코어가 거의 모든 하드웨어 리소스의 복사본을 가지고 있다는 점입니다. 코어는 동일한 리소스(예: 외부와의 연결)를 동시에 사용하지 않는 한 완전히 독립적으로 실행될 수 있습니다. 반면 스레드는 프로세서의 거의 모든 리소스를 공유합니다.
인텔의 스레드 구현에는 스레드에 대한 별도의 레지스터만 있으며, 그마저도 일부 레지스터는 제한적입니다
공유합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is SMP?,SMP란 무엇인가요?,"symmetric multi-processor

In symmetric multi-processor (SMP) systems the caches of the CPUs cannot work independently from each other. All processors are supposed to see the same memory content at all times. The maintenance of this uniform view of memory is called “cache coherency”.","대칭 다중 processor

대칭형 다중 프로세서(SMP) 시스템에서는 CPU의 캐시가 서로 독립적으로 작동할 수 없습니다. 모든 프로세서는 항상 동일한 메모리 콘텐츠를 볼 수 있어야 합니다. 이러한 일관된 메모리 뷰를 유지하는 것을 ""캐시 일관성""이라고 합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does a multi-processor CPU maintain cache coherency?,멀티프로세서 CPU는 캐시 일관성을 어떻게 유지하나요?,"- A dirty cache line is not present in any other processor’s cache.
- Clean copies of the same cache line can reside in arbitrarily many caches.","- 다른 프로세서의 캐시에는 더러운 캐시 라인이 없습니다.
- 동일한 캐시 라인의 깨끗한 복사본은 임의의 많은 캐시에 저장될 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Colossus?,거상이란 무엇인가요?,the successor to the Google File System,구글 파일 시스템의 후속작,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Spanner?,스패너란 무엇인가요?,"Spanner is a scalable, globally-distributed database designed, built, and deployed at Google. At the highest level of abstraction, it is a database that shards data across many sets of Paxos state machines in datacenters spread all over the world. Replication is used for global availability and geographic locality; clients automatically failover between replicas. Spanner automatically reshards data across machines as the amount of data or the number of servers changes, and it automatically migrates data across machines (even across datacenters) to balance load and in response to failures. Spanner is designed to scale up to millions of machines across hundreds of datacenters and trillions of database rows.","Spanner는 Google에서 설계, 구축 및 배포되는 확장 가능한 글로벌 분산 데이터베이스입니다. 추상화 수준이 가장 높은 데이터베이스로, 전 세계 데이터 센터의 여러 Paxos 상태 머신 세트에서 데이터를 공유합니다. 복제는 글로벌 가용성과 지리적 지역성을 위해 사용되며, 클라이언트는 복제본 간에 자동으로 페일오버됩니다. Spanner는 데이터 양이나 서버 수가 변경됨에 따라 자동으로 데이터를 여러 머신에서 재공유하고, 데이터 센터 간에도 자동으로 데이터를 마이그레이션하여 부하와 장애에 대한 대응을 균형 있게 조정합니다. Spanner는 수백 개의 데이터 센터와 수조 개의 데이터베이스 행에 걸쳐 최대 수백만 대의 머신을 확장할 수 있도록 설계되었습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Marzullo's algorithm?,마르줄로의 알고리즘은 무엇인가요?,"Marzullo's algorithm, is an agreement algorithm used to select sources for estimating accurate time from a number of noisy time sources. A refined version of it, renamed the ""intersection algorithm"", forms part of the modern Network Time Protocol.","Marzulo의 알고리즘은 여러 노이즈가 있는 시간 소스에서 정확한 시간을 추정하기 위한 소스를 선택하는 데 사용되는 합의 알고리즘입니다. ""교차 알고리즘""으로 이름이 바뀐 이 알고리즘의 정제된 버전은 현대 네트워크 시간 프로토콜의 일부를 형성합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Google File System?,Google 파일 시스템이란 무엇인가요?,"A scalable distributed file system for large distributed data-intensive applications. It provides fault tolerance while running on inexpensive commodity hardware, and it delivers high aggregate performance to a large number of clients.
It deals with multi-GB and TB files by appending to files, as that is the predominant usage pattern of large data files.","대규모 분산 데이터 집약적인 애플리케이션을 위한 확장 가능한 분산 파일 시스템입니다. 저렴한 상용 하드웨어에서 실행되는 동안 내결함성을 제공하며, 많은 클라이언트에게 높은 종합 성능을 제공합니다.
파일에 추가하여 다중 GB 및 TB 파일을 처리하는데, 이는 대용량 데이터 파일의 주요 사용 패턴이기 때문입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is BNF?,BNF란 무엇인가요?,"BNF (Backus Normal Form or Backus–Naur Form) is one of the two main notation techniques for context-free grammars, often used to describe the syntax of languages used in computing, such as computer programming languages, document formats, instruction sets and communication protocols; the other main technique for writing context-free grammars is the van Wijngaarden form.","BNF(Backus Normal Form 또는 Backus–Naur Form)는 문맥 자유 문법을 위한 두 가지 주요 표기 기법 중 하나로, 컴퓨터 프로그래밍 언어, 문서 형식, 명령어 집합 및 통신 프로토콜과 같은 컴퓨팅에서 사용되는 언어의 구문을 설명하는 데 자주 사용됩니다. 문맥 자유 문법을 작성하는 또 다른 주요 기법은 반 빈가르덴 형식입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is MapReduce?,맵리듀스란 무엇인가요?,"MapReduce, developed by Google in 2004, is a programming model and an associated implementation for processing and generating large data sets. Users specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key.",2004년 Google에서 개발한 MapReduce는 대규모 데이터 세트를 처리하고 생성하기 위한 프로그래밍 모델이자 관련 구현입니다. 사용자는 키/값 쌍을 처리하여 중간 키/값 쌍을 생성하는 맵 함수와 동일한 중간 키와 관련된 모든 중간 값을 병합하는 축소 함수를 지정합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a Zipf distribution?,Zipf 분포란 무엇인가요?,"The Zipf distribution, sometimes referred to as the zeta distribution, is a discrete distribution commonly used in linguistics, insurance, and the modeling of rare events.","Zipf 분포는 때때로 제타 분포라고도 불리며, 언어학, 보험, 희귀 사건 모델링에서 흔히 사용되는 이산 분포입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
The memory addresses returned by the malloc function are typically aligned to at least ___ bytes.,malloc 함수에 의해 반환되는 메모리 주소는 일반적으로 최소 ___ 바이트로 정렬됩니다.,8,8,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is AddressSanitizer?,AddressSanitizer란 무엇인가요?,"AddressSanitizer is a fast memory error detector. AddressSanitizer finds out-of-bounds (for heap, stack, and globals) accesses and use-after-free bugs at the cost of 73% slowdown on average and a 3.4x memory size; the tool has no false positives.
AddressSanitizer uses shadow memory to provide accurate and immediate bug detection. The conventional wisdom is that shadow memory either incurs high overhead through multi-level mapping schemes or imposes prohibitive address space requirements by occupying a large contiguous region. Our novel shadow state encoding reduces our shadow space footprint enough that we can use a simple mapping, which can be implemented with low overhead.
It has been included as a compilation option in LLVM since 3.1.","AddressSanitizer는 빠른 메모리 오류 감지기입니다. AddressSanitizer는 힙, 스택, 글로벌의 경우 평균 73%의 속도 저하와 3.4배의 메모리 크기로 아웃오브바운드(out-of-bound) 접근 및 사용 후 버그를 찾아냅니다. 이 도구에는 오탐이 없습니다.
AddressSanitizer는 정확하고 즉각적인 버그 탐지를 제공하기 위해 그림자 메모리를 사용합니다. 일반적인 통념은 그림자 메모리가 다단계 매핑 방식을 통해 높은 오버헤드를 발생시키거나, 인접한 큰 영역을 차지함으로써 엄청난 주소 공간 요구 사항을 부과한다는 것입니다. 우리의 새로운 그림자 상태 인코딩은 간단한 매핑을 사용할 수 있을 만큼 우리의 그림자 공간 발자국을 줄여주며, 이는 낮은 오버헤드로 구현될 수 있습니다.
3.1부터 LLVM의 컴파일 옵션으로 포함되어 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is transitive closure?,전이적 폐쇄란 무엇인가요?,"transitive closure can be thought of as constructing a data structure that makes it possible to answer reachability questions. That is, can one get from node a to node d in one or more hops?","전이적 폐쇄는 도달 가능성 질문에 답할 수 있는 데이터 구조를 구성하는 것으로 생각할 수 있습니다. 즉, 노드 A에서 노드 D로 하나 이상의 홉으로 이동할 수 있을까요?",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is CUDA?,CUDA란 무엇인가요?,"CUDA (Compute Unified Device Architecture) is a parallel computing platform and application programming interface (API) model created by NVIDIA.[1] It allows software developers and software engineers to use a CUDA-enabled graphics processing unit (GPU) for general purpose processing – an approach known as GPGPU. The CUDA platform is a software layer that gives direct access to the GPU's virtual instruction set and parallel computational elements, for the execution of compute kernels.[2]","CUDA(Comput Unified Device Architecture)는 NVIDIA에서 개발한 병렬 컴퓨팅 플랫폼이자 애플리케이션 프로그래밍 인터페이스(API) 모델입니다. [1] 소프트웨어 개발자와 소프트웨어 엔지니어는 범용 처리를 위해 CUDA 지원 그래픽 처리 장치(GPU)를 사용할 수 있으며, 이를 GPGPU라고 합니다. CUDA 플랫폼은 GPU의 가상 명령어 세트와 병렬 계산 요소에 직접 접근하여 컴퓨팅 커널을 실행할 수 있는 소프트웨어 계층입니다. [2]",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Borg?,보그란 무엇인가요?,The first unified container-management system developed at Google. It was built to manage both long-running services and batch jobs.,최초의 통합 컨테이너 관리 시스템은 Google에서 개발되었습니다. 이 시스템은 장기 서비스와 배치 작업을 모두 관리하도록 설계되었습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is MPM?,MPM이란 무엇인가요?,"Within Google, MPM (Midas Package Manager) is used to build and deploy container images. It corresponds to the Docker image registry for Docker containers.",Google 내에서 MPM(Midas Package Manager)은 컨테이너 이미지를 구축하고 배포하는 데 사용됩니다. 이는 Docker 컨테이너의 Docker 이미지 레지스트리에 해당합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are 3 benefits of containers?,용기의 3가지 이점은 무엇인가요?,"1. Containers encapsulate the application environment, abstracting away many details of machines and operating systems from the application developer and the deployment infrastructure.
2. Because well-designed containers and container images are scoped to a single application, managing containers means managing applications rather than machines. This shift of management APIs from machine-oriented to application oriented dramatically improves application deployment and introspection.
3. Decoupling of image and OS makes it possible to provide the same deployment environment in both development and production, which, in turn, improves deployment reliability and speeds up development by reducing inconsistencies and friction.","1. 컨테이너는 애플리케이션 환경을 캡슐화하여 애플리케이션 개발자와 배포 인프라에서 기계와 운영 체제의 많은 세부 사항을 추상화합니다.
2. 잘 설계된 컨테이너와 컨테이너 이미지는 단일 애플리케이션으로 범위가 지정되기 때문에 컨테이너를 관리한다는 것은 기계가 아닌 애플리케이션을 관리하는 것을 의미합니다. 이러한 관리 API의 기계 중심에서 애플리케이션 중심으로 전환하면 애플리케이션 배포와 성찰이 크게 향상됩니다.
3. 이미지와 운영 체제를 분리하면 개발과 생산 모두에서 동일한 배포 환경을 제공할 수 있으며, 이는 결과적으로 배포 신뢰성을 향상시키고 불일치와 마찰을 줄여 개발 속도를 높입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Chubby?,통통이란 무엇인가요?,A distributed lock service (master election) built on Borg.,Borg를 기반으로 구축된 분산 잠금 서비스(마스터 선거).,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does CSP stand for?,CSP는 무엇을 의미하나요?,Communicating Sequential Processes,순차적 프로세스 소통,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Protocol buffers?,프로토콜 버퍼란 무엇인가요?,"Protocol buffers (aka protobuf) are Google's language-neutral, platform-neutral, extensible mechanism for serializing structured data. IDL-based.

You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.","프로토콜 버퍼(일명 프로토부프)는 구조화된 데이터를 직렬화하기 위한 Google의 언어 중립적이고 플랫폼 중립적이며 확장 가능한 메커니즘입니다. IDL 기반입니다.

데이터를 구조화하는 방법을 한 번 정의한 다음, 특수 생성된 소스 코드를 사용하여 다양한 데이터 스트림과 다양한 언어를 사용하여 구조화된 데이터를 쉽게 쓰고 읽을 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Why is using Protocol buffers better than pickling?,프로토콜 버퍼를 사용하는 것이 피클링보다 나은 이유는 무엇인가요?,"Python pickling doesn't deal well with schema evolution, and also doesn't work very well if you need to share data with applications written in C++ or Java.","파이썬 피클링은 스키마 진화를 잘 다루지 않으며, C++ 또는 Java로 작성된 애플리케이션과 데이터를 공유해야 하는 경우에도 잘 작동하지 않습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is gRPC?,What is gRPC?,It’s an open source framework for RPC by Google. gRPC uses HTTP/2 and Google’s own Protobuf to provide a scalable and low latency communication. With gRPC comes a new version of Protobuf (proto3) for high performance binary serialization which includes new features and is easier to use than its predecessors.,이 프레임워크는 Google의 RPC를 위한 오픈 소스입니다. gRPC는 HTTP/2와 Google의 자체 Protobuf를 사용하여 확장 가능하고 낮은 지연 시간의 통신을 제공합니다. gRPC에는 새로운 기능을 포함하고 이전 버전보다 사용하기 쉬운 고성능 바이너리 직렬화를 위한 새로운 버전의 Protobuf(proto3)가 포함되어 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Redis?,Redis란 무엇인가요?,"Redis is an in-memory data structure store, used as database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs and geospatial indexes with radius queries. Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.","Redis는 데이터베이스, 캐시 및 메시지 브로커로 사용되는 in-memory 데이터 구조 저장소입니다. 문자열, 해시, 리스트, 세트, 정렬된 세트, 범위 쿼리, 비트맵, 하이퍼로그 및 반경 쿼리를 포함한 지리 공간 인덱스를 지원합니다. Redis는 복제, Lua 스크립팅, LRU 제거, 트랜잭션 및 다양한 수준의 디스크 내 지속성을 내장하고 있으며, Redis Sentinel을 통해 고가용성을 제공하고 Redis Cluster를 사용한 자동 파티셔닝을 제공합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What commands can be used to make a Redis queue somewhat reliable?,Redis 대기열을 어느 정도 안정적으로 만들기 위해 어떤 명령어를 사용할 수 있나요?,"LPUSH
RPOPLPUSH - pop right, pushing onto another list for processing, atomically,
BRPOPLPUSH - same as above, but blocking
RPOP

Redis is more susceptible to data loss in the event of abrupt termination or power failures.","LPUSH
RPOPLPUSH - 오른쪽으로 튀어오르며, 원자적으로 처리하기 위해 다른 목록으로 이동합니다,
BRPOPLPUSH - 위와 동일하지만 차단
RPOP

Redis는 갑작스러운 종료나 정전이 발생할 경우 데이터 손실에 더 취약합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is RabbitMQ?,RabbitMQ란 무엇인가요?,"RabbitMQ is a messaging broker - an intermediary for messaging.

Messages are routed through exchanges before arriving at queues. RabbitMQ features several built-in exchange types for typical routing logic. For more complex routing you can bind exchanges together or even write your own exchange type as a plugin.

It can be used as a durable queue, work queues, pub/sub, topic handler, and even for rpc.","RabbitMQ는 메시징 중개업체입니다.

메시지는 대기열에 도착하기 전에 교환을 통해 라우팅됩니다. RabbitMQ는 일반적인 라우팅 로직을 위해 여러 가지 내장된 교환 유형을 제공합니다. 더 복잡한 라우팅을 위해 교환을 함께 바인딩하거나 자신만의 교환 유형을 플러그인으로 작성할 수도 있습니다.

내구성이 뛰어난 대기열, 작업 대기열, 펍/서브, 토픽 핸들러, 심지어 rpc용으로도 사용할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is pika?,피카란 무엇인가요?,Pika is a pure-Python implementation of the AMQP 0-9-1 protocol that tries to stay fairly independent of the underlying network support library. Can use with RabbitMQ.,"Pika는 AMQP 0-9-1 프로토콜의 순수 파이썬 구현체로, 기본 네트워크 지원 라이브러리로부터 상당히 독립적으로 유지하려고 합니다. RabbitMQ와 함께 사용할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Celery?,Celery란 무엇인가요?,"Celery is an asynchronous task queue/job queue based on distributed message passing. It is focused on real-time operation, but supports scheduling as well. You use it with a message broker, and it manages the task execution.

The execution units, called tasks, are executed concurrently on a single or more worker servers using multiprocessing, Eventlet, or gevent. Tasks can execute asynchronously (in the background) or synchronously (wait until ready).

The recommended message broker is RabbitMQ, but support for Redis, Beanstalk, MongoDB, CouchDB, and databases (using SQLAlchemy or the Django ORM) is also available.","Celery는 분산 메시지 전달을 기반으로 하는 비동기식 작업 대기열/작업 대기열입니다. 실시간 운영에 중점을 두지만 스케줄링도 지원합니다. 메시지 브로커와 함께 사용하면 작업 실행이 관리됩니다.

작업이라고 하는 실행 단위는 다중 처리, 이벤트렛 또는 게벤트를 사용하여 단일 이상의 작업자 서버에서 동시에 실행됩니다. 작업은 비동기식(배경)으로 실행되거나 동기식으로 실행될 수 있습니다(준비될 때까지 기다립니다).

추천 메시지 브로커는 RabbitMQ이지만, Redis, Beanstalk, MongoDB, CouchDB 및 데이터베이스(SQLchemy 또는 Django ORM 사용)에 대한 지원도 제공됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does amqp stand for?,amqp는 무엇을 의미하나요?,Advanced Message Queuing Protocol,고급 메시지 큐 프로토콜,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is ZeroMQ?,ZeroMQ란 무엇인가요?,"A socket-based system, can be used as a queue, pub/sub, etc.

Carries messages across inproc, IPC, TCP, TIPC, multicast.
Smart patterns like pub-sub, push-pull (pipeline), and router-dealer.","socket 기반 시스템은 대기열, 펍/서브 등으로 사용할 수 있습니다.

inproc, IPC, TCP, TIPC, 멀티캐스트에 메시지를 전달합니다.
펍 서브, 푸시 풀(파이프라인), 라우터 딜러와 같은 스마트 패턴.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is ActiveMQ?,ActiveMQ란 무엇인가요?,Apache ActiveMQ is an open source message broker written in Java.,Apache ActiveMQ는 Java로 작성된 오픈 소스 메시지 브로커입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is IPC?,IPC란 무엇인가요?,"Inter-process communication or interprocess communication (IPC) refers specifically to the mechanisms an operating system provides to allow processes it manages to share data. Typically, applications can use IPC categorized as clients and servers, where the client requests data and the server responds to client requests.","프로세스 간 통신 또는 프로세스 간 통신(IPC)은 운영 체제가 관리하는 프로세스가 데이터를 공유할 수 있도록 제공하는 메커니즘을 말합니다. 일반적으로 애플리케이션은 클라이언트와 서버로 분류된 IPC를 사용할 수 있으며, 클라이언트는 데이터를 요청하고 서버는 클라이언트 요청에 응답합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Kafka?,Kafka란 무엇인가요?,"Apache Kafka is a distributed, partitioned, replicated commit log service. It provides the functionality of a messaging system, but with a unique design.","Apache Kafka는 분산, 분할, 복제된 커밋 로그 서비스입니다. 메시징 시스템의 기능을 제공하지만 독특한 디자인을 가지고 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is MessagePack?,메시지팩이란 무엇인가요?,"MessagePack is an efficient binary serialization format. It lets you exchange data among multiple languages like JSON. But it's faster and smaller. Small integers are encoded into a single byte, and typical short strings require only one extra byte in addition to the strings themselves.

No IDL.","MessagePack은 효율적인 이진 직렬화 형식입니다. JSON과 같은 여러 언어 간에 데이터를 교환할 수 있습니다. 하지만 더 빠르고 작습니다. 작은 정수는 하나의 바이트로 인코딩되며, 일반적인 짧은 문자열은 문자열 자체 외에 하나의 바이트만 추가하면 됩니다.

IDL 없음.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Avro?,아브로란 무엇인가요?,"Apache Avro is a data serialization system. IDL-based.
Rich data structures. 
A compact, fast, binary data format. 
A container file, to store persistent data. 
Remote procedure call (RPC).
Code generation is not required to read or write data files nor to use or implement RPC protocols. Code generation as an optional optimization, only worth implementing for statically typed languages.","Apache Avro는 데이터 직렬화 시스템입니다. IDL 기반입니다.
풍부한 데이터 구조. 
간결하고 빠른 이진 데이터 형식. 
지속적인 데이터를 저장하는 컨테이너 파일입니다. 
원격 절차 호출(RPC).
코드 생성은 데이터 파일을 읽거나 쓰거나 RPC 프로토콜을 사용하거나 구현하는 데 필요하지 않습니다. 코드 생성은 선택적 최적화로, 정적으로 입력된 언어에만 구현할 가치가 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a Bloom filter?,블룸 필터란 무엇인가요?,"A Bloom filter is a data structure used to quickly test membership in a set where the number and size of possible elements would be very large. Too large to keep in memory.
A Bloom filter is a space-efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not, thus a Bloom filter has a 100% recall rate. In other words, a query returns either ""possibly in set"" or ""definitely not in set"". Elements can be added to the set, but not removed (though this can be addressed with a ""counting"" filter). The more elements that are added to the set, the larger the probability of false positives.","블룸 필터는 가능한 요소의 수와 크기가 매우 큰 집합에서 멤버십을 빠르게 테스트하는 데 사용되는 데이터 구조입니다. 메모리에 저장하기에는 너무 큽니다.
블룸 필터는 1970년 버튼 하워드 블룸이 고안한 공간 효율적인 확률 데이터 구조로, 요소가 집합의 구성원인지 여부를 테스트하는 데 사용됩니다. 거짓 양성 일치는 가능하지만 거짓 음성 일치는 불가능하므로 블룸 필터는 100% 재현율을 가집니다. 즉, 쿼리는 ""집합 내에 있을 가능성"" 또는 ""집합 내에 없을 가능성""을 반환합니다. 요소는 집합에 추가할 수 있지만 제거할 수는 없습니다(이는 ""계산"" 필터로 해결할 수 있지만). 집합에 더 많은 요소가 추가될수록 거짓 양성일 확률이 커집니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you easily generate multiple hashes for the same element?,같은 요소에 대해 여러 해시를 쉽게 생성하려면 어떻게 해야 하나요?,"Double hashing. This method gives you as many hashes as you need:
hash(x,m) = (hasha(x) + i * hashb(x)) mod m

In Python:
import mmh3
mmh3.hash64('foo') # two 64 bit signed ints, in a tuple
now you have 2 64-bit hashes. Substituting for i gives you multiple hashes for a Bloom filter.","이중 해싱. 이 방법은 필요한 만큼의 해싱을 제공합니다:
hash(x,m) = (hasha(x) + i * hashb(x)) mod m

파이썬에서:
mmh3 가져오기
mmh3.hash64 ('foo') # 투플로 64비트 서명된 두 개의 인트
이제 64비트 해시 2개가 있습니다. i를 대입하면 블룸 필터에 여러 개의 해시가 생성됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is DFT?,DFT란 무엇인가요?,"Discrete Fourier Transform - converts a finite sequence of equally-spaced samples of a function into an equivalent-length sequence of equally-spaced samples of the discrete-time Fourier transform (DTFT), which is a complex-valued function of frequency.",이산 푸리에 변환 - 함수의 유한한 등간격 샘플 시퀀스를 복소수 값의 주파수 함수인 이산 시간 푸리에 변환(DTFT)의 등간격 샘플 시퀀스로 변환합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is FFTW?,FFTW란 무엇인가요?,"Developed at MIT, it's the Fastest Fourier Transform in the West.",MIT에서 개발된 이 변환은 서양에서 가장 빠른 푸리에 변환입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What data structure allows for insert and delete in constant time?,일정한 시간 내에 삽입하고 삭제할 수 있는 데이터 구조는 무엇인가요?,"An array, indexed by the value stored. Technically a bit vector.",저장된 값으로 인덱싱된 배열. 기술적으로는 비트 벡터입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a cache-oblivious algorithm?,캐시에 의존하지 않는 알고리즘이란 무엇인가요?,"A cache-oblivious algorithm does not mean that the algorithm does not take advantage of the cache; to the contrary, it does so quite effectively. What it means is that the algorithm does not need to know the cache line size; it works effectively for all cache line sizes simultaneously, removing the need to tune or optimize for a given machine.

Optimal cache-oblivious algorithms are known for the Cooley–Tukey FFT algorithm, matrix multiplication, sorting, matrix transposition, and several other problems.","캐시가 불분명한 알고리즘은 알고리즘이 캐시를 활용하지 않는다는 것을 의미하지 않으며, 반대로 매우 효과적으로 캐시를 활용합니다. 즉, 알고리즘은 캐시 라인 크기를 알 필요가 없으며, 모든 캐시 라인 크기에 대해 동시에 효과적으로 작동하여 주어진 머신에 맞게 튜닝하거나 최적화할 필요가 없습니다.

최적의 캐시 명확성 알고리즘은 쿨리-투키 FFT 알고리즘, 행렬 곱셈, 정렬, 행렬 전치 및 기타 여러 문제에 대해 잘 알려져 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you augment a splay tree so you can find how many items are between x and y?,X와 Y 사이의 항목 수를 찾을 수 있도록 플레이 트리를 보강하려면 어떻게 해야 하나요?,"Store size of subtrees at each node. 
Find x, splay to root. Each splay, insert, and delete must maintain size in node.
Find y, and along the way add up the sizes in the left subtrees, and 1 for each visited left-hand node.
Splay y to root to ensure balance.","각 노드에 하위 트리의 크기를 저장합니다. 
x를 찾아서 루트에 재생합니다. 각 재생, 삽입, 삭제는 노드의 크기를 유지해야 합니다.
y를 구하고, 가는 길에 왼쪽 부분 트리의 크기를 더하면, 방문한 왼쪽 노드 각각에 대해 1이 됩니다.
균형을 맞추기 위해 y를 루트로 재생하세요.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In a maximum flow problem, what is the minimum cut?",최대 유량 문제에서 최소 컷은 얼마인가요?,The min cut is the maximum flow through the graph.,최소 컷은 그래프를 통과하는 최대 흐름입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Ford-Fulkerson algorithm?,포드-풀커슨 알고리즘이란 무엇인가요?,"The Ford–Fulkerson method or Ford–Fulkerson algorithm (FFA) is a greedy algorithm that computes the maximum flow in a flow network. It is called a ""method"" instead of an ""algorithm"" as the approach to finding augmenting paths in a residual graph is not fully specified or it is specified in several implementations with different running times. The name ""Ford–Fulkerson"" is often also used for the Edmonds–Karp algorithm, which is a specialization of Ford–Fulkerson.","포드-풀커슨 방법 또는 포드-풀커슨 알고리즘(FFA)은 흐름 네트워크에서 최대 흐름을 계산하는 탐욕 알고리즘입니다. 잔차 그래프에서 증강 경로를 찾는 접근 방식이 완전히 지정되지 않았거나 실행 시간이 다른 여러 구현에서 지정되었기 때문에 ""알고리즘"" 대신 ""방법""이라고 불립니다. ""포드-풀커슨""이라는 이름은 포드-풀커슨의 전문인 에드먼즈-카프 알고리즘에도 자주 사용됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the running time for the disjoint set data structure?,분리된 집합 데이터 구조의 실행 시간은 어떻게 되나요?,"Due to merging smaller disjoint sets into larger ones (called union by rank) (during union) and performing path compression (during find), the amortized time per operation is only O(alpha(n)), where alpha(n) is the inverse of the function and A is the extremely fast-growing Ackermann function. Since alpha(n) is the inverse of this function, alpha(n) is less than 5 for all remotely practical values of n. Thus, the amortized running time per operation is effectively a small constant.

The worst-case for find() is Theta(log u) where u is the number of unions, and no finds have been done to allow for path compression yet.","작은 분리된 집합을 더 큰 집합으로 병합하고(결합 중에는 순위별로 결합이라고 함) 경로 압축을 수행하기 때문에(찾기 중에는), 연산당 상각 시간은 O(alpha(n))뿐이며, 여기서 alpha(n)는 함수의 역수이고 A는 매우 빠르게 성장하는 Ackermann 함수입니다. alpha(n)는 이 함수의 역수이므로, alpha(n)는 모든 원격 실용적인 n 값에 대해 5보다 작습니다. 따라서 연산당 상각된 실행 시간은 사실상 작은 상수입니다.

find()의 최악의 경우는 세타(log u)로, 여기서 u는 조합의 수입니다. 아직 경로 압축을 허용하는 발견은 이루어지지 않았습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In testing, what is an oracle?",테스트에서 오라클이란 무엇인가요?,"Software testers and software engineers can use an oracle as a mechanism for determining whether a test has passed or failed. The use of oracles involves comparing the output(s) of the system under test, for a given test-case input, to the output(s) that the oracle determines that product should have.",소프트웨어 테스터와 소프트웨어 엔지니어는 오라클을 테스트가 통과되었는지 또는 실패했는지를 판단하는 메커니즘으로 사용할 수 있습니다. 오라클의 사용은 주어진 테스트 케이스 입력에 대해 테스트 대상 시스템의 출력을 오라클이 해당 제품이 가져야 한다고 판단하는 출력과 비교하는 것을 포함합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What do you test interfaces with a trust boundary?,신뢰 경계가 있는 인터페이스를 테스트하는 방법은 무엇인가요?,"With lots of different inputs, including random inputs to ensure that the system can handle or appropriately error out, not crash.",시스템이 충돌하지 않고 처리하거나 적절하게 오류를 범할 수 있도록 하는 무작위 입력을 포함하여 다양한 입력을 제공합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What Python flag turns on optimizations and removes assertions from code?,최적화를 켜고 코드에서 어설션을 제거하는 파이썬 플래그는 무엇인가요?,python -O,파이썬 -O,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Why is doing work in a constructor a bad thing?,건설업자가 일을 하는 것이 나쁜 이유는 무엇인가요?,It can make your code harder to test.,코드 테스트가 더 어려워질 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What should be avoided to ensure testing is easier/possible?,테스트가 더 쉬우거나 가능하도록 하기 위해 피해야 할 것은 무엇인가요?,"- static methods and properties
- final keyword
- use of new in methods (use dependency injection)","- 정적 방법 및 속성
- 최종 키워드
- 새로운 방법의 사용(의존성 주입 사용)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is another name for a setter?,세터의 다른 이름은 무엇인가요?,A mutator,돌연변이,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is another name for a getter?,게터의 다른 이름은 무엇인가요?,An accessor.,액세서리.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some guidelines to keep in mind to not violate the dependency inversion principle?,종속성 역전 원칙을 위반하지 않기 위해 염두에 두어야 할 몇 가지 지침은 무엇인가요?,"- No variable should have a concrete class type. An abstract type is better.
- No class should derive from a concrete class.
- No method should override an implemented method of any of its base classes.

These are guidelines and may not be feasible all the time.","- 어떤 변수에도 구체적인 클래스 유형이 없어야 합니다. 추상적인 유형이 더 좋습니다.
- 어떤 클래스도 구체적인 클래스에서 파생되어서는 안 됩니다.
- 어떤 메서드도 기본 클래스의 구현된 메서드를 무시해서는 안 됩니다.

이것들은 지침이며 항상 실행 가능하지 않을 수도 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is another name for O(2^n)?,O(2^n)의 다른 이름은 무엇인가요?,Exponential growth,기하급수적 성장,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is another name for O(n^4)?,O(n^4)의 다른 이름은 무엇인가요?,Quartic growth,사분위수 성장,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does big-O mean? (briefly),big-O는 무슨 뜻인가요? (간단히),"It never gets as big as this.
Growth will never be slower as this.","이렇게 커질 일은 없어요.
성장은 결코 이렇게 느리지 않을 것입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does big-Omega mean? (briefly),Big-O메가는 무슨 뜻인가요? (간단히),"It's at least as big as this.
Growth will never be slower as this.","적어도 이것만큼 커요.
성장은 결코 이렇게 느리지 않을 것입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a trap/exception?,함정/예외란 무엇인가요?,A special instruction that a program performs to interrupt the process and give control to the kernel.,프로그램이 프로세스를 중단하고 커null을 제어하기 위해 수행하는 특별한 명령입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does the scheduler do?,스케줄러는 무엇을 하나요?,Schedulers are special system software which handles process scheduling in various ways. Their main task is to select the jobs to be submitted into the system and to decide which process to run.,스케줄러는 프로세스 스케줄링을 다양한 방식으로 처리하는 특수 시스템 소프트웨어입니다. 이들의 주요 업무는 시스템에 제출할 작업을 선택하고 실행할 프로세스를 결정하는 것입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the 2 hardware modes?,두 가지 하드웨어 모드는 무엇인가요?,kernel mode and user mode,커널 모드 및 사용자 모드,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a PCB and what does it have?,PCB란 무엇이며 무엇을 포함하나요?,Process control block - It holds a complete snapshot of the state of the process.,프로세스 제어 블록 - 프로세스 상태의 전체 snapshot을 저장합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is stored in a TCB?,TCB에는 무엇이 저장되나요?,"registers
program counter
stack counter","레지스터
프로그램 카운터
스택 카운터",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is separate chaining?,별도의 연쇄란 무엇인가요?,"In hash table conflict resolution, each bucket is independent and has some sort of linked list of entries with the same index. The time for hash table operations is the time to find the bucket (which is constant) plus the time for the list operation.

In a good hash table, each bucket has zero or one entries, and sometimes two or three, but rarely more than that. Therefore, structures that are efficient in time and space for these cases are preferred. Structures that are efficient for a fairly large number of entries per bucket are not needed or desirable. If these cases happen often, the hashing function needs to be fixed.","해시 테이블 충돌 해결에서 각 버킷은 독립적이며 동일한 인덱스를 가진 항목들의 연결된 목록을 가지고 있습니다. 해시 테이블 연산의 시간은 버킷을 찾는 시간(일정한)과 목록 연산의 시간을 더한 값입니다.

좋은 해시 테이블에서는 각 버킷에 0개 또는 1개의 항목이 있고 때로는 2~3개이지만 그 이상인 경우는 드뭅니다. 따라서 이러한 경우에 대해 시간과 공간적으로 효율적인 구조가 선호됩니다. 버킷당 상당히 많은 항목에 대해 효율적인 구조는 필요하지도 않고 바람직하지도 않습니다. 이러한 경우가 자주 발생하는 경우 해싱 함수를 수정해야 합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is open addressing?,오픈 어드레싱이란 무엇인가요?,"In hash table conflict resolution, all entry records are stored in the bucket array itself. When a new entry has to be inserted, the buckets are examined, starting with the hashed-to slot and proceeding in some probe sequence, until an unoccupied slot is found. When searching for an entry, the buckets are scanned in the same sequence, until either the target record is found, or an unused array slot is found, which indicates that there is no such key in the table. The name ""open addressing"" refers to the fact that the location (""address"") of the item is not determined by its hash value. (This method is also called closed hashing; it should not be confused with ""open hashing"" or ""closed addressing"" that usually mean separate chaining.)","해시 테이블 충돌 해결에서는 모든 항목 기록이 버킷 배열 자체에 저장됩니다. 새 항목을 삽입해야 할 때, 버킷은 해시된 슬롯부터 시작하여 비어 있는 슬롯이 발견될 때까지 일부 프로브 시퀀스로 진행됩니다. 항목을 검색할 때 버킷은 동일한 시퀀스로 스캔되며, 대상 레코드가 발견되거나 사용되지 않은 배열 슬롯이 발견될 때까지 스캔됩니다. 이는 테이블에 해당 키가 없음을 나타냅니다. ""열린 주소 지정""이라는 이름은 항목의 위치(주소)가 해시 값에 의해 결정되지 않는다는 사실을 의미합니다. (이 방법은 폐쇄 해싱이라고도 하며, 일반적으로 별도의 체인을 의미하는 ""열린 주소 지정""과 혼동해서는 안 됩니다.)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the length of the longest chain in a hash table using separate chaining?,해시 테이블에서 별도의 체인을 사용하는 가장 긴 체인의 길이는 얼마인가요?,"O(1 + alpha) where alpha is the load factor, n/m.","O(1 + 알파) 여기서 알파는 하중 계수, n/m입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Since uniform hashing is difficult to achieve in practice, what is a great alternative?","통일된 해싱은 실제로 달성하기 어렵기 때문에, 어떤 훌륭한 대안이 있을까요?",double hashing,이중 해싱,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you test if a number is odd in bitwise operations?,비트 단위 연산에서 숫자가 홀수인지 어떻게 테스트할 수 있나요?,return (x & 1),return (x & 1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you test if a number is even in bitwise operations?,숫자가 비트 단위 연산에서도 짝수인지 어떻게 테스트할 수 있나요?,return (x & 1) == 0,return (x & 1) == 0,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What order of node and its children are involved in a preorder traversal?,노드와 그 하위 노드는 어떤 순서로 사전 주문 순회에 참여하나요?,"node
leftChild
rightChild","노드
왼쪽 자식
오른쪽 아이",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What order of node and its children are involved in a postorder traversal?,노드와 그 하위 노드는 어떤 순서로 정렬된 후행에 관여하나요?,"leftChild
rightChild
node","왼쪽 자식
오른쪽 아이
노드",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What order of node and its children are involved in an inorder traversal?,노드와 그 하위 노드는 어떤 순서로 순서가 뒤바뀐 탐색에 관여하나요?,"leftChild
node
rightChild","왼쪽 자식
노드
오른쪽 아이",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is another name for a breadth-first search traversal?,너비 우선 탐색 트래블의 다른 이름은 무엇인가요?,Level-order traversal.,수평 이동.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Code: Compute the power set of a set of integers S.,코드: 정수 집합 S의 거듭제곱 집합을 계산합니다.,How?,어떻게?,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the proper name for Endianness?,엔디안니스의 정식 명칭은 무엇인가요?,octet order,옥텟 순서,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Where can octet order (Endianness) problems crop up in files?,옥텟 오더(엔디안니스) 문제는 파일에서 어디에서 발생할 수 있나요?,"In binary files, if you aren't consistent with choosing an order. Files encoded in utf8 or ASCII don't have this issue.",이진 파일에서는 순서를 선택하는 것이 일관되지 않으면 문제가 없습니다. utf8 또는 ASCII로 인코딩된 파일에는 이 문제가 없습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What defines a complete binary tree, and give an example?",완전 이진 트리를 정의하고 예를 들어 설명하자면 무엇인가요?,"The same number of nodes at all levels of the tree, except at leaf level where it fills in left to right. A heap stored as an array is an example.",트리의 모든 레벨에서 동일한 수의 노드가 왼쪽에서 오른쪽으로 채워지는 리프 레벨을 제외하고. 배열로 저장된 힙이 하나의 예입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In a heap, with a 0-based array, what is parent of i?",0 기반 배열이 있는 힙에서 i의 부모는 무엇인가요?,floor((i-1)/2),바닥((i-1)/2),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In a heap, with a 0-based array, what is left child of i?",0 기반 배열이 있는 힙에서 i의 왼쪽 자식은 무엇인가요?,2i + 1,2i + 1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In a heap, with a 0-based array, what is right child of i?",0 기반 배열이 있는 힙에서 i의 오른쪽 자식은 무엇인가요?,2i + 2,2i + 2,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In a heap, with a 1-based array, what is right child of i?",1 기반 배열이 있는 더미에서 i의 오른쪽 자식은 무엇인가요?,2i + 1,2i + 1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In a heap, with a 1-based array, what is left child of i?",1 기반 배열이 있는 더미에서 i의 왼쪽 자식은 무엇인가요?,2i,2i,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In a heap, with a 0-based array, what is parent of i?",0 기반 배열이 있는 힙에서 i의 부모는 무엇인가요?,floor(i/2),바닥(i/2),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the height of a m-ary heap?,마우리 더미의 높이는 얼마인가요?,log base m of n,로그 기저 m(n),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a 2-3-4 tree?,2-3-4 트리란 무엇인가요?,"2–3–4 tree (also called a 2–4 tree) is a self-balancing data structure that is commonly used to implement dictionaries. The numbers mean a tree where every node with children (internal node) has either two, three, or four child nodes:

- 2-node has one data element, and if internal has two child nodes;
- 3-node has two data elements, and if internal has three child nodes;
- 4-node has three data elements, and if internal has four child nodes.","2-3-4 트리(2-4 트리라고도 함)는 사전을 구현하는 데 일반적으로 사용되는 자가 균형 데이터 구조입니다. 이 숫자는 자식이 있는 모든 노드(내부 노드)에 2개, 3개 또는 4개의 자식 노드가 있는 트리를 의미합니다:

- 2노드는 하나의 데이터 요소를 가지고 있으며, 내부에 두 개의 자식 노드가 있는 경우;
- 3노드에는 두 개의 데이터 요소가 있으며, 내부에 세 개의 자식 노드가 있는 경우;
- 4노드에는 세 개의 데이터 요소가 있으며, 내부에는 네 개의 자식 노드가 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the complexity of all operations on a splay tree?,플레이 트리의 모든 연산의 복잡성은 무엇인가요?,"O(log n) on average.
A single operation Theta(n) in the worst case.","평균적으로 O(로그 n).
최악의 경우 단일 작업 세타(n).",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the maximum height of a red-black tree?,빨강-검정 나무의 최대 높이는 얼마인가요?,2 log n,2 로그 n,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In a b-tree, how many children are there per node?",b-트리에서는 노드당 몇 명의 아이들이 있나요?,"root: 1 to 2t-1 keys
non-root: t-1 to 2t-1 keys
t could be up to 100, or more.
There are n keys and n+1 children.
Leaves are all the same level.","루트: 1에서 2t-1 키
non-root: t-1 to 2t-1 keys
t는 최대 100개 또는 그 이상일 수 있습니다.
n개의 키와 n+1명의 아이들이 있습니다.
나뭇잎은 모두 같은 높이입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does the max degree of a b-tree depend on?,b-트리의 최대 차수는 무엇에 따라 달라지나요?,"The number of items being stored, and page size based on disk characteristics.",저장되는 항목의 수와 디스크 특성에 따른 페이지 크기.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
A b-tree's data is organized to correspond with what?,b-트리의 데이터는 무엇과 일치하도록 구성되어 있나요?,Pages on disk.,디스크의 페이지.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Give an example of how a b-tree might be organized.,b-트리가 어떻게 구성될 수 있는지 예를 들어보세요.,"1024 children per node.
Store root in memory.
3 nodes accessed gets us 1024^3 disk pages.
4 nodes accessed gets us 1024^4 disk pages.","노드당 1024명의 어린이.
루트를 메모리에 저장하세요.
3개의 노드에 액세스하면 1024^3개의 디스크 페이지가 표시됩니다.
4개의 노드에 액세스하면 1024^4개의 디스크 페이지가 표시됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"On descending a b-tree, what's the rule?",b-트리를 내려갈 때 규칙은 무엇인가요?,Never step into a minimal node.,절대 최소 노드에 들어가지 마세요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"On insertion in a b-tree, what's the rule?",b-트리에 삽입할 때 규칙은 무엇인가요?,Never step into a full node.,절대로 전체 노드에 들어가지 마세요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many nodes of k leaves are in a compressed trie (big-O)?,압축 트리(big-O)에는 몇 개의 k개의 잎 노드가 있나요?,O(k) nodes with k leaves due to compression.,압축으로 인해 k개의 잎이 있는 O(k) 노드.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a suffix tree?,접미사 트리란 무엇인가요?,"A suffix tree is a compressed trie containing all the suffixes of the given text as their keys and positions in the text as their values. Suffix trees allow particularly fast implementations of many important string operations.

The construction of such a tree for the string S takes time and space linear in the length of S. Once constructed, several operations can be performed quickly, for instance locating a substring in S, locating a substring if a certain number of mistakes are allowed, locating matches for a regular expression pattern etc. Suffix trees also provide one of the first linear-time solutions for the longest common substring problem. These speedups come at a cost: storing a string's suffix tree typically requires significantly more space than storing the string itself.","접미사 트리는 주어진 텍스트의 모든 접미사를 키로, 텍스트 내 위치를 값으로 포함하는 압축 트리입니다. 접미사 트리는 많은 중요한 문자열 작업을 특히 빠르게 구현할 수 있게 해줍니다.

문자열 S의 이러한 트리를 구성하는 데는 S의 길이에 따라 선형적으로 시간과 공간이 소요됩니다. 일단 구성된 후, 여러 작업을 빠르게 수행할 수 있습니다. 예를 들어, S에서 부분 문자열을 찾기, 특정 개수의 실수가 허용되면 부분 문자열을 찾기, 정규 표현식 패턴과 일치하는 부분 문자열을 찾기 등이 있습니다. 접미사 트리는 또한 가장 긴 일반적인 부분 문자열 문제에 대한 최초의 선형 시간 솔루션 중 하나를 제공합니다. 이러한 속도 향상에는 대가가 따릅니다: 문자열의 접미사 트리를 저장하는 것은 일반적으로 문자열 자체를 저장하는 것보다 훨씬 더 많은 공간을 필요로 합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In brief, how does selection sort work?","간단히 말해서, Selection Sort은 어떻게 작동하나요?","Find the minimum item on each pass, past the previous minimum, and swap it into the leftmost position after the previous minimum.","각 패스에서 이전 최소값을 지나 최소값 항목을 찾고, 이전 최소값 다음으로 가장 왼쪽 위치로 전환하세요.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
When can insertion sort run in n log n time?,Insertion Sort은 언제 n 로그 n 시간 내에 실행될 수 있나요?,Load into a binary search tree. Then inorder traversal.,Binary Search Tree에 로드합니다. 그런 다음 순서대로 이동합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you speed up selection sort with a heap?,힙으로 Selection Sort 속도를 높이려면 어떻게 해야 하나요?,Replace the unsorted portion with a min-heap. Gives O(log n) removal. Makes n log n overall.,정렬되지 않은 부분을 미니 힙으로 교체하세요. O(log n) 제거를 제공합니다. 전체적으로 n개의 로그 n을 만듭니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What data structure is well suited for a heap sort and which is bad?,Heap Sort에 적합한 데이터 구조와 나쁜 구조는 무엇인가요?,"Array - good
Linked list - clumsy","배열 - 양호
연결된 목록 - 서투름",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What data structure is well suited for a merge sort and which is just okay?,"Merge Sort에 적합한 데이터 구조는 무엇이며, 어떤 것이 괜찮을까요?","Linked list - a natural
Array does not allow for in-place","연결된 목록 - 자연스러운 목록
배열은 제자리에서 사용할 수 없습니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you optimize finding a pivot when the segment to pivot is large (not random choice)?,피벗할 세그먼트가 큰 경우(무작위 선택이 아닌) 피벗을 찾는 것을 최적화하려면 어떻게 해야 하나요?,Choose a median of three.,세 개의 중앙값을 선택하세요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is counting sort?,카운팅이란 무엇인가요?,"Counting sort is an algorithm for sorting a collection of objects according to keys that are small integers; that is, it is an integer sorting algorithm. It operates by counting the number of objects that have each distinct key value, and using arithmetic on those counts to determine the positions of each key value in the output sequence. Its running time is linear in the number of items and the difference between the maximum and minimum key values, so it is only suitable for direct use in situations where the variation in keys is not significantly greater than the number of items. However, it is often used as a subroutine in another sorting algorithm, radix sort, that can handle larger keys more efficiently.","카운팅 정렬은 작은 정수인 키에 따라 객체 모음을 정렬하는 알고리즘, 즉 정수 정렬 알고리즘입니다. 각 키 값이 서로 다른 객체의 수를 세고, 해당 개수에 대한 산술을 사용하여 출력 시퀀스에서 각 키 값의 위치를 결정하는 방식으로 작동합니다. 실행 시간은 항목 수와 최대 키 값과 최소 키 값의 차이가 선형적이므로 키의 변동이 항목 수보다 크게 크지 않은 상황에서만 직접 사용하기에 적합합니다. 그러나 더 큰 키를 더 효율적으로 처리할 수 있는 또 다른 정렬 알고리즘인 래딕스 정렬에서는 하위 루틴으로 자주 사용됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is radix sort?,래딕스 종류란 무엇인가요?,"Radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value. 
Two classifications of radix sorts are least significant digit (LSD) radix sorts and most significant digit (MSD) radix sorts. LSD radix sorts process the integer representations starting from the least digit and move towards the most significant digit. MSD radix sorts work the other way around.","Radix 정렬은 동일한 중요한 위치와 값을 공유하는 개별 숫자로 키를 그룹화하여 정수 키로 데이터를 정렬하는 비교 불가능한 정수 정렬 알고리즘입니다. 
래딕스 정렬의 두 가지 분류는 최소 유효 자릿수(LSD) 래딕스 정렬과 최대 유효 자릿수(MSD) 래딕스 정렬입니다. LSD 래딕스 정렬은 정수 표현을 최소 자릿수에서 시작하여 가장 유효한 자릿수로 이동하는 과정을 처리합니다. MSD 래딕스 정렬은 그 반대로 작동합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the counting sort running time?,카운트 정렬 실행 시간은 어떻게 되나요?,"O(q + n) where q is the number of unique items. If q is in O(n), then linear time.",O(q + n) 여기서 q는 고유 항목의 수입니다. q가 O(n)에 있다면 선형 시간입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What radix is most natural to use?,가장 자연스럽게 사용할 수 있는 라디칼은 무엇인가요?,A power of 2 radix.,2 라디칼의 거듭제곱.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How would radix sort work for IEEE floating point numbers?,IEEE 부동 소수점 번호에 대해 라디우스 정렬은 어떻게 작동하나요?,"Flip all bits for negative numbers, do sort, then flip back.",모든 비트를 음수로 바꾸고 정렬한 다음 다시 뒤집습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How to choose q for radix sort?,래딕스 정렬을 위해 q를 선택하는 방법은 무엇인가요?,"Choose q within a power of 2 of n. Ensures the number of passes is small. Best rule is n rounded down to the next power of 2.
To save memory, round sqrt(n) down to the next power of 2. Twice as many passes.","2의 거듭제곱 n 내에서 q를 선택합니다. 통과 횟수가 적을 것을 보장합니다. 가장 좋은 규칙은 다음 2의 거듭제곱 n으로 반올림하는 것입니다.
메모리를 절약하려면 제곱근(n)을 2의 다음 거듭제곱으로 반올림합니다. 패스 수는 두 배입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What operations are a treap optimized for?,트랩은 어떤 작업에 최적화되어 있나요?,"- union
- intersection
- difference","- 연합
- 교차점
- 차이",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Day–Stout–Warren (DSW) algorithm?,데이-스타우트-워런(DSW) 알고리즘은 무엇인가요?,"The Day–Stout–Warren (DSW) algorithm is a method for efficiently balancing binary search trees — that is, decreasing their height to O(log n) nodes, where n is the total number of nodes. Unlike a self-balancing binary search tree, it does not do this incrementally during each operation, but periodically, so that its cost can be amortized over many operations.","Day–Stout–Warren (DSW) 알고리즘은 Binary Search Tree의 효율적인 균형을 맞추기 위한 방법입니다. 즉, Binary Search Tree의 높이를 O(log n) 노드로 줄이는 것입니다. 여기서 n은 총 노드 수입니다. 자체 균형 Binary Search Tree와 달리, 이는 각 작업 동안 점진적으로 수행되는 것이 아니라 주기적으로 수행되므로 많은 작업에서 비용을 상각할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the insertion sort algorithm?,Insertion Sort 알고리즘이란 무엇인가요?,"for (i = 0; i < n; ++i) {
    j = i;
    while (j > 0 && a[j - 1] > a[j]) {
        swap(a, j, j - 1);
        j -= 1;
    }
}","for (i = 0; i < n; ++i) {
    j = i;
    while (j > 0 && a[j - 1] > a[j]) {
        swap(a, j, j - 1);
        j -= 1;
    }
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is radix sort stable?,래딕스는 안정적인가요?,Yes.,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the algorithmic time complexity of radix sort?,래딕스 정렬의 알고리즘 time complexity는 무엇인가요?,O(digits),O(숫자),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Give the code for selection sort.,Selection Sort 코드를 입력하세요.,"for (i = 0; i < n; ++i) {
    min_index = i:
    for (j = i; j < n; ++j) {
        if (a[j] < a[min_index]) {
            min_index = j;
        }
    }
    swap(a, i, min_index)
}","for (i = 0; i < n; ++i) {
    min_index = i:
    for (j = i; j < n; ++j) {
        if (a[j] < a[min_index]) {
            min_index = j;
        }
    }
    swap(a, i, min_index)
}",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
All comparison-based sorting is bounded by what complexity?,모든 비교 기반 정렬은 어떤 복잡성에 의해 제한되나요?,Omega(n log n),오메가(n 로그 n),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What do you call a linear ordering of a directed graph of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering?",정점 u에서 정점 v로 향하는 모든 방향의 간선 uv에 대해 순서대로 u가 v보다 먼저 오는 방향 그래프의 선형 순서를 뭐라고 부르나요?,Topological sort,위상 정렬,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a good method for performing a topological sort?,위상 정렬을 수행하는 데 좋은 방법은 무엇인가요?,"1. Calculate in-degree for each node. O(v + e)
2. Go through 0s, add to queue.
3. For each item in queue, look at each connection, and decrement in-degree of each, if they got to 0, add to queue, repeat.","1. 각 노드에 대한 차수 내 계산. O(v + e)
2. 0을 통과하여 대기열에 추가하세요.
3. 대기열에 있는 각 항목에 대해 각 연결을 살펴보고, 각 항목의 차수가 0에 도달하면 대기열에 추가하고 반복합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many possible trees are there that span all nodes in a graph?,그래프의 모든 노드에 걸쳐 있는 가능한 트리는 몇 개인가요?,4^n,4^n,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Prim's algorithm?,Prim의 알고리즘은 무엇인가요?,"def prim(self):
    """"""
    Returns a dictionary of parents of vertices in a minimum spanning tree
    :rtype: dict
    """"""
    s = set()
    q = queue.PriorityQueue()
    parents = {}
    start_weight = float(""inf"")
    weights = {}  # since we can't peek into queue

    for i in self.get_vertex():
        weight = start_weight
        if i == 0:
            q.put(([0, i]))
        weights[i] = weight
        parents[i] = None

    while not q.empty():
        v_tuple = q.get()
        vertex = v_tuple[1]

        s.add(vertex)

        for u in self.get_neighbor(vertex):
            if u.vertex not in s:
                if u.weight < weights[u.vertex]:
                    parents[u.vertex] = vertex
                    weights[u.vertex] = u.weight
                    q.put(([u.weight, u.vertex]))

    return parents","def prim(self):
    """"""
    Returns a dictionary of parents of vertices in a minimum spanning tree
    :rtype: dict
    """"""
    s = set()
    q = queue.PriorityQueue()
    parents = {}
    start_weight = float(""inf"")
    weights = {}  # since we can't peek into queue

    for i in self.get_vertex():
        weight = start_weight
        if i == 0:
            q.put(([0, i]))
        weights[i] = weight
        parents[i] = None

    while not q.empty():
        v_tuple = q.get()
        vertex = v_tuple[1]

        s.add(vertex)

        for u in self.get_neighbor(vertex):
            if u.vertex not in s:
                if u.weight < weights[u.vertex]:
                    parents[u.vertex] = vertex
                    weights[u.vertex] = u.weight
                    q.put(([u.weight, u.vertex]))

    return parents",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the time complexity of Prim's algorithm on an adjacency matrix?,인접 행렬에서 Prim 알고리즘의 time complexity는 얼마인가요?,O(v^2),O(v^2),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the time complexity of Prim's algorithm on an adjacency list and a binary heap?,인접 목록과 이진 힙에서 Prim 알고리즘의 time complexity는 얼마인가요?,"O(e log v)
derived from:
O((e + v) log v)","O(로그 v)
다음에서 파생됨:
O((e + v) log v)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the time complexity of Prim's algorithm on an adjacency list and a Fibonacci heap?,인접 목록과 피보나치 힙에서 Prim 알고리즘의 time complexity는 얼마인가요?,O(e + v log v),O(e + v log v),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the pseudocode Kruskal's algorithm?,의사 코드 크루스칼의 알고리즘은 무엇인가요?,"KRUSKAL(G):
A = ∅
foreach v ∈ G.V:
   MAKE-SET(v)
foreach (u, v) in G.E ordered by weight(u, v), increasing:
   if FIND-SET(u) ≠ FIND-SET(v):
      A = A ∪ {(u, v)}
      UNION(u, v)
return A","KRUSKAL(G):
A = ∅
foreach v ∈ G.V:
   MAKE-SET(v)
foreach (u, v) in G.E ordered by weight(u, v), increasing:
   if FIND-SET(u) ≠ FIND-SET(v):
      A = A ∪ {(u, v)}
      UNION(u, v)
return A",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the time complexity of Kruskal's algorithm?,크루스칼 알고리즘의 time complexity는 얼마인가요?,"O(E log V)
or
O(e log e + e α(v) + v)","O(E 로그 V)
또는
O(e log e + e α(v) + v)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Kruskal's algorithm?,크루스칼의 알고리즘은 무엇인가요?,"Kruskal's algorithm is a minimum-spanning-tree algorithm which finds an edge of the least possible weight that connects any two trees in the forest. It is a greedy algorithm in graph theory as it finds a minimum spanning tree for a connected weighted graph adding increasing cost arcs at each step. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. If the graph is not connected, then it finds a minimum spanning forest (a minimum spanning tree for each connected component).","크루스칼의 알고리즘은 최소 스패닝 트리 알고리즘으로, 숲의 두 트리를 연결하는 최소 가중치의 엣지를 찾습니다. 이 알고리즘은 연결된 가중치 그래프에 대해 각 단계에서 비용 증가 호를 추가하는 최소 스패닝 트리를 찾기 때문에 그래프 이론에서 탐욕스러운 알고리즘입니다. 즉, 트리의 모든 엣지의 총 가중치가 최소화되는 모든 정점을 포함하는 트리를 구성하는 엣지의 하위 집합을 찾습니다. 그래프가 연결되지 않은 경우 최소 스패닝 포REST(연결된 각 구성 요소에 대한 최소 스패닝 트리)를 찾습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you find the number of connected components?,연결된 구성 요소의 수를 어떻게 찾을 수 있나요?,"For each node:
  if node not yet visited, increment component count and do DFS.","각 노드에 대해:
  노드가 아직 방문하지 않은 경우 구성 요소 수를 늘리고 DFS를 수행합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you get a topological sort with DFS?,DFS를 사용하여 위상 정렬을 어떻게 얻을 수 있나요?,"Do a DFS, and when each node is being marked as complete, add node to a list.
Reverse the list.","DFS를 수행하고 각 노드가 완료로 표시되면 노드를 목록에 추가합니다.
목록을 뒤집으세요.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you check for a cycle with DFS?,DFS와의 주기를 어떻게 확인할 수 있나요?,"for each neighbor node:
if not marked as visited (and is not parent) then DFS
else it's a cycle","각 이웃 노드에 대해:
방문한 것으로 표시되지 않고 부모가 아닌 경우 DFS
그렇지 않으면 주기입니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you get the strongly connected components of a graph?,그래프의 강하게 연결된 구성 요소를 어떻게 얻을 수 있나요?,"1. DFS - calculate the finish times for each node
2. Reverse the edges in the graph
3. Call DFS on nodes in reverse graph in reverse order of finishing times.","1. DFS - 각 노드의 완료 시간 계산
2. 그래프의 가장자리를 뒤집습니다
3. 역 그래프의 노드에서 완료 시간의 역순으로 DFS를 호출합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How do you reverse the edges in a directed graph represented as an adjacency matrix?,인접 행렬로 표시된 방향 그래프의 가장자리를 어떻게 되돌리나요?,"Transpose the matrix, so [i, j] becomes [j, i]","행렬을 전치하면 [i, j]가 [j, i]가 됩니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you find the shortest path on a DAG?,DAG에서 가장 짧은 경로를 어떻게 찾을 수 있나요?,"1. Topological sort
2. follow the topological sort, relaxing edges","1. 위상 정렬
2. 위상 정렬을 따르고 편안한 가장자리를 유지합니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How to find the longest path on a weighted DAG?,가중 DAG에서 가장 긴 경로를 찾는 방법은 무엇인가요?,"1. Set all edges to their negative weight.
2. Topological sort 
3. follow the topological sort, relaxing edges","1. 모든 모서리를 음의 무게로 설정하세요.
2. 위상 정렬 
3. 위상 정렬을 따르고 편안한 가장자리를 유지합니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the diameter of a graph?,그래프의 지름은 얼마인가요?,"The shortest path of the farthest nodes. That is, it is the greatest distance between any pair of vertices. To find the diameter of a graph, first find the shortest path between each pair of vertices. The greatest length of any of these paths is the diameter of the graph.","가장 먼 노드 중 가장 짧은 경로입니다. 즉, 정점 쌍 사이의 가장 큰 거리입니다. 그래프의 지름을 구하려면 먼저 각 정점 쌍 사이의 최단 경로를 구합니다. 이러한 경로 중 가장 long long는 그래프의 지름입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Under what condition can you not use Djikstra's algorithm?,어떤 조건에서 지크스트라의 알고리즘을 사용할 수 없나요?,When the graph contains a negative edge. Can cause a cycle that will be traversed infinitely.,그래프에 음의 간선이 포함된 경우. 무한히 순환하는 사이클을 일으킬 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In plain words, how does Kruskal's algorithm work?","간단히 말해서, 크루스칼의 알고리즘은 어떻게 작동하나요?","1. Create a set T and list for result
2. Make a list of all edges in G
3. Sort edges by weight, from least to greatest.
4. Iterate edges in sorted order.
5. For each edge, if u and v are not in T, add u and v to T, and add edge to result list.","1. 집합 T를 생성하고 결과를 위한 목록 만들기
2. G의 모든 간선 목록 만들기
3. 가장자리를 최소부터 최대까지 무게별로 정렬합니다.
4. 모서리를 정렬된 순서대로 반복합니다.
5. 각 간선마다 u와 v가 T에 속하지 않으면 u와 v를 T에 더하고, 결과 목록에 간선을 추가하세요.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What can most dynamic programming problems be expressed as?,가장 동적인 프로그래밍 문제는 무엇으로 표현할 수 있나요?,Finding the shortest path in a DAG. Formulating it this way ensures you can solve it in linear or linearithmic time.,DAG에서 최단 경로를 찾습니다. 이렇게 공식화하면 선형 또는 선형 산술 시간 내에 해결할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What metric can you use to measure the badness of a line in a text justification problem?,텍스트 정당화 문제에서 선의 불량성을 측정하는 데 사용할 수 있는 지표는 무엇인가요?,"(page width - text width)^3
Minimize the sum of the badness of the lines.","(페이지 너비 - 텍스트 너비)^3
선의 심각도의 합을 최소화하세요.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you tell if a graph is 2-colorable?,그래프가 2색인지 어떻게 알 수 있나요?,If it's bipartite. All trees are bipartite.,이분법적이라면. 모든 나무는 이분법적입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is it called when you have too many base cases in your recursion?,재귀 중에 베이스 케이스가 너무 많을 때 그것을 뭐라고 부르나요?,arm's length recursion,팔 길이 재귀,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the base case of a recursion?,재귀의 기본 사례는 무엇인가요?,The code required to give the solution to the smallest subproblem.,가장 작은 하위 문제에 대한 해결책을 제시하는 데 필요한 코드입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the formula for n choose k?,n 선택 k의 공식은 무엇인가요?,n! / k!(n - k)!,n! / k!(n - k)!,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the general outline of a backtracking algorithm?,역추적 알고리즘의 일반적인 개요는 무엇인가요?,"def solve(conf):
    if (no more choices):
        return conf
    
    choices = get_available_choices

    for choice in choices:
        c = pick one
        if solve(conf using c):
            return true
        unmake choice c

    return false","def solve(conf):
    if (no more choices):
        return conf
    
    choices = get_available_choices

    for choice in choices:
        c = pick one
        if solve(conf using c):
            return true
        unmake choice c

    return false",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What kinds of problems is dynamic programming best suited for?,동적 프로그래밍은 어떤 종류의 문제에 가장 적합한가요?,"- optimizing left to right sequences (strings, tree nodes as array, permutations)
- search all possibilities while storing results to avoid recomputing","- 왼쪽에서 오른쪽 시퀀스 최적화(strings, 배열로서의 트리 노드, 순열)
- 결과를 저장하면서 모든 가능성을 검색하여 다시 계산하지 않도록 합니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is n choose n?,n 선택이란 무엇인가요?,1,1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is n choose 1?,n 선택 1이란 무엇인가요?,n,n,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is n choose 0?,n 선택 0이란 무엇인가요?,1,1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Floyd-Warshall algorithm?,플로이드-워샬 알고리즘이란 무엇인가요?,The Floyd–Warshall algorithm is a dynamic programming algorithm for finding shortest paths in a weighted graph with positive or negative edge weights (but with no negative cycles).,플로이드-워샬 알고리즘은 양의 또는 음의 에지 가중치를 가진 가중 그래프에서 최단 경로를 찾기 위한 동적 프로그래밍 알고리즘입니다(음의 사이클은 없지만).,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Bayes' rule (formula)?,베이즈의 규칙(공식)은 무엇인가요?,P(A|B) = (P(B|A) * P(A)) / P(B),P(A|B) = (P(B|A) * P(A)) / P(B),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How would you calculate P(A|B)?,P(A|B)를 어떻게 계산하시겠습니까?,P(A and B) / P(B),P(A and B) / P(B),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How would you calculate P(A and B)?,P(A와 B)를 어떻게 계산하시겠습니까?,P(A) * P(B),P(A) * P(B),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How would you calculate P(A or B)?,P(A 또는 B)를 어떻게 계산하시겠습니까?,P(A) + P(B) - P(AB),P(A) + P(B) - P(AB),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What's another way to write P(A and B)?,P(A와 B)를 쓰는 또 다른 방법은 무엇인가요?,P(AB),P(AB),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a Markov chain?,마르코프 연쇄란 무엇인가요?,A Markov chain consists of states linked by transitions labeled with probabilities. The states do not have to be words. They could represent any state.,마르코프 연쇄는 확률로 표시된 전이로 연결된 상태로 구성됩니다. 상태는 반드시 단어일 필요는 없습니다. 어떤 상태든 나타낼 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Write a function that computes the sqrt(n) using binary search.,이진 검색을 사용하여 제곱근(n)을 계산하는 함수를 작성하세요.,How?,어떻게?,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is P(A|A)?,What is P(A|A)?,1,1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
At how many items should you expect a collision when hashing among n buckets?,n개의 버킷을 해싱할 때 충돌이 예상되는 항목은 몇 개인가요?,At sqrt(n) the probability is 1/2,sqrt(n)에서 확률은 1/2입니다,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is n/n^2?,What is n/n^2?,1/n,1/n,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the P( ! B ) ?,P(! B )란 무엇인가요?,1 - P(B),1 - P(B),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the probability of at least 1 H in 3 flips?,3번의 플립 중 최소 1H의 확률은 얼마인가요?,1 - P(TTT) = 1 - 1/8 = 7/8,1 - P(TTT) = 1 - 1/8 = 7/8,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"With a fair coin, what is the probability of getting exactly 1 H in 4 flips?",공정한 동전을 사용하면 4번의 동전 던지기에서 정확히 1H를 얻을 확률은 얼마인가요?,P(HTTT) + P(THTT) + P(TTHT) + P(TTTH) = 1/16 + 1/16 + 1/16 + 1/16 = 4/16 = 1/4,P(HTTT) + P(THTT) + P(TTHT) + P(TTTH) = 1/16 + 1/16 + 1/16 + 1/16 = 4/16 = 1/4,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"With a fair coin, what is the probability of getting exactly k H in n flips?",공정한 동전을 사용하면 n번의 플립에서 정확히 k H를 얻을 확률은 얼마인가요?,(n choose k)/2^n,(n choose k)/2^n,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In what domain are most decision problems (P, Exp, R, outside R)?","대부분의 의사 결정 문제(P, Exp, R, 외부 R)는 어떤 영역에 있나요?",Outside R - they are uncomputable,외부 R - 계산할 수 없습니다,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does it mean when a problem is NP-Hard?,문제가 NP-난해하다는 것은 무엇을 의미하나요?,It is as hard as any other problem in NP. A problem X is NP-Hard if every problem Y in NP-Hard reduces to X.,NP의 다른 어떤 문제만큼이나 어렵습니다. NP-Hard의 모든 문제 Y가 X로 축소되면 문제 X는 NP-Hard입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does it mean to reduce a problem A to a problem B?,문제 A를 문제 B로 축소한다는 것은 무엇을 의미하나요?,"Converting the input to algorithm A into input into algorithm B, providing an answer for A.",입력을 알고리즘 A로 변환하여 알고리즘 B로 변환하면 A에 대한 답을 얻을 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Is ""3-D matching"" NP-Complete?","""3D 매칭""은 NP-완전인가요?",Yes,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Is ""triple coloring a graph"" NP-Complete?","""트리플 컬러링은 그래프"" NP-완전인가요?",Yes,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Is ""two coloring a graph"" NP-Complete?","""두 가지 색칠은 그래프""는 NP-완전인가요?",No,아니요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Is ""subset sum"" NP-Complete?","""부분 집합 합""이 NP-완전인가요?",Yes,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Is ""bin packing"" NP-Complete?","""빈 패킹""은 NP-완전인가요?",Yes,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Is ""vertex cover"" NP-Complete?","""정점 덮개""는 NP-완전인가요?",Yes,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Is ""set cover"" NP-Complete?","""세트 커버""는 NP-완전인가요?",Yes,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Name some NP-Complete problems.,NP-완전 문제 몇 가지를 말해보세요.,"- tsp
- knapsack problem
- satisfiability
- 3D matching
- tricoloring
- subset sum
- rectangle packing
- bin packing
- vertex cover
- set cover","- tsp
- 배낭 문제
- 만족 가능성
- 3D 매칭
- 삼색화
- 부분 합
- 직사각형 포장
- 쓰레기통 포장
- 정점 덮개
- 표지 설정",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is one way of doing approximate traveling salesman?,대략적인 여행 세일즈맨을 하는 한 가지 방법은 무엇인가요?,"Select a vertex as root.
Build a MST.
Do a preorder traversal, store nodes in H.
Return H (a Hamiltonian cycle)","정점을 루트로 선택하세요.
MST를 구축하세요.
사전 주문 트래버스를 수행하고 노드를 H에 저장합니다.
반환 H (해밀토니안 사이클)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What suffers from GC pauses?,GC 멈춤으로 고통받는 것은 무엇인가요?,"- long-running processes like servers
- real-time applications like video processing","- 서버와 같은 장기적인 프로세스
- 비디오 처리와 같은 실시간 애플리케이션",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can an LRU cache be implemented with a linked list?,링크된 목록으로 LRU 캐시를 구현하려면 어떻게 해야 하나요?,"When an item is accessed, it moves to the head of the list.
The trailing items can be overwritten with new items, or removed.","항목에 접근하면 목록의 맨 앞으로 이동합니다.
후행 항목은 새 항목으로 덮어쓰거나 제거할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How often are DRAM cells data rewritten?,DRAM 셀 데이터는 얼마나 자주 다시 작성되나요?,Every 10ms.,매 10ms마다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does Skylake architecture look like?,스카이레이크 건축은 어떤 모습인가요?,"Skylake: 

L1 Data cache = 32 KB, 64 B/line, 8-WAY. 64 cache lines per cache way
L1 Instruction cache = 32 KB, 64 B/line, 8-WAY. 64 cache lines per cache way
L2 cache = 256 KB, 64 B/line, 4-WAY
L3 cache = 8 MB, 64 B/line, 16-WAY","스카이레이크: 

L1 데이터 캐시 = 32KB, 64 B/라인, 8-WAY. 캐시 웨이당 64개의 캐시 라인
L1 명령어 캐시 = 32KB, 64 B/라인, 8-WAY. 캐시 웨이당 64개의 캐시 라인
L2 캐시 = 256KB, 64B/라인, 4-WAY
L3 캐시 = 8MB, 64B/라인, 16-WAY",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a TLB?,TLB란 무엇인가요?,"A translation lookaside buffer (TLB) is a cache that memory management hardware uses to improve virtual address translation speed. The majority of desktop, laptop, and server processors includes one or more TLBs in the memory management hardware, and it is nearly always present in any hardware that utilizes paged or segmented virtual memory.","번역 룩어사이드 버퍼(TLB)는 메모리 관리 하드웨어가 가상 주소 번역 속도를 향상시키기 위해 사용하는 캐시입니다. 대부분의 데스크톱, 노트북 및 서버 프로세서는 메모리 관리 하드웨어에 하나 이상의 TLB를 포함하며, 이는 거의 항상 호출되거나 분할된 가상 메모리를 사용하는 모든 하드웨어에 존재합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In a direct mapped or set associative cache, what is special about the cache size?",직접 매핑 또는 집합 연관 캐시에서 캐시 크기의 특별한 점은 무엇인가요?,"Main memory is divided into pages, and a memory page maps directly to the cache way size. So an item in a cache page can be mapped to any one of 8 cache ways in an 8-way associative cache. A direct mapped cache simply has one cache way, but it works the same way.",주 메모리는 페이지로 나뉘며 메모리 페이지는 캐시 웨이 크기에 직접 매핑됩니다. 따라서 캐시 페이지의 항목은 8방향 연관 캐시의 8가지 캐시 웨이 중 하나에 매핑할 수 있습니다. 직접 매핑된 캐시에는 캐시 웨이가 하나만 있지만 동일한 방식으로 작동합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many bits does a SHA1 produce?,SHA1은 몇 비트를 생성하나요?,160,160,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many bits does a SHA2 and SHA3 produce?,SHA2와 SHA3는 몇 비트를 생성하나요?,224 to 512,224에서 512까지,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is it always letters we are looking for in compression?,우리가 항상 압축에서 찾고 있는 것은 글자인가요?,"No. Hardly.
We are looking to compress discrete symbols, not letters. If we have a few words, they could be symbols.
We try to balance longest chains of symbols and the lowest entropy.","아니요. 거의요.
우리는 문자가 아닌 이산 기호를 압축하려고 합니다. 단어가 몇 개 있다면 기호가 될 수 있습니다.
우리는 가장 긴 기호 사슬과 가장 낮은 엔트로피를 균형 있게 맞추려고 노력합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Zopfli?,What is Zopfli?,"Zopfli is data compression software that encodes data into DEFLATE, gzip and zlib formats. It achieves higher compression than other DEFLATE/zlib implementations, but takes much longer to perform the compression. It was first released in February 2013 by Google.","Zopfli는 데이터를 DEFLATE, gzip, zlib 형식으로 인코딩하는 데이터 압축 소프트웨어입니다. 다른 DEFLATE/zlib 구현보다 더 높은 압축을 달성하지만, 압축을 수행하는 데 훨씬 더 오랜 시간이 걸립니다. 이 소프트웨어는 2013년 2월에 Google에 의해 처음 출시되었습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Chinese remainder theorem?,중국의 나머지 정리는 무엇인가요?,"If one knows the remainders of the division of an integer n by several integers, then one can determine uniquely the remainder of the division of n by the product of these integers, under the condition that the divisors are pairwise coprime.","정수 n의 나눗셈의 나머지를 여러 정수로 알고 있다면, 나눗셈이 쌍대 동치라는 조건 하에서 n의 나눗셈의 나머지를 이 정수들의 곱으로 유일하게 결정할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How do you change a 2s complement positive integer into a negative one?,2s 보체 양의 정수를 음수로 어떻게 변경하나요?,Flip all bits and + 1,모든 비트를 뒤집고 +1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How do you change a 2s complement negative integer into a positive one?,2s 보체 음의 정수를 양의 정수로 어떻게 변경하나요?,Flip all bits and + 1 (same as going the other way),모든 비트를 뒤집고 +1(반대 방향으로 가는 것과 동일),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Which way does the stack grow?,스택은 어느 방향으로 성장하나요?,Down to lower memory addresses.,낮은 메모리 주소까지.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is polymorphism in OO?,OO에서 다형성이란 무엇인가요?,"A property of OO in which an abstraction operation may be performed in different ways in different classes, but share an interface.
Also can mean multiple methods of the same name but different signature.","OO의 속성으로, 클래스에 따라 추상화 작업을 다양한 방식으로 수행할 수 있지만 인터페이스를 공유할 수 있습니다.
또한 이름은 같지만 서명이 다른 여러 메서드를 의미할 수도 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the 4 main tenets of OO?,OO의 4가지 주요 원칙은 무엇인가요?,"Abstraction
Polymorphism
Inheritance 
Encapsulation

a pie (acronym)","추상화
다형성
상속 
캡슐화

파이(acronym)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is dynamic binding?,동적 바인딩이란 무엇인가요?,"Dynamic binding, also called dynamic dispatch, is the process of linking procedure call to a specific sequence of code (method) at run-time. Dynamic binding is also known as late binding or run-time binding. Dynamic binding is an object oriented programming concept and it is related with polymorphism and inheritance.","동적 바인딩, 또는 동적 디스패치는 런타임에 프로시저 호출을 특정 코드 시퀀스(메소드)에 연결하는 과정입니다. 동적 바인딩은 레이트 바인딩 또는 런타임 바인딩이라고도 합니다. 동적 바인딩은 객체 지향 프로그래밍 개념으로 다형성 및 상속과 관련이 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a package?,패키지란 무엇인가요?,A group of classes bundled together.,클래스 그룹이 함께 묶여 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an interface in OO?,OO에서 인터페이스란 무엇인가요?,"Similar to an abstract data type, but simply defines the expected behaviors of a class, but does not suggest an implementation.",추상적인 데이터 유형과 유사하지만 단순히 클래스의 예상 동작을 정의할 뿐 구현을 제안하지는 않습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a framework?,프레임워크란 무엇인가요?,A reusable piece of software that implements a generic solution to a generalized problem. It saves time by being a close model of the problem domain and can reach 100% with details coded by the implementer.,일반화된 문제에 대한 일반적인 해결책을 구현하는 재사용 가능한 소프트웨어입니다. 문제 도메인의 근접 모델로 시간을 절약하고 구현자가 코딩한 세부 정보로 100%에 도달할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are hooks?,훅이란 무엇인가요?,"The portions of a framework that are called, but do nothing and require implementation when needed.",프레임워크의 일부는 호출되지만 아무것도 하지 않고 필요할 때 구현이 필요한 부분입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a server?,서버란 무엇인가요?,A program that provides a service for other programs to connect to it.,다른 프로그램이 연결될 수 있도록 서비스를 제공하는 프로그램입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an OCL?,OCL이란 무엇인가요?,Object constraint language. A specification language designed to formally specify constraints in software modules. An OCL expression specifies a logical fact about the system that must remain true.,객체 제약 언어. 소프트웨어 모듈에서 제약 조건을 공식적으로 지정하도록 설계된 사양 언어입니다. OCL 표현식은 참으로 유지되어야 하는 시스템에 대한 논리적 사실을 지정합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Chain of Responsibility pattern?,책임 사슬 패턴이란 무엇인가요?,Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.,요청을 처리할 수 있는 두 개 이상의 객체를 제공하여 요청 발신자를 수신자와 연결하지 않도록 합니다. 수신 객체를 체인으로 연결하고 객체가 요청을 처리할 때까지 체인을 따라 전달합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Command pattern?,명령 패턴이란 무엇인가요?,"Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.","요청을 객체로 캡슐화하여 다양한 요청, 대기열 또는 로그 요청을 가진 클라이언트를 매개변수화하고 되돌릴 수 없는 작업을 지원할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern avoids coupling the sender of a request to its receiver by giving more than one object a chance to handle the request?,요청을 처리할 수 있는 두 개 이상의 객체를 제공하여 요청 발신자를 수신자와 연결하지 않는 디자인 패턴은 무엇인가요?,Chain of Responsibility,책임의 사슬,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What design pattern encapsulates a request as an object, thereby letting you parameterize clients with different requests?",요청을 객체로 캡슐화하여 다양한 요청을 가진 클라이언트를 매개변수화할 수 있는 디자인 패턴은 무엇인가요?,Command pattern,명령 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Interpreter pattern?,인터프리터 패턴이란 무엇인가요?,"Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.","언어가 주어졌을 때, 해당 언어의 문법에 대한 표현과 그 표현을 사용하여 해당 언어의 문장을 해석하는 해석기를 정의하세요.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What design pattern, given a language, defines a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language?",언어에 주어진 디자인 패턴 중 문법에 대한 표현과 해당 표현을 사용하여 해당 언어의 문장을 해석하는 인터프리터를 정의하는 것은 무엇인가요?,Interpreter pattern,인터프리터 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Iterator pattern?,반복 패턴이란 무엇인가요?,Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.,집계 객체의 기본 표현을 노출하지 않고 순차적으로 요소에 액세스할 수 있는 방법을 제공합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation?,집합 객체의 기본 표현을 노출하지 않고 순차적으로 요소에 액세스할 수 있는 방법을 제공하는 디자인 패턴은 무엇인가요?,Iterator pattern,반복자 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Mediator pattern?,중재자 패턴이란 무엇인가요?,Defines an object that encapsulates how a set of objects interact. Promotes loose coupling by keeping objects from referring to each other explicitly and it lets you vary their interactions independently.,"객체 집합이 상호 작용하는 방식을 캡슐화하는 객체를 정의합니다. 객체가 서로를 명시적으로 참조하지 않도록 하여 느슨한 결합을 촉진하고, 객체 간의 상호 작용을 독립적으로 변경할 수 있도록 합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern defines an object that encapsulates how a set of objects interact?,객체 집합이 상호 작용하는 방식을 캡슐화하는 객체를 정의하는 디자인 패턴은 무엇인가요?,Mediator pattern,중재자 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Memento pattern?,메멘토 패턴이란 무엇인가요?,"Without violating encapsulation, capture and externalize an object's internal state so that the object can be restore to this state later.",캡슐화를 위반하지 않고 객체의 내부 상태를 캡처하고 외부화하여 객체가 나중에 이 상태로 복원될 수 있도록 하세요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern captures and externalize an object's internal state so that the object can be restore to this state later?,물체의 내부 상태를 포착하고 외부화하여 나중에 이 상태로 복원할 수 있도록 하는 디자인 패턴은 무엇인가요?,Memento pattern,메멘토 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Observer pattern?,옵저버 패턴이란 무엇인가요?,"Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.","객체 간의 일대일 종속성을 정의하여, 하나의 객체가 상태를 변경하면 모든 종속 변수가 자동으로 통지되고 업데이트됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What design pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically?",객체 간의 일대일 종속성을 정의하여 하나의 객체가 상태를 변경하면 모든 종속 변수가 자동으로 통지되고 업데이트되도록 하는 디자인 패턴은 무엇인가요?,Observer pattern,관찰자 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the State pattern?,주 패턴은 무엇인가요?,Allows an object to alter its behavior when its internal state changes. The object will appear to change its class.,객체의 내부 상태가 변경될 때 동작을 변경할 수 있습니다. 객체가 클래스를 변경하는 것처럼 보입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern allows an object to alter its behavior when its internal state changes?,물체의 내부 상태가 변할 때 동작을 변경할 수 있는 디자인 패턴은 무엇인가요?,State pattern,상태 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Strategy pattern?,전략 패턴이란 무엇인가요?,"Defines a family of algorithms, encapsulates each one, and makes them interchangeable. Lets the algorithm vary independently from clients that use it.",알고리즘 패밀리를 정의하고 각 알고리즘을 캡슐화하여 상호 호환되도록 합니다. 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What design pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable, and lets the algorithm vary independently from clients that use it?","알고리즘 패밀리를 정의하고, 각 알고리즘을 캡슐화하여 상호 호환 가능하게 하며, 알고리즘을 사용하는 클라이언트와 독립적으로 다르게 만드는 디자인 패턴은 무엇인가요?",Strategy pattern,전략 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Template Method pattern?,템플릿 메서드 패턴이란 무엇인가요?,"Defines the skeleton of an algorithm in an operation, deferring some steps to subclasses. Lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.",작업에서 알고리즘의 골격을 정의하고 몇 가지 단계를 하위 클래스로 연기합니다. 하위 클래스는 알고리즘의 구조를 변경하지 않고도 알고리즘의 특정 단계를 재정의할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What design pattern defines the skeleton of an algorithm in an operation, deferring some steps to subclasses?",작업에서 알고리즘의 골격을 정의하는 설계 패턴은 하위 클래스로 몇 가지 단계를 미룰 수 있나요?,Template Method pattern,템플릿 메서드 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Visitor pattern?,방문자 패턴이란 무엇인가요?,Represents an operation to be performed on the elements of an object structure. Lets you define a new operation without changing the classes of the elements on which it operates.,객체 구조의 요소에 대해 수행할 작업을 나타냅니다. 해당 작업이 수행되는 요소의 클래스를 변경하지 않고 새 작업을 정의할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern represents an operation to be performed on the elements of an object structure and lets you define a new operation without changing the classes of the elements on which it operates?,"객체 구조의 요소에 대해 수행해야 하는 작업을 나타내며, 해당 작업이 수행되는 요소의 클래스를 변경하지 않고 새로운 작업을 정의할 수 있는 디자인 패턴은 무엇인가요?",Visitor pattern,방문자 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Adapter pattern?,어댑터 패턴이란 무엇인가요?,Converts the interface of a class into another interface clients expect. Lets classes work together that couldn't otherwise because of incompatible interfaces.,클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환합니다. 호환되지 않는 인터페이스로 인해 그렇지 않은 클래스는 함께 작동하도록 합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern converts the interface of a class into another interface clients expect?,클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환하는 디자인 패턴은 무엇인가요?,Adapter pattern,어댑터 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Bridge pattern?,브리지 패턴이란 무엇인가요?,Decouples an abstraction from its implementation so that the two can vary independently.,추상화를 구현에서 분리하여 두 추상화가 독립적으로 변할 수 있도록 합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern decouples an abstraction from its implementation so that the two can vary independently?,추상화를 구현에서 분리하여 두 가지가 독립적으로 달라질 수 있도록 하는 디자인 패턴은 무엇인가요?,Bridge pattern,다리 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Composite pattern?,복합 패턴이란 무엇인가요?,Compose objects into tree structures to represent part-whole hierarchies. Lets clients treat individual objects and compositions of objects uniformly.,객체를 트리 구조로 구성하여 부분 전체 계층을 나타냅니다. 클라이언트가 개별 객체와 객체의 구성을 균일하게 처리할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern composes objects into tree structures to represent part-whole hierarchies?,부분 전체 계층 구조를 나타내기 위해 객체를 트리 구조로 구성하는 디자인 패턴은 무엇인가요?,Composite pattern,복합 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Decorator pattern?,데코레이터 패턴이란 무엇인가요?,Attaches additional responsibilities to an object dynamically. Provides a flexible alternative to sub-classing for extending functionality.,객체에 동적으로 추가 책임을 부여합니다. 기능을 확장하기 위해 하위 분류에 대한 유연한 대안을 제공합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern attaches additional responsibilities to an object dynamically and provides a flexible alternative to sub-classing for extending functionality?,객체에 동적으로 추가적인 책임을 부여하고 기능 확장을 위한 하위 분류에 유연한 대안을 제공하는 디자인 패턴은 무엇인가요?,Decorator pattern,장식 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Facade pattern?,파사드 패턴이란 무엇인가요?,Provides a unified interface to a set of interfaces in a subsystem. Defines a high-level interface that makes the subsystem easier to use.,하위 시스템의 인터페이스 세트에 통합 인터페이스를 제공합니다. 하위 시스템을 더 쉽게 사용할 수 있도록 고급 인터페이스를 정의합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern provides a unified interface to a set of interfaces in a subsystem and defines a high-level interface that makes the subsystem easier to use.,서브시스템의 인터페이스 세트에 통합 인터페이스를 제공하고 서브시스템을 더 쉽게 사용할 수 있는 고급 인터페이스를 정의하는 디자인 패턴은 무엇인가요.,Facade pattern,외관 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Flyweight pattern?,플라이급 패턴이란 무엇인가요?,Uses sharing to support large numbers of fine-grained objects efficiently.,공유를 사용하여 많은 세분화된 객체를 효율적으로 지원합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern uses sharing to support large numbers of fine-grained objects efficiently?,많은 수의 세밀한 객체를 효율적으로 지원하기 위해 공유를 사용하는 디자인 패턴은 무엇인가요?,Flyweight pattern,플라이급 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Proxy pattern?,프록시 패턴이란 무엇인가요?,Provides a surrogate or placeholder for another object to control access to it.,다른 객체에 대한 접근을 제어할 수 있는 대리자 또는 자리 표시자를 제공합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern provides a surrogate or placeholder for another object to control access to it?,다른 객체에 대한 접근을 제어하기 위해 대리자 또는 플레이스홀더를 제공하는 디자인 패턴은 무엇인가요?,Proxy pattern,프록시 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Abstract Factory pattern?,추상 공장 패턴이란 무엇인가요?,Provides an interface for creating families of related or dependent objects without specifying their concrete class.,구체적인 클래스를 지정하지 않고도 관련되거나 종속된 객체의 패밀리를 생성할 수 있는 인터페이스를 제공합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern provides an interface for creating families of related or dependent objects without specifying their concrete class?,구체적인 클래스를 지정하지 않고 관련되거나 종속된 객체의 패밀리를 만들 수 있는 인터페이스를 제공하는 디자인 패턴은 무엇인가요?,Abstract Factory pattern,추상 공장 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Builder pattern?,빌더 패턴이란 무엇인가요?,"Separates the construction of a complex object from its representation, so the same construction process can create different representations.",복잡한 객체의 구성과 그 표현을 분리하여 동일한 구성 프로세스가 서로 다른 표현을 만들 수 있도록 합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What design pattern separates the construction of a complex object from its representation, so the same construction process can create different representations?","복잡한 객체의 구성과 표현을 구분하는 디자인 패턴은 무엇이며, 동일한 구성 프로세스가 서로 다른 표현을 만들 수 있을까요?",Builder pattern.,빌더 패턴.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Factory Method pattern?,공장 방식 패턴이란 무엇인가요?,"(Technically it's an idiom)
Defines an interface for creating an object, but lets subclasses decide which class to instantiate. Lets a class defer instantiation to subclasses.","(기술적으로는 관용구입니다)
객체를 만들기 위한 인터페이스를 정의하지만 하위 클래스가 인스턴스화할 클래스를 결정할 수 있도록 합니다. 클래스가 인스턴스화를 하위 클래스로 연기하도록 합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What design pattern defines an interface for creating an object, but lets subclasses decide which class to instantiate?",객체를 만들기 위한 인터페이스를 정의하지만 하위 클래스가 인스턴스화할 클래스를 결정할 수 있도록 하는 디자인 패턴은 무엇인가요?,"Factory method (technically an idiom, not a design pattern)",공장 방식(기술적으로 디자인 패턴이 아닌 관용구),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Prototype pattern?,프로토타입 패턴이란 무엇인가요?,"Specifies the kinds of objects to create using a prototypical instance, and creates new objects by copying this prototype.","프로토타입 인스턴스를 사용하여 생성할 객체의 종류를 지정하고, 이 프로토타입을 복사하여 새로운 객체를 만듭니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What design pattern specifies the kinds of objects to create using a prototypical instance, and creates new objects by copying this prototype?",프로토타입 인스턴스를 사용하여 생성할 객체의 종류를 지정하고 이 프로토타입을 복사하여 새로운 객체를 생성하는 디자인 패턴은 무엇인가요?,Prototype pattern,프로토타입 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Singleton pattern?,싱글턴 패턴이란 무엇인가요?,Ensures a class only has one instance and provides a global point of access to it.,Ensures a class only has one instance and provides a global point of access to it.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What design pattern ensures a class only has one instance and provides a global point of access to it?,What design pattern ensures a class only has one instance and provides a global point of access to it?,Singleton pattern,싱글톤 패턴,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are design patterns?,디자인 패턴이란 무엇인가요?,"Recurring, reusable solutions to common class and class relationship problems.",일반적인 계층 및 계층 관계 문제에 대한 반복적이고 재사용 가능한 해결책.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Law of Demeter?,데메테르의 법칙이란 무엇인가요?,"Each unit should have only limited knowledge about other units - only units ""closely"" related to the current unit. Each unit should only talk to friends, not strangers. Only talk to immediate friends.","각 유닛은 현재 유닛과 ""가까운"" 유닛들만 다른 유닛에 대해 제한된 지식을 가져야 합니다. 각 유닛은 낯선 사람이 아닌 친구들과만 대화해야 합니다. 가까운 친구들과도만 대화해야 합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"If a cache line size is 64B, and the memory bus is 64 bits wide, how many transfers per cache line?","캐시 라인 크기가 64B이고 메모리 버스 폭이 64비트인 경우, 캐시 라인당 전송 횟수는 몇 번인가요?",8,8,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does an exclusive cache style?,독점 캐시 스타일이란 무엇인가요?,"An eviction from L1D pushes the cache line down into L2, which has the same cache line size. Each eviction is progressively more expensive.",L1D에서 퇴거하면 캐시 라인 크기가 같은 L2로 캐시 라인이 밀려 내려갑니다. 각 퇴거는 점진적으로 더 비쌉니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What manufacturer uses an exclusive cache style?,독점 캐시 스타일을 사용하는 제조업체는 어디인가요?,AMD,AMD,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does an inclusive cache style work?,포괄적 캐시 스타일은 어떻게 작동하나요?,Each cache line in L1D is also in L2. This makes L1D eviction faster.,L1D의 각 캐시 라인도 L2에 있습니다. 따라서 L1D 삭제 속도가 빨라집니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What manufacturer uses an inclusive cache style?,포괄적 캐시 스타일을 사용하는 제조업체는 어디인가요?,Intel,인텔,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Fast Fourier Transform?,고속 푸리에 변환이란 무엇인가요?,"A fast Fourier transform (FFT) algorithm computes the discrete Fourier transform (DFT) of a sequence, or its inverse. Fourier analysis converts a signal from its original domain (often time or space) to a representation in the frequency domain and vice versa. An FFT rapidly computes such transformations by factorizing the DFT matrix into a product of sparse (mostly zero) factors.",고속 푸리에 변환(FFT) 알고리즘은 시퀀스의 이산 푸리에 변환(DFT) 또는 그 역행렬을 계산합니다. 푸리에 분석은 원래 도메인(종종 시간 또는 공간)의 신호를 주파수 도메인의 표현으로 변환하거나 그 반대로 변환합니다. FFT는 DFT 행렬을 희소(대부분 0) 요인의 곱으로 분해하여 이러한 변환을 빠르게 계산합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a skip list?,건너뛰기 목록이란 무엇인가요?,"A data structure that allows fast search within an ordered sequence of elements. Fast search is made possible by maintaining a linked hierarchy of subsequences, with each successive subsequence skipping over fewer elements than the previous one. Searching starts in the sparsest subsequence until two consecutive elements have been found, one smaller and one larger than or equal to the element searched for.

A skip list is built in layers. The bottom layer is an ordinary ordered linked list. Each higher layer acts as an ""express lane"" for the lists below, where an element in layer i appears in layer i+1 with some fixed probability p (two commonly used values for p are 1/2 or 1/4).","정렬된 요소 시퀀스 내에서 빠른 검색을 가능하게 하는 데이터 구조입니다. 각 연속적인 하위 시퀀스는 이전보다 적은 수의 요소를 건너뛰고 연결된 하위 시퀀스 계층을 유지함으로써 빠른 검색이 가능합니다. 검색은 가장 드문 하위 시퀀스에서 시작하여 검색된 요소보다 작거나 같은 두 개의 연속적인 요소가 발견될 때까지 계속됩니다.

건너뛰기 목록은 레이어로 구성되어 있습니다. 하위 레이어는 일반적인 순서대로 연결된 목록입니다. 각 상위 레이어는 아래 목록의 ""급행 차선"" 역할을 하며, 레이어 i의 요소는 고정된 확률 p(p에 대해 일반적으로 사용되는 두 값은 1/2 또는 1/4)로 레이어 i+1에 나타납니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What operations does a skip list support and what is their avg and worst case times?,"스킵 리스트는 어떤 작업을 지원하며, 평균 시간과 최악의 경우 시간은 어떻게 되나요?","search: O(log n) O(n)
insert: O(log n) O(n)
delete: O(log n) O(n)","검색: O(log n) O(n)
삽입: O(log n) O(n)
삭제: O(로그 n) O(n)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What operations does a van Emde Boas tree support and what are the time complexities?,반 엠데 보아스 트리는 어떤 연산을 지원하며 time complexity는 어떻게 되나요?,"All are O(log log M), where M is the total number of items that can be stored = 2^m
Or O(log m) where m is the actual number of items stored
Space: O(M)

Search
Insert
Delete
Predecessor
Successor","모두 O(로그 로그 M)이며, 여기서 M은 저장할 수 있는 총 항목 수 = 2^m입니다
또는 O(log m) 여기서 m은 저장된 실제 항목 수입니다
공간: O(M)

검색
삽입
삭제
전임자
후계자",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the complexities for treap operations?,치료 작업의 복잡성은 무엇인가요?,"For all the basic maintenance operations, they are O(log n) average case and O(n) worst case.
- Search
- Insert
- Delete

For these operations, O(m log n/m) for treaps of sizes m and n, with m ≤ n. 
- union
- intersection
- difference","모든 기본 유지보수 작업에 대해 O(log n) 평균 경우와 O(n) 최악의 경우입니다.
- 검색
- 삽입
- 삭제

이러한 작업의 경우, 크기가 m이고 n인 트랩에 대해 m ≤ n인 O(m log n/m)입니다. 
- 연합
- 교차점
- 차이",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are Catalan numbers?,카탈루냐 숫자란 무엇인가요?,"Catalan numbers form a sequence of natural numbers that occur in various counting problems, often involving recursively-defined objects. They can be thought of as the set of balanced parentheses. 
Do not think of Catalan numbers as pseudoprimes. There are only 3 Catalan pseudoprimes.","카탈루냐 수는 다양한 카운팅 문제에서 발생하는 일련의 자연수를 형성하며, 종종 재귀적으로 정의된 객체와 관련이 있습니다. 카탈루냐 수는 균형 잡힌 괄호의 집합으로 생각할 수 있습니다. 
카탈루냐 숫자를 의사 소수로 생각하지 마세요. 카탈루냐 의사 소수는 단 3개뿐입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is Karatsuba multiplication?,카라츠바 곱셈이란 무엇인가요?,"It reduces the multiplication of two n-digit numbers to at most n^1.585 single-digit multiplications in general (and exactly n^log(base2)3 when n is a power of 2). The Karatsuba algorithm was the first multiplication algorithm asymptotically faster than the quadratic ""grade school"" algorithm.","일반적으로 n자리 숫자 두 개의 곱셈을 최대 n^1.585개의 한 자릿수 곱셈으로 줄입니다(n이 2의 거듭제곱일 때 정확히 n^log(base2)3). 카라츠바 알고리즘은 이차 ""학년"" 알고리즘보다 점진적으로 빠른 최초의 곱셈 알고리즘이었습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the time complexity of Ford-Fulkerson?,포드-풀커슨의 time complexity는 무엇인가요?,O(E max|f|),O(E max|f|),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
16^0 ?,16^0 ?,1,1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
16^1 ?,16^1 ?,16,16,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
16^2 ?,16^2 ?,256,256,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
16^3 ?,16^3 ?,4096,4096,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
16^4 ?,16^4 ?,"65,536","65,536",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
16^5 ?,16^5 ?,"1,048,576","1,048,576",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
16^6 ?,16^6 ?,16 million,"1,600만",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
16^7,16^7,268 million,"2억 6,800만",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
16^8 ?,16^8 ?,"4.294 billion, same as 2^32","42억 9,400만, 2^32와 동일",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is 0xB in decimal?,소수점에서 0xB는 무엇인가요?,11,11,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is 0xC in decimal?,소수점에서 0xC는 무엇인가요?,12,12,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is 0xD in decimal?,소수점에서 0xD는 무엇인가요?,13,13,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is 0xE in decimal?,소수점에서 0xE는 무엇인가요?,14,14,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is 0xF in decimal?,소수점에서 0xF는 무엇인가요?,15,15,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is 0xA in decimal?,소수점에서 0xA는 무엇인가요?,10,10,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is 0xA in binary?,이진법에서 0xA란 무엇인가요?,1010,1010,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is 0xB in binary?,이진법에서 0xB란 무엇인가요?,1011,1011,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is 0xC in binary?,이진법에서 0xC란 무엇인가요?,1100,1100,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is 0xD in binary?,이진법에서 0xD란 무엇인가요?,1101,1101,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is 0xE in binary?,이진법에서 0xE는 무엇인가요?,1110,1110,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is 0xF in binary?,이진법에서 0xF란 무엇인가요?,1111,1111,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How are the priorities of a treap assigned?,트랩의 우선순위는 어떻게 할당되나요?,Randomly generated upon insertion. That randomness is used to keep the tree balanced.,삽입 시 무작위로 생성됩니다. 이러한 무작위성은 트리의 균형을 유지하는 데 사용됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Give an example of a proposition in conjunctive normal form.,결합 법선 형식의 명제를 예로 들어보세요.,(A + ~B)(A + B),(A + ~B)(A + B),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does a half-adder handle an addition?,하프 애더는 덧셈을 어떻게 처리하나요?,XOR for the sum and AND for the carry,합계에 대한 XOR과 캐리에 대한 AND,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is a geometric Steiner tree NP-Complete?,기하학적 슈타이너 트리는 NP-완전인가요?,Yes,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the 2 algorithms for convex hull?,볼록 껍질을 위한 두 가지 알고리즘은 무엇인가요?,"- Graham scan
- Jarvis march (gift-wrapping method)","- 그레이엄 스캔
- 자비스 행진(선물 포장 방법)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does a Graham scan work in finding convex hull?,그레이엄 스캔은 볼록 껍질을 찾는 데 어떻게 작동하나요?,"At O(n log n), uses a sort and then a simple single pass of all the points, and making only left turns as it goes around the perimeter counter-clockwise. When the next point is a right turn, it backtracks past all points (using a stack and popping points off) until that turn turns into a left turn.",O(n log n)에서는 모든 지점을 정렬한 다음 간단한 단일 패스를 사용하여 반시계 방향으로 회전하면서 왼쪽으로만 회전합니다. 다음 지점이 우회전할 때는 모든 지점을 역추적하여 스택과 팝업 포인트를 사용하여 왼쪽으로 회전할 때까지 모든 지점을 지나갑니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How does the Jarvis march work in finding convex hull?,자비스 행진은 볼록 껍질을 찾는 데 어떻게 작동하나요?,"Starting with the leftmost point p: 
Go through each point to the right of that point, and using p as a pivot, find which point is the most clockwise. O(n)
Get the most clockwise point as the new p - O(1)
Loop again with new p

This continues until the starting point is reached O(h) - where h is the number of hull points","맨 왼쪽 점 p부터 시작합니다: 
각 지점을 통과하여 해당 지점의 오른쪽으로 이동하고 p를 피벗으로 사용하여 어느 지점이 가장 시계 방향인지 찾습니다. O(n)
새로운 p - O(1)로 가장 시계 방향의 점을 구합니다
새로운 p로 다시 루프

이것은 시작 지점이 O(h)에 도달할 때까지 계속됩니다 - 여기서 h는 선체 지점의 수입니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the worst case time complexity of a Jarvis march?,자비스 행진의 최악의 경우 time complexity는 무엇인가요?,"O(n^2)
Occurs when most points are part of the hull, and few points contained in the hull.","O(n^2)
대부분의 지점이 선체의 일부일 때 발생하며, 선체에 포함된 지점은 거의 없습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the average complexity of a Jarvis march?,자비스 행진의 평균 복잡성은 무엇인가요?,O(n * h) where h is the number of points that compose the hull.,O(n * h) 여기서 h는 선체를 구성하는 점의 수입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is white-box testing?,화이트박스 테스트란 무엇인가요?,The tester is using knowledge of the program's internals.,테스터는 프로그램 내부에 대한 지식을 활용하고 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is black-box testing?,블랙박스 테스트란 무엇인가요?,The tester is testing without knowledge of the internals.,테스터가 내부 정보 없이 테스트하고 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is unit testing?,단위 테스트란 무엇인가요?,Testing a single module in isolation.,단일 모듈을 개별적으로 테스트합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"What can affect testing, apart from API inputs?",API 입력 외에 테스트에 영향을 미칠 수 있는 것은 무엇인가요?,"- timing of inputs
- disk full
- network latency
- network failures","- 입력 타이밍
- 디스크 가득
- 네트워크 지연 시간
- 네트워크 장애",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are 3 situations where timing of inputs important in testing?,테스트에서 입력 타이밍이 중요한 3가지 상황은 무엇인가요?,"- when SUT interacts directly with hardware devices
- when SUT interfaces with other machines on the network
- SUT is multithreaded","- SUT이 하드웨어 장치와 직접 상호 작용할 때
- SUT이 네트워크의 다른 컴퓨터와 인터페이스할 때
- SUT은 멀티스레드입니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a mock object?,모의 물체란 무엇인가요?,An object used to replicate the interfaces and interactions of a larger system that can be bolted on to the SUT.,SUT에 볼트로 고정할 수 있는 더 큰 시스템의 인터페이스와 상호 작용을 복제하는 데 사용되는 객체입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is integration testing?,통합 테스트란 무엇인가요?,Testing units together to ensure the integrated behavior performs as expected.,통합 동작이 예상대로 작동하는지 확인하기 위해 유닛을 함께 테스트합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is system testing?,시스템 테스트란 무엇인가요?,"- not concerned with internals
- does system as a while perform acceptably for the important use cases","- 내부와 관련이 없는
- 시스템이 중요한 사용 사례에 대해 한동안 허용 가능한 성능을 발휘합니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is differential testing?,감별 테스트란 무엇인가요?,Running test inputs into 2 different implementations and then testing for equality. This is useful for testing multiple versions of the software.,테스트 입력을 두 가지 다른 구현으로 실행한 다음 동일성을 테스트합니다. 이는 여러 버전의 소프트웨어를 테스트하는 데 유용합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is stress testing?,스트레스 테스트란 무엇인가요?,"Testing code or a system beyond its normal usage.
Testing large inputs.
Testing many requests.","코드나 시스템을 정상적으로 사용하지 않는 테스트.
대규모 입력 테스트.
많은 요청을 테스트합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you tell you're testing enough?,어떻게 하면 충분히 테스트하고 있다고 말할 수 있나요?,Code coverage metrics (of which there are a few),코드 커버리지 메트릭(몇 가지가 있음),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does code coverage not tell you?,코드 커버리지는 무엇을 알려주지 않나요?,"- missing errors of omission
- code that misses a specification item
- does not tell us that code looped the correct number of times","- 누락된 오류
- 사양 항목이 누락된 코드
- 코드가 올바른 횟수로 반복되었음을 알려주지 않습니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What should you do when you discover that not all code is covered?,모든 코드가 포함되지 않는다는 것을 알게 되면 어떻게 해야 하나요?,"Don't blindly write tests to cover all cases.
Rethink the tests. Perhaps they are interpreting the functionality incorrectly.","모든 사례를 다루기 위해 맹목적으로 시험을 작성하지 마세요.
테스트를 다시 생각해 보세요. 아마도 그들이 기능을 잘못 해석하고 있는 것 같습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some coverage metrics?,보장 지표에는 어떤 것들이 있나요?,"- line coverage
- statement coverage (multiple statements on a line)
- branch coverage
- mc/dc coverage
- loop coverage","- 라인 커버리지
- 진술 범위(한 줄에 여러 개의 진술)
- 지점 커버리지
- MC/DC 커버리지
- 루프 커버리지",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is mc/dc coverage?,MC/DC 커버리지란 무엇인가요?,"modified condition / decision

- Required for certain types of avionics software
- Tests every possible branch and condition","수정된 조건/결정

- 특정 유형의 항공 전자 소프트웨어에 필요함
- 가능한 모든 가지와 조건을 테스트합니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is path coverage?,경로 보장이란 무엇인가요?,Coverage that is concerned with the paths taken to arrive at a place in the code.,코드의 특정 장소에 도착하는 경로와 관련된 커버리지.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is infeasible code?,실행 불가능한 코드란 무엇인가요?,"Code that can never be true.
Infeasible code is code that is either not forward- or not backward-reachable. Infeasible code is not necessarily an error but it is a good indicator that something is wrong with the code and, e.g., in avionics, infeasible code is forbidden by current standards.","절대 사실일 수 없는 코드.
실행 불가능한 코드는 순방향 또는 역방향으로 도달할 수 없는 코드입니다. 실행 불가능한 코드는 반드시 오류는 아니지만 코드에 문제가 있다는 좋은 지표이며, 예를 들어 항공전자공학에서는 실행 불가능한 코드가 현재 표준에 의해 금지되어 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Should you include integration tests in code coverage metrics?,코드 커버리지 지표에 통합 테스트를 포함해야 하나요?,No,아니요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What should you do before fixing a reported bug?,보고된 버그를 수정하기 전에 무엇을 해야 하나요?,Write a test. Avoiding this practice allows bugs to re-appear.,테스트를 작성하세요. 이 관행을 피하면 버그가 다시 나타날 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Why should tests be idempotent and isolated?,왜 검사는 무력하고 고립되어야 하나요?,"It allows tests to be run in any order, re-run, and parallelized.","테스트를 어떤 순서로든 실행하고, 다시 실행하고, 병렬화할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
delete (unordered singly linked list),삭제(순서 없이 단일 링크된 목록),O(n),O(n),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
find (unordered singly linked list),찾기(순서 없이 단일 링크된 목록),O(n),O(n),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
delete (ordered singly linked list),삭제(단일 링크 목록 정렬),O(n),O(n),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
find (Binary Search Tree),찾기(바이너리 검색 트리),O(h),O(h),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
add (Binary Search Tree),추가(바이너리 검색 트리),O(h),O(h),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Add element to the top of the stack - push,스택 상단에 요소 추가 - 푸시,O(1),O(1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Remove the top element of the stack - pop,스택의 상단 요소 제거 - 팝,O(1),O(1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Return the value of the top element of the stack without removing it.,스택의 최상위 요소 값을 제거하지 않고 반환합니다.,O(1),O(1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Add an element to a queue.,대기열에 요소를 추가합니다.,O(1),O(1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Remove an element from the front of the queue. dequeue,대기열 앞쪽에서 요소를 제거합니다. 대기열 해제,O(1),O(1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Return the element from the front of the queue without removing it. - front,요소를 제거하지 않고 대기열 앞쪽에서 반환합니다,O(1),O(1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
find (unordered array),찾기(순서가 없는 배열),O(n),O(n),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
add (unordered array),추가(순서가 없는 배열),O(1),O(1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
delete (unordered array),삭제(순서가 없는 배열),O(N),O(N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
find (sorted array),찾기(sorted 배열),"O(log n)
binary search","O(로그 n)
이진 검색",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
add (sorted array),추가(sorted 배열),O(n),O(n),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
delete an element from a sorted array,정렬된 배열에서 요소 삭제,O(N),O(N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
find (unordered singly linked list),찾기(순서 없이 단일 링크된 목록),O(N),O(N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
add (unordered singly linked list),추가(순서 없이 단일 링크된 목록),O(1),O(1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
delete (unordered singly linked list),삭제(순서 없이 단일 링크된 목록),O(N),O(N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
find (ordered singly linked list),찾기(단일 링크 목록 정렬),O(N),O(N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
add (ordered singly linked list),추가(단일 링크 목록 정렬),O(N),O(N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
delete (ordered singly linked list),삭제(단일 링크 목록 정렬),O(N),O(N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
find (Binary Search Tree),찾기(바이너리 검색 트리),O(h),O(h),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
add (Binary Search Tree),추가(바이너리 검색 트리),O(h),O(h),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
delete (Binary Search Tree),삭제(바이너리 검색 트리),O(h),O(h),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
find (Balanced Binary Search Tree),찾기(균형 Binary Search Tree),O(log N),O(로그 N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
add (Balanced Binary Search Tree),추가(균형 Binary Search Tree),O(log N),O(로그 N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
delete (Balanced Binary Search Tree),삭제(균형 Binary Search Tree),O(log N),O(로그 N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
find (Balanced Binary Search Tree),찾기(균형 Binary Search Tree),O(log N),O(로그 N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
add (Balanced Binary Search Tree),추가(균형 Binary Search Tree),O(log N),O(로그 N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
delete (Balanced Binary Search Tree),삭제(균형 Binary Search Tree),O(log N),O(로그 N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a skip list?,건너뛰기 목록이란 무엇인가요?,"A data structure for storing a sorted list of items using a hierarchy of linked lists that connect increasingly sparse subsequences of the items.
O(log N) expected time for all operations, O(N) worst case.","항목의 점점 더 희소해지는 하위 시퀀스를 연결하는 링크된 목록의 계층 구조를 사용하여 정렬된 항목 목록을 저장하는 데이터 구조입니다.
O(로그 N) 모든 작업에 대한 예상 시간, O(N) 최악의 경우.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a treap?,트랩이란 무엇인가요?,"Tree + heap
A random priority is assigned to every key and must maintain two properties:
- They are in order with respect to their keys, as in a typical binary search tree
- They are in heap order with respect to their priorities, that is, no key has a key of lower priority as an ancestor
O(log N) expected time for all operations, O(N) worst case.","트리 + 힙
모든 키에 무작위 우선순위가 할당되며 두 가지 속성을 유지해야 합니다:
- 그들은 일반적인 Binary Search Tree에서처럼 키에 대해 순서대로 배열되어 있습니다
- 우선순위에 따라 힙 순서대로 정렬됩니다. 즉, 어떤 키도 우선순위가 낮은 키를 조상으로 사용하지 않습니다
O(로그 N) 모든 작업에 대한 예상 시간, O(N) 최악의 경우.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a max-heap?,맥스 힙이란 무엇인가요?,"A queue in which each element has a ""priority"" assigned to it. Elements with higher priorities are served before lower priorities.","각 요소에 ""우선순위""가 할당된 대기열입니다. 우선순위가 높은 요소는 우선순위가 낮은 요소보다 먼저 제공됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
min (unordered sequence),min (순서 순서 없음),O(N),O(N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
insert (unordered sequence),삽입(순서 순서 없음),O(1),O(1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
removeMin (unordered sequence),removeMin (순서 순서 없음),O(N),O(N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
min (ordered sequence),min (순서 순서),O(1),O(1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
insert (ordered sequence),삽입(순서 순서대로),O(N),O(N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
removeMin (ordered sequence),removeMin (순서),O(1),O(1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
build (ordered sequence),빌드(순서 순서),O(N log N),O(N 로그 N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
min (binary heap),최소 (binary 더미),O(1),O(1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
insert (binary heap),삽입(binary 힙),O(log N),O(로그 N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
removeMin (binary heap),RemoveMin(이진 힙),O(log N),O(로그 N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
build (binary heap),빌드(binary 힙),O(N),O(N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a binary heap?,이진 힙이란 무엇인가요?,"A collection of keys arranged in a complete heap-ordered binary tree, represented in level order in an array (not using the first entry). The parent of the node in position k is in position [k/2] and the two children of the node in position k are in position 2k and 2k+1.","완전한 힙 순서 이진 트리에 배열된 키 모음으로, 배열에서 레벨 순서로 표시됩니다(첫 번째 항목을 사용하지 않음). 위치 k에 있는 노드의 부모는 [k/2] 위치에 있고, 위치 k에 있는 노드의 두 자식은 위치 2k와 2k+1에 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a Adaptable Priority Queue?,적응 가능한 우선순위 대기열이란 무엇인가요?,A priority queue that allows you to change the priority of objects already in the queue.,이미 대기열에 있는 객체의 우선순위를 변경할 수 있는 우선순위 대기열입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the time complexity of quicksort?,퀵소트의 time complexity는 어떻게 되나요?,"O(N^2 worst)
O(N log N) - best & expected","O(N^2 최악)
O(N 로그 N) - 최적 및 예상",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Lower Bound for Comparison Based Sorting,비교 기반 정렬의 하한선,No comparison based sorting algorithm can be faster than O(N log N),비교 기반 정렬 알고리즘은 O(N 로그 N)보다 빠를 수 없습니다,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
k-th smallest (full heap),k번째로 작은 (전체 힙),"Put all values in, do k removeMin operations: O(N + k log N)",모든 값을 입력합니다. dok k removeMin 연산: O(N + k log N),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a connected graph?,연결 그래프란 무엇인가요?,There exists a path from every vertex to every other vertex in the graph.,그래프의 모든 정점에서 다른 모든 정점으로 가는 경로가 존재합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a tree?,나무란 무엇인가요?,An acyclic connected graph.,비순환 연결 그래프.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a cycle?,사이클이란 무엇인가요?,Path with at least one edge whose first and last vertices are the same.,첫 번째 정점과 마지막 정점이 동일한 하나 이상의 간선이 있는 경로.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a spanning tree?,스패닝 트리란 무엇인가요?,A subgraph that contains all of that graph's vertices and a single tree.,해당 그래프의 모든 정점과 단일 트리를 포함하는 하위 그래프.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Space required for an adjacency list,인접 목록에 필요한 공간,O(E + V),O(E + V),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"is_adjacent (u,v) (adjacency matrix)","is_adjacent (u,v) (adj 인접 행렬)",O(degree(u)),O(도(u)),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the complexity of an adjacency list DFS?,인접 목록 DFS의 복잡성은 무엇인가요?,O(E),O(E),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is another name for a Min-Cost Spanning Tree?,미니 코스트 스패닝 트리의 다른 이름은 무엇인가요?,minimum spanning tree,최소 신장 트리,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Bitwise: Isolate the lowest bit that is 1 in x,비트와이즈: x에서 1인 가장 낮은 비트를 분리합니다,x & ~(x - 1),x & ~(x - 1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Bitwise: Replace the lowest bit that is 1 with 0,비트와이즈: 1인 가장 낮은 비트를 0으로 바꿉니다,x & (x - 1),x & (x - 1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Bitwise: Right propagate the rightmost set bit in x,비트와이즈: 오른쪽으로 가장 오른쪽으로 설정된 비트를 x로 전파합니다,x | (x & ~(x - 1) - 1),x | (x & ~(x - 1) - 1),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are heuristics?,휴리스틱이란 무엇인가요?,"Any approach to problem solving, learning, or discovery that employs a practical method not guaranteed to be optimal or perfect, but sufficient for the immediate goals. Where finding an optimal solution is impossible or impractical, heuristic methods can be used to speed up the process of finding a satisfactory solution. Heuristics can be mental shortcuts that ease the cognitive load of making a decision. Examples of this method include using a rule of thumb, an educated guess, an intuitive judgment, stereotyping, profiling, or common sense","문제 해결, 학습 또는 발견에 대한 모든 접근 방식은 최적이거나 완벽하다고 보장되지 않지만 즉각적인 목표에 충분합니다. 최적의 해결책을 찾는 것이 불가능하거나 비현실적인 경우 휴리스틱 방법을 사용하여 만족하는 해결책을 찾는 과정을 가속화할 수 있습니다. 휴리스틱은 의사 결정의 인지적 부담을 덜어주는 정신적 지름길이 될 수 있습니다. 이 방법의 예로는 경험 법칙, 교육받은 추측, 직관적 판단, 고정관념, 프로파일링 또는 상식을 사용하는 것이 있습니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is stable sorting?,안정적인 정렬이란 무엇인가요?,Items with the same key are sorted based on their relative position in the original permutation,동일한 키를 가진 항목은 원래 순열에서 상대적 위치를 기준으로 정렬됩니다,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is another name for a trie?,트라이의 다른 이름은 무엇인가요?,Prefix tree or a radix tree.,접두사 트리 또는 래딕스 트리.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is internal sorting?,내부 정렬이란 무엇인가요?,"An internal sort is any data sorting process that takes place entirely within the main memory of a computer. This is possible whenever the data to be sorted is small enough to all be held in the main memory. For sorting larger datasets, it may be necessary to hold only a chunk of data in memory at a time, since it won't all fit. The rest of the data is normally held on some larger, but slower medium, like a hard-disk. Any reading or writing of data to and from this slower media can slow the sortation process considerably.",내부 정렬은 컴퓨터의 메인 메모리 내에서 전적으로 이루어지는 모든 데이터 정렬 프로세스입니다. 이는 정렬할 데이터가 모두 메인 메모리에 저장될 수 있을 만큼 작을 때마다 가능합니다. 더 큰 데이터셋을 정렬하려면 한 번에 메모리에 데이터 덩어리만 보관해야 할 수도 있습니다. 나머지 데이터는 일반적으로 하드 디스크와 같이 더 크지만 느린 매체에 보관됩니다. 이 느린 매체를 통해 데이터를 읽거나 작성하면 정렬 프로세스가 상당히 느려질 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is external sorting?,외부 정렬이란 무엇인가요?,"External sorting is a term for a class of sorting algorithms that can handle massive amounts of data. External sorting is required when the data being sorted do not fit into the main memory of a computing device (usually RAM) and instead they must reside in the slower external memory (usually a hard drive). External sorting typically uses a hybrid sort-merge strategy. In the sorting phase, chunks of data small enough to fit in main memory are read, sorted, and written out to a temporary file. In the merge phase, the sorted subfiles are combined into a single larger file.

Mergesort is typically preferred.","외부 정렬은 방대한 양의 데이터를 처리할 수 있는 정렬 알고리즘의 한 종류를 의미합니다. 정렬되는 데이터가 컴퓨팅 장치의 메인 메모리(일반적으로 RAM)에 맞지 않고 느린 외부 메모리(일반적으로 하드 드라이브)에 있어야 할 때 외부 정렬이 필요합니다. 외부 정렬은 일반적으로 하이브리드 정렬 병합 전략을 사용합니다. 정렬 단계에서는 메인 메모리에 들어갈 만큼 작은 데이터 덩어리를 읽고, 정렬한 후 임시 파일로 작성합니다. 병합 단계에서는 정렬된 하위 파일을 하나의 더 큰 파일로 결합합니다.

일반적으로 병합이 선호됩니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are 2 advantages of merge sort?,Merge Sort의 두 가지 장점은 무엇인가요?,"- suitable for a linked list
- suitable for external sort","- 링크된 목록에 적합한
- 외부 정렬에 적합한",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is disadvantages of merge sort?,Merge Sort의 단점은 무엇인가요?,Need an extra buffer to hold the merged data,병합된 데이터를 보관하려면 추가 버퍼가 필요합니다,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are 3 advantages of heap sort?,Heap Sort의 3가지 장점은 무엇인가요?,"- don't need recursion
- suitable for large data
- locality of data","- 재귀가 필요하지 않습니다
- 대용량 데이터에 적합한
- 데이터의 지역성",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a disadvantage of heap sort?,Heap Sort의 단점은 무엇인가요?,Usually slower than merge sort and quick sort.,보통 Merge Sort과 빠른 정렬보다 느립니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a articulation vertex?,관절 정점이란 무엇인가요?,The weakest point in a graph.,그래프에서 가장 약한 점.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the chromatic number?,반음계 숫자는 무엇인가요?,The smallest number of colors needed for an edge coloring of a graph.,그래프의 가장자리 색칠에 필요한 최소 색상 수입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are long-term issues involved in machine learning?,머신 러닝과 관련된 장기적인 문제는 무엇인가요?,"- technical debt
- lack of clear abstraction barriers 
- changing anything changes everything
- feedback loop - usage based on your model changes the model
- attractive nuisance (using a successful model in one domain where it doesn't fit in another)
- non-stationarity - stick with current data, or get new, and how much of old data to reuse
- tracking data dependencies - where did the data come from, how to get new data","- 기술 부채
- 명확한 추상화 장벽의 부족 
- 모든 것을 바꾸는 것은 모든 것을 바꿉니다
- 피드백 루프 - 모델에 따른 사용 방식이 모델을 변경합니다
- 매력적인 성가심 (다른 도메인에 맞지 않는 성공적인 모델을 사용하여)
- 비정상성 - 현재 데이터를 유지하거나 새 데이터를 얻거나 재사용할 오래된 데이터의 양
- 데이터 종속성 추적 - 데이터 출처, 새 데이터를 얻는 방법",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many rows are in a 12 x 16 matrix?,12 x 16 행렬에는 몇 줄이 있나요?,12,12,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many columns are in a 12 x 16 matrix?,12 x 16 행렬에는 몇 개의 열이 있나요?,16,16,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
In linear algebra a vector of 12 elements has how many rows?,선형 대수학에서 12개 원소의 벡터는 몇 개의 행을 가지고 있나요?,12,12,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
In linear algebra a vector of 12 elements has how many columns?,선형 대수학에서 12개 원소의 벡터는 몇 개의 열을 가지고 있나요?,1,1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
In linear algebra a 12-dimensional vector has how many rows?,선형 대수학에서 12차원 벡터는 몇 개의 행을 가지고 있나요?,12,12,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
In linear algebra a vector of 12-dimensional vector has how many columns?,선형 대수학에서 12차원 벡터의 벡터는 몇 개의 열을 가지고 있나요?,1,1,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"When multiplying a 4x3 matrix and a 3x6 matrix, what are the dimensions of the final matrix?",4x3 행렬과 3x6 행렬을 곱할 때 최종 행렬의 크기는 어떻게 되나요?,4x6,4x6,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Can you multiply a 3x2 and a 2x3 matrix?,3x2 행렬과 2x3 행렬을 곱할 수 있나요?,Yes,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Can you multiply a 3x2 and a 3x2 matrix?,3x2 행렬과 3x2 행렬을 곱할 수 있나요?,No,아니요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Can you multiply a 3x2 and a 2x6 matrix?,3x2와 2x6 행렬을 곱할 수 있나요?,Yes,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"When multiplying a 5x2 matrix and a 2x5 matrix, what are the dimensions of the final matrix?",5x2 행렬과 2x5 행렬을 곱할 때 최종 행렬의 크기는 어떻게 되나요?,5x5,5x5,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is matrix multiplication commutative? Does AxB = BxA?,행렬 곱셈은 가환적인가요? AxB = BxA인가요?,No.,아니요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is matrix multiplication associative? Does (AxB)xC = Ax(BxC)?,행렬 곱셈은 연관성이 있나요? (AxB)xC = Ax(BxC)인가요?,Yes,네.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What would the identity matrix look like to multiply with an MxN matrix to get itself?,항등 행렬이 MxN 행렬과 곱하여 자신을 얻는 모습은 어떻게 될까요?,An NxN matrix that is all zeroes except it has 1s on a top-left to bottom-right diagonal.,NxN 행렬은 왼쪽 위에서 오른쪽 아래 대각선에 1이 있는 것을 제외하고는 모두 0입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What must at least be true about a matrix for it to have an inverse?,행렬이 역행렬을 가지려면 적어도 행렬에 대해 무엇이 참이어야 하나요?,It must be square.,정사각형이어야 합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does it mean to invert a matrix?,행렬을 반전시킨다는 것은 무엇을 의미하나요?,Multiplying it by a specific matrix so that the product is the identity matrix.,특정 행렬에 곱하여 곱이 항등 행렬이 되도록 합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What Python library computes the inverse of a matrix?,행렬의 역행렬을 계산하는 파이썬 라이브러리는 무엇인가요?,"numpy.linalg.inv
or
numpy.linalg.pinv which can solve when the matrix is non-invertible","numpy.linalg.inv
또는
행렬이 가역적이지 않을 때 해결할 수 있는 numpy.linalg.pinv",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are 2 words for matrices that are invertible?,가역 행렬의 두 단어는 무엇인가요?,"- singular
- degenerate","- 단수의
- 퇴화된",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"If A is a matrix and Aij is the ith row, jth column, what is the traspose B?","A가 행렬이고 Aij가 i번째 행, j번째 열인 경우, 사다리꼴 B는 무엇인가요?",Bji,비지,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is another name for quadratic?,이차의 다른 이름은 무엇인가요?,2nd-order polynomial,이차 다항식,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is supervised learning?,지도 학습이란 무엇인가요?,"Supervised learning is the machine learning task of inferring a function from labeled training data. The training data consist of a set of training examples. In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal).","Supervised learning is the machine learning task of inferring a function from labeled training data. The training data consist of a set of training examples. In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal).",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a regression problem?,회귀 문제란 무엇인가요?,"One that predicts a continuously valued output. May refer specifically to the estimation of continuous response variables, as opposed to the discrete response variables used in classification.",연속적인 값의 출력을 예측하는 것. 분류에 사용되는 이산 반응 변수와는 달리 연속 반응 변수의 추정을 구체적으로 참조할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a classification problem?,분류 문제란 무엇인가요?,"The problem of identifying to which of a set of categories (sub-populations) a new observation belongs, on the basis of a training set of data containing observations (or instances) whose category membership is known.",범주 구성원이 알려진 관찰(또는 인스턴스)을 포함하는 학습 데이터 세트를 기반으로 새로운 관찰이 어떤 범주(하위 집단)에 속하는지 식별하는 문제입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is unsupervised learning?,비지도 학습이란 무엇인가요?,"Unsupervised learning is the machine learning task of inferring a function to describe hidden structure from unlabeled data. Since the examples given to the learner are unlabeled, there is no error or reward signal to evaluate a potential solution. This distinguishes unsupervised learning from supervised learning and reinforcement learning.","Unsupervised learning is the machine learning task of inferring a function to describe hidden structure from unlabeled data. Since the examples given to the learner are unlabeled, there is no error or reward signal to evaluate a potential solution. This distinguishes unsupervised learning from supervised learning and reinforcement learning.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the 2 types of problems that utilize supervised learning?,지도 학습을 활용하는 두 가지 유형의 문제는 무엇인가요?,Regression and classification,회귀 및 분류,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In machine learning, what is the symbol m used for?",기계 학습에서 기호 m은 무엇에 사용되나요?,the number of training examples.,훈련 예시의 수.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is another term for linear regression with one variable?,변수가 하나인 선형 회귀의 다른 용어는 무엇인가요?,Univariate linear regression,단변량 선형 회귀,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is gradient descent?,경사 하강법이란 무엇인가요?,"Gradient descent is a first-order iterative optimization algorithm. To find a local minimum of a cost function using gradient descent, one takes steps proportional to the negative of the gradient (partial derivative or tangent) of the function at the current point.",경사 하강법은 1차 반복 최적화 알고리즘입니다. 경사 하강법을 사용하여 비용 함수의 국소 최소값을 구하려면 현재 시점에서 함수의 경사(부분 미분 또는 탄젠트)의 음수에 비례하는 단계를 밟습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is it called when all training examples are used to calculate gradient descent?,모든 훈련 예제를 사용하여 경사 하강법을 계산할 때 이를 무엇이라고 하나요?,batch gradient descent,배치 경사 하강법,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is another term for linear regression with multiple variables?,여러 변수가 있는 선형 회귀의 다른 용어는 무엇인가요?,Multivariate linear regression,다변량 선형 회귀,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Why is feature scaling important?,기능 확장이 중요한 이유는 무엇인가요?,"Without feature scaling, it can take gradient descent much longer to find the local minimum. The function may oscillate in small movements for much longer.",특징 스케일링이 없으면 지역 최소값을 찾는 데 경사 하강이 훨씬 더 오래 걸릴 수 있습니다. 함수는 작은 움직임으로 훨씬 더 오래 진동할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is is good range to scale features down to?,기능을 어느 정도까지 확장하기에 좋은 범위인가요?,"-1 to +1, or Ng's range: -3 to +3",-1에서 +1 또는 Ng의 범위: -3에서 +3,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is mean normalization?,평균 정규화란 무엇인가요?,A method of scaling a feature's values so that they all fall within a range relative to each other.,기능의 값을 모두 서로 상대적인 범위 내에 있도록 스케일링하는 방법입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a good range for mean normalization?,평균 정규화를 위한 좋은 범위는 무엇인가요?,-0.5 to +0.5,-0.5에서 +0.5까지,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you calculate mean normalization over a set of features?,특징 집합에 대한 평균 정규화를 어떻게 계산할 수 있나요?,"for each x: xi = (xi - avg(x)) / (max_x - min_x)

(max_x - min_x) can be replaced with the standard deviation","각 x에 대해: xi = (xi - avg(x)) / (max_x - min_x)

(max_x - min_x)는 표준 편차로 대체할 수 있습니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"Given a sufficiently small alpha, what can you expect from gradient descent?","충분히 작은 알파가 주어졌을 때, 경사 하강에서 무엇을 기대할 수 있나요?",That it will eventually converge.,결국 수렴할 것입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does Andrew Ng use to find an appropriate alpha for gradient descent?,앤드류 응은 경사 하강에 적합한 알파를 찾기 위해 무엇을 사용하나요?,"0.001
0.003
0.01
0.03
0.1
0.3
1","0.001
0.003
0.01
0.03
0.1
0.3
1",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How can you get your data to fit better using higher order terms in linear regression?,선형 회귀에서 고차 항을 사용하여 데이터를 더 잘 맞추려면 어떻게 해야 하나요?,"You can take the data and square it, cube it, etc. 

x1 = (somevalue)^2
x7 = (somevalue)^4

This is applied to data, not the function. The function still is theta1*x1 + theta2*x2, etc","데이터를 가져와서 제곱하거나 큐브를 맞추는 등의 작업을 수행할 수 있습니다. 

x1 = (somevalue)^2
x7 = (somevalue)^4

이것은 함수가 아닌 데이터에 적용됩니다. 함수는 여전히 theta1*x1 + theta2*x2 등입니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What can affect invertibility in a matrix?,행렬의 가역성에 영향을 미칠 수 있는 것은 무엇인가요?,"- 2 more more features are linearly dependent or redundant (size in meters and size in ft) - remove redundant features
- too few training examples (m) to features (n): m <= n  (remove some features or use regularization)","- 2 more more features are linearly dependent or redundant (size in meters and size in ft) - remove redundant features
- too few training examples (m) to features (n): m <= n  (remove some features or use regularization)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
When can we use the normal equation instead of gradient descent to minimize J(theta)?,언제 경사 하강 대신 정규 방정식을 사용하여 J(theta)를 최소화할 수 있을까요?,"- when we have fewer than 10,000 features
- have to ensure invertibility","- 기능이 10,000개 미만일 때
- 가역성을 보장해야 합니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does numpy.allclose() do?,numpy.allclose()는 무엇을 하나요?,Returns True if two arrays are element-wise equal within a tolerance.,두 배열이 허용 오차 내에서 요소별로 같으면 True를 반환합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Is feature scaling needed when using the normal equation?,정규 방정식을 사용할 때 특징 스케일링이 필요한가요?,No,아니요.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the normal equation?,일반 방정식은 무엇인가요?,"An equation that can minimize J(theta), solving for theta, instead of using gradient descent.

Also called ordinary least squares (OLS) or linear least squares, it's a method for estimating the unknown parameters in a linear regression model, with the goal of minimizing the sum of the squares of the differences between the observed responses in the given dataset and those predicted by a linear function of a set of explanatory variables.","기울기 하강법 대신 J(theta)를 최소화하여 세타를 구할 수 있는 방정식.

일반 최소 제곱(OLS) 또는 선형 최소 제곱이라고도 하는 이 방법은 선형 회귀 모델에서 알려지지 않은 매개변수를 추정하는 방법으로, 주어진 데이터셋에서 관찰된 반응과 설명 변수 집합의 선형 함수로 예측된 반응 간의 차이의 제곱 합을 최소화하는 것을 목표로 합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What Python determines the pseudo-inverse of a matrix?,행렬의 의사 역행렬을 결정하는 파이썬은 무엇인가요?,numpy.linalg.pinv,numpy.linalg.pinv,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is treated as false in Python?,파이썬에서 거짓으로 취급되는 것은 무엇인가요?,"• False
• None
• [] (an empty list)
• {} (an empty dict)
• """"
• set()
• 0
• 0.0","• False
• None
• [] (an empty list)
• {} (an empty dict)
• """"
• set()
• 0
• 0.0",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a dot product?,점 제품이란 무엇인가요?,"The dot product of two vectors is the sum of their componentwise products.
v_1 * w_1 + ... + v_n * w_n","두 벡터의 내적은 그들의 구성 요소별 곱의 합입니다.
v_1 * w_1 + ... + v_n * w_n",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the quantile?,분위수는 무엇인가요?,The number at a given percentile of the data.,주어진 데이터 백분위수에서의 숫자.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the mode?,모드가 무엇인가요?,Most-common value(s) in a set of data. Could have more than one if there are 2 subsets with the same number of values.,데이터 집합에서 가장 일반적인 값입니다. 동일한 수의 값을 가진 두 개의 하위 집합이 있는 경우 둘 이상의 값을 가질 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is dispersion?,분산이란 무엇인가요?,Dispersion refers to measures of how spread out our data is. Typically they’re statistics for which values near zero signify not spread out at all and for which large values (whatever that means) signify very spread out.,분산은 데이터가 얼마나 분산되어 있는지를 측정하는 척도를 의미합니다. 일반적으로 0에 가까운 값은 전혀 분산되지 않고 큰 값(의미가 무엇이든)은 매우 분산되어 있음을 나타내는 통계입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is covariance?,공분산이란 무엇인가요?,The mean value of the product of the deviations of two variates from their respective means.,두 편차의 곱의 평균값은 각각의 평균에서 다릅니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a random variable?,랜덤 변수란 무엇인가요?,"A random variable is a variable whose possible values have an associated probability distribution.

A very simple random variable equals 1 if a coin flip turns up heads and 0 if the flip turns up tails. A more complicated one might measure the number of heads observed when flipping a coin 10 times or a value picked from range(10) where each number is equally likely.","확률 변수는 가능한 값들이 연관된 확률 분포를 가지는 변수입니다.

동전 던지기가 앞면이 나오면 1, 뒷면이 나오면 0이 되는 매우 간단한 확률 변수입니다. 더 복잡한 변수는 동전 던지기를 10번 할 때 관찰되는 앞면의 수를 측정하거나 각 숫자가 동일할 가능성이 있는 범위(10)에서 선택한 값을 측정할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is PCA and what is it used for?,PCA란 무엇이며 무엇에 사용되나요?,Principal component analysis. We use it to extract one or more dimensions that capture as much of the variation in the data as possible.,주성분 분석. 우리는 이를 사용하여 데이터 변동의 가능한 한 많은 부분을 포착하는 하나 이상의 차원을 추출합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a model?,모델이란 무엇인가요?,A specification of a mathematical (or probabilistic) relationship that exists between different variables.,서로 다른 변수들 사이에 존재하는 수학적(또는 확률적) 관계의 명세.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is machine learning?,머신 러닝이란 무엇인가요?,Creating and using models that are learned from data.,데이터에서 학습한 모델을 만들고 사용합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the degree of a vertex?,정점의 차수는 무엇인가요?,"The number of edges incident of the vertex, with loops counted twice.",정점에 입사하는 모서리의 수와 루프가 두 번 계산됩니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is quick select?,퀵 셀렉트란 무엇인가요?,"A selection algorithm to find the kth smallest element in an unordered list. Quickselect uses the same overall approach as quicksort, choosing one element as a pivot and partitioning the data in two based on the pivot, accordingly as less than or greater than the pivot. However, instead of recursing into both sides, as in quicksort, quickselect only recurses into one side - the side with the element it is searching for. This reduces the average complexity from O(n log n) to O(n).",정렬되지 않은 목록에서 k번째로 작은 요소를 찾기 위한 선택 알고리즘입니다. 퀵셀렉트는 퀵소트와 동일한 전체 접근 방식을 사용하여 하나의 요소를 피벗으로 선택하고 피벗을 기준으로 데이터를 두 개로 분할하여 피벗보다 작거나 크게 만듭니다. 그러나 퀵셀렉트는 퀵소트처럼 양쪽으로 재귀하는 대신 검색하는 요소가 있는 쪽인 한쪽으로만 재귀합니다. 이렇게 하면 평균 복잡성이 O(n 로그 n)에서 O(n)으로 줄어듭니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is preemption?,선점이란 무엇인가요?,"Preemption is the act of temporarily interrupting a task being carried out by a computer system, without requiring its cooperation, and with the intention of resuming the task at a later time. Such a change is known as a context switch.",선점은 컴퓨터 시스템이 수행하는 작업을 협력 없이 일시적으로 중단하고 나중에 작업을 재개할 의도로 하는 행위입니다. 이러한 변경은 컨텍스트 전환이라고 합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is an inverted index?,역지수란 무엇인가요?,"An index data structure storing a mapping from content, such as words or numbers, to its locations in a database file, or in a document or a set of documents (named in contrast to a Forward Index, which maps from documents to content). The purpose of an inverted index is to allow fast full text searches, at a cost of increased processing when a document is added to the database.","단어나 숫자와 같은 콘텐츠에서 데이터베이스 파일, 문서 또는 문서 집합(문서에서 콘텐츠로 매핑하는 Forward Index와는 대조적으로 명명됨)의 위치로 매핑을 저장하는 인덱스 데이터 구조입니다. 역 인덱스의 목적은 문서가 데이터베이스에 추가될 때 처리 비용을 증가시키면서 빠른 전체 텍스트 검색을 가능하게 하는 것입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is set partition?,세트 partition이란 무엇인가요?,"A partitioning of elements of some universal set into a collection of disjointed subsets. Thus, each element must be in exactly one subset.",어떤 보편적 집합의 요소들을 분리된 부분 집합으로 나누는 것입니다. 따라서 각 요소는 정확히 하나의 부분 집합에 있어야 합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a maximum spanning tree?,최대 신장 트리란 무엇인가요?,A spanning tree of a weighted graph having maximum weight. It can be computed by negating the edges and running either Prim's or Kruskal's algorithms.,최대 가중치를 가진 가중 그래프의 스패닝 트리입니다. 간선을 부정하고 Prim 또는 Kruskal의 알고리즘을 실행하여 계산할 수 있습니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a minimum product spanning tree and when would you use it?,최소 제품 스패닝 트리는 무엇이며 언제 사용하시겠습니까?,"The cost of a tree is the product of all the edge weights in the tree, instead of the sum of the weights. Since log(a*b) = log(a) + log(b), the minimum spanning tree on a graph whose edge weights are replaced with their logarithms gives the minimum product spanning tree on the original graph.
You would use it to minimize the product.","트리의 비용은 가중치의 합 대신 트리의 모든 엣지 가중치의 곱입니다. log(a*b) = log(a) + log(b)이므로 엣지 가중치가 로그로 대체된 그래프의 최소 스패닝 트리는 원래 그래프의 최소 곱 스패닝 트리를 제공합니다.
제품을 최소화하는 데 사용할 수 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a rolling hash?,롤링 해시란 무엇인가요?,"A rolling hash (also known as a rolling checksum) is a hash function where the input is hashed in a window that moves through the input.

One of the main applications is the Rabin-Karp string search algorithm, which uses the rolling hash.","롤링 해시(롤링 체크섬이라고도 함)는 입력을 통해 이동하는 창에서 입력이 해시되는 해시 함수입니다.

주요 응용 프로그램 중 하나는 롤링 해시를 사용하는 라빈-카프 문자열 검색 알고리즘입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Euclidean GCD algorithm in Python?,파이썬에서 유클리드 GCD 알고리즘은 무엇인가요?,"def gcd(a, b):
    while a:
        b, a = a, b % a
    return b","def gcd(a, b):
    while a:
        b, a = a, b % a
    return b",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Rabin-Karp algorithm?,라빈-카프 알고리즘이란 무엇인가요?,"Compute hash codes of each substring whose length is the length of s, such as a function with the property that the hash code of a string is an additive function of each individual character. Get the hash code of a sliding window of characters and compare if the hash matches.",문자열의 해시 코드가 각 개별 문자의 덧셈 함수라는 속성을 가진 함수와 같이 길이가 s인 각 하위 문자열의 해시 코드를 계산합니다. 문자 슬라이딩 창의 해시 코드를 가져와 해시가 일치하는지 비교합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is sharding?,sharding이란 무엇인가요?,"Sharding is a type of database partitioning that separates very large databases the into smaller, faster, more easily managed parts called data shards.","sharding은 매우 큰 데이터베이스를 데이터 샤드라고 하는 더 작고, 빠르고, 더 쉽게 관리할 수 있는 부분으로 나누는 일종의 데이터베이스 분할입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is von Neumann Architecture?,폰 노이만 건축이란 무엇인가요?,"A model for modern computer organization created by John von Neumann, that had two main features:
1) Both data & instructions are stored in the same place
2) Units that store information are different from units that process information","존 폰 노이만이 만든 현대 컴퓨터 조직 모델은 두 가지 주요 특징을 가지고 있었습니다:
1) 데이터와 지침이 모두 같은 장소에 저장됩니다
2) 정보를 저장하는 단위는 정보를 처리하는 단위와 다릅니다",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the fetch-execute cycle?,가져오기-실행 주기는 무엇인가요?,"A 4 part system that describes how actions are performed in the CPU. There are 4 parts to this cycle:
1) Fetch instructions
2) Decode instructions
3) Get data if needed
4) Execute the instructions","CPU에서 작업이 수행되는 방식을 설명하는 4부 시스템입니다. 이 사이클에는 4부가 있습니다:
1) 가져오기 지침
2) 명령어 해독
3) 필요한 경우 데이터 가져오기
4) 지침 실행",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does a Control Unit (CU) do?,제어 장치(CU)는 무엇을 하나요?,"Controls, organizes and deals with all the process and instruction the CPU receives. It is also in charge of the Fetch-Execute Cycle. Has two special purpose registers: the Instruction Register and the Program Counter.","CPU가 받는 모든 프로세스와 명령을 제어, 조직 및 처리합니다. 또한 가져오기-실행 주기도 담당합니다. 명령 레지스터와 프로그램 카운터라는 두 가지 특수 목적 레지스터가 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the time complexity of breadth-first search?,너비 우선 검색의 time complexity는 얼마인가요?,"O(m + n) 
uses queue","O(m + n) 
대기열 사용",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the time complexity of breadth-first search?,너비 우선 검색의 time complexity는 얼마인가요?,"O(m + n) 
uses stack","O(m + n) 
스택 사용",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the time and space complexity of minimum edit distance using dynamic programming?,동적 프로그래밍을 사용하는 최소 편집 거리의 시간과 space complexity는 얼마인가요?,"Time O(mn)
Space O(mn)","시간 O(mn)
공간 O(mn)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the time complexity of Floyd-Warshall?,플로이드 워샬의 time complexity는 무엇인가요?,Theta(n^3),세타(n^3),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the log of n! ?,n의 로그는 무엇인가요?,n log n,n 로그 n,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the time and space complexity of Bellman-Ford?,벨먼-포드의 시간과 공간의 복잡성은 무엇인가요?,"Time : O (|V| |E|) or Theta(n^3) 
Space: O (|V|)","Time : O (|V| |E|) or Theta(n^3) 
공간: O (|V|)",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the Bellman–Ford algorithm?,벨먼-포드 알고리즘이란 무엇인가요?,"An algorithm that computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph. It is slower than Dijkstra's algorithm for the same problem, but more versatile, as it is capable of handling graphs in which some of the edge weights are negative numbers.",가중 그래프에서 단일 소스 정점에서 다른 모든 정점까지의 최단 경로를 계산하는 알고리즘입니다. 동일한 문제에 대한 Dijkstra의 알고리즘보다 느리지만 일부 에지 가중치가 음수인 그래프를 처리할 수 있기 때문에 더 다재다능합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a Hamiltonian cycle?,해밀턴 사이클이란 무엇인가요?,"Given an undirected graph G = (V, E), does there exist a simple
cycle Γ that contains every node in V ?
Certificate is a permutation of the n nodes, contain each node in v exactly once, there is an edge btw each pair of adj nodes in the permutation.","방향이 없는 그래프 G = (V, E)가 주어졌을 때, 다음과 같은 간단한 것이 존재하는가
V의 모든 노드를 포함하는 사이클 γ?
인증서는 n개의 노드를 순열한 것으로, v에 있는 각 노드를 정확히 한 번만 포함합니다. 순열에는 각 adj 노드 쌍에 엣지가 있습니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the set cover problem?,세트 커버 문제는 무엇인가요?,"Given a set U of elements, a collection S1, S2, ..., Sm of subsets of
U, and an integer k, does there exist a collection of ≤ k of these sets whose union is equal to U ?","원소 집합 U가 주어졌을 때, 집합 S1, S2, ..., 부분 집합의 Sm
U와 정수 k의 합집합이 U와 같은 ≤ k개의 집합이 존재하나요?",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the time and space complexity of heapsort?,힙소트의 시간과 공간 복잡성은 무엇인가요?,"O(n lg n) time
O(1) space","O(n lg n) time
O(1) 공간",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the time and space complexity of merge sort?,병합 유형의 시간과 공간 복잡성은 무엇인가요?,"O(n lg n) time
O(n) space","O(n lg n) time
O(n) 공간",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How would you divide up a data set for training and testing?,훈련 및 테스트를 위해 데이터 세트를 어떻게 나누시겠습니까?,"Split your data set, so that two-thirds of it is used to train the model, after which we test/measure the model’s performance on the remaining third.","데이터 세트를 분할하여 그 중 3분의 2가 모델을 훈련시키는 데 사용되도록 하고, 그 후 나머지 3분의 1에서 모델의 성능을 테스트/측정합니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How would you split up a data set in order to choose from multiple models?,여러 모델 중에서 데이터 세트를 선택하려면 어떻게 해야 하나요?,"In such a situation, you should split the data into three parts: a training set for building models, a validation set for choosing among trained models (called the cross-validation set), and a test set for judging the final model.","이러한 상황에서는 데이터를 세 부분으로 나누어야 합니다: 모델을 구축하기 위한 훈련 세트, 훈련된 모델 중에서 선택하기 위한 검증 세트(교차 검증 세트라고 함), 그리고 최종 모델을 판단하기 위한 테스트 세트입니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a Type 1 error?,타입 1 오류란 무엇인가요?,A false positive,거짓 양성,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is a Type 2 error?,타입 2 오류란 무엇인가요?,A false negative,거짓 음성,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In statistics, how would you calculate precision?",통계학에서 정밀도를 어떻게 계산하시겠습니까?,true_pos / (true_pos + false_pos),true_pos / (true_pos + false_pos),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In statistics, how would you calculate recall?",통계학에서 리콜을 어떻게 계산하시겠습니까?,true_pos / (true_pos + false_neg),true_pos / (true_pos + false_neg),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In statistics, what does precision measure?",통계에서 정밀도는 무엇을 측정하나요?,Precision measures how accurate our positive predictions are.,정밀도는 우리의 긍정적인 예측이 얼마나 정확한지를 측정합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
"In statistics, what does recall measure?",통계에서 회상은 무엇을 측정하나요?,Recall measures what fraction of the positives our model identified.,리콜은 우리 모델이 식별한 긍정적인 요소의 비율을 측정합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How would you calculate the F1 score?,F1 점수를 어떻게 계산하시겠습니까?,2 * precision * recall / (precision + recall),2 * 정밀도 * 리콜 / (정밀도 + 리콜),CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is another name for the F1 score?,F1 점수의 다른 이름은 무엇인가요?,the harmonic mean of precision and recall,정밀도와 회상의 조화 평균,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is the trade-off between precision and recall?,정밀도와 재현율 사이의 균형은 무엇인가요?,"A model that predicts “yes” when it’s even a little bit confident will probably have a high recall but a low precision; a model that predicts “yes” only when it’s extremely confident is likely to have a low recall and a high precision.

Alternatively, you can think of this as a trade-off between false positives and false negatives. Saying “yes” too often (high recall) will give you lots of false positives; saying “no” too often will give you lots of false negatives (high precision).","조금이라도 자신감이 있을 때 ""예""를 예측하는 모델은 높은 재현율을 가지지만 정밀도는 낮을 것입니다. 극도로 자신감이 있을 때만 ""예""를 예측하는 모델은 재현율이 낮고 정밀도가 높을 가능성이 높습니다.

또는 이것을 거짓 양성과 거짓 음성 사이의 절충안으로 생각할 수도 있습니다. ""예""를 너무 자주 말하면 (높은 기억력) 많은 거짓 양성이 나오고, ""아니오""를 너무 자주 말하면 (높은 정확도) 많은 거짓 음성이 나옵니다.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
High bias and low variance typically correspond to _______.,높은 편향과 낮은 분산은 일반적으로 ______에 해당합니다.,underfitting,과소적합,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Low bias but very high variance typically correspond to _______.,편향은 낮지만 분산이 매우 높은 경우 일반적으로 _____.에 해당합니다.,overfitting,과적합,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What can you do when your model has high bias (which means it performs poorly even on your training data)?,"모델의 편향이 높을 때(즉, 훈련 데이터에서도 성능이 좋지 않음을 의미함) 어떻게 할 수 있나요?",One thing to try is adding more features.,한 가지 시도해 볼 수 있는 것은 더 많은 기능을 추가하는 것입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What can you do if your model suffers from overfitting due to high variance?,모델이 높은 분산으로 인해 과적합으로 고통받는 경우 어떻게 할 수 있나요?,"You can remove features. Another solution is to obtain more training examples (if you can).
Or use regularization.","기능을 제거할 수 있습니다. 또 다른 해결책은 더 많은 훈련 예제를 얻는 것입니다 (가능하다면).
또는 정규화를 사용하세요.",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What does BFGS stand for?,BFGS는 무엇을 의미하나요?,Broyden–Fletcher–Goldfarb–Shanno algorithm,브로이든-플레처-골드파브-샤노 알고리즘,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What is L-BFGS?,L-BFGS란 무엇인가요?,Limited-memory BFGS (L-BFGS or LM-BFGS) is an optimization algorithm in the family of quasi-Newton methods that approximates the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm using a limited amount of computer memory. It is a popular algorithm for parameter estimation in machine learning.,제한 메모리 BFGS(L-BFGS 또는 LM-BFGS)는 제한된 양의 컴퓨터 메모리를 사용하여 Broyden–Fletcher–Goldfarb–Shanno(BFGS) 알고리즘을 근사하는 준-뉴턴 방법 계열의 최적화 알고리즘입니다. 이 알고리즘은 머신 러닝에서 매개변수 추정에 널리 사용되는 알고리즘입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are some alternative algorithms that can optimize for a logistic regression problem?,로지스틱 회귀 문제에 최적화할 수 있는 대체 알고리즘에는 어떤 것이 있나요?,"- conjugate gradient
- BGFS
- L-BGFS","- 켤레 구배
- BGFS
- L-BGFS",CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What makes neural networks superior over regression or classification?,신경망이 회귀나 분류보다 우월한 이유는 무엇인가요?,Each hidden layer learns its own features instead of being given features.,각 은닉층은 주어진 특징 대신 고유한 특징을 학습합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How should you initialize Theta for a neural network?,신경망을 위해 세타를 어떻게 초기화해야 하나요?,Initialize as a matrix of random reals between 0 and 1. Constrain within a range of +/- epsilon using Theta * 2*epsilon - epsilon.,0과 1 사이의 무작위 실수 행렬로 초기화합니다. 세타 * 2*epsilon - epsilon을 사용하여 +/- epsilon 범위 내에서 제약합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the number of neurons (units) at the input layer of a neural network?,신경망의 입력층에 있는 뉴런(단위)의 수는 얼마인가요?,The number of features.,특징의 수.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
What are the number of neurons (units) at the output layer of a neural network performing classification?,분류를 수행하는 신경망의 출력층에 있는 뉴런(단위)의 수는 얼마인가요?,The number of classes you are classifying.,분류하고 있는 클래스의 수입니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
How many hidden layers should there be in a neural network?,신경망에는 몇 개의 숨겨진 층이 있어야 하나요?,"Start with 1 as a default, and if more than one, have the same number of units at each layer. The more the better. The number of units in each hidden layer should be more than, or a multiple of, the input units.",기본값으로 1부터 시작하여 하나 이상이면 각 레이어에서 동일한 수의 단위를 갖습니다. 많을수록 좋습니다. 각 숨겨진 레이어의 단위 수는 입력 단위보다 많거나 여러 개여야 합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Machine learning: What tends to happen with the training error in a linear model as the degree of polynomial increases?,기계 학습: 다항식의 차수가 증가함에 따라 선형 모델에서 학습 오류는 어떻게 발생하는 경향이 있나요?,"The error decreases, but too high a degree of polynomial will cause overfitting.",오차는 감소하지만 다항식의 차수가 너무 높으면 과적합이 발생합니다.,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
Machine learning: What tends to happen with the cross-validation error in a linear model as the degree of polynomial increases?,기계 학습: 다항식의 차수가 증가함에 따라 선형 모델에서 교차 검증 오류는 어떻게 발생하는 경향이 있나요?,"It starts high (high bias) and decreases, reaching a minimum, and then increases (high variance).",높은 편향(높은 편향)에서 시작하여 감소하여 최소값에 도달한 다음 증가합니다(높은 분산).,CS,2.5,2026-02-02 13:11:01,2026-02-02 13:11:01
